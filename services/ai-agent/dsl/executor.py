"""
DSL Executor
Safely parses and executes DSL code generated by the LLM
"""

import ast
import asyncio
from typing import Any, Dict, List, Optional, Union
from dataclasses import dataclass, field
from datetime import datetime
import traceback
import pandas as pd

from .query import Query, ALLOWED_COLUMNS, ALLOWED_SOURCES, QueryValidationError
from .column import col, Column, Condition
from .display import (
    display_table, create_chart, print_stats,
    clear_outputs, get_outputs,
    TableOutput, ChartOutput, StatsOutput
)


@dataclass
class ExecutionResult:
    """Resultado de la ejecución del DSL"""
    success: bool
    code: str
    outputs: List[Union[TableOutput, ChartOutput, StatsOutput]] = field(default_factory=list)
    error: Optional[str] = None
    execution_time_ms: float = 0
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convierte a diccionario para JSON"""
        outputs_data = []
        for output in self.outputs:
            if isinstance(output, TableOutput):
                outputs_data.append({
                    "type": "table",
                    "title": output.title,
                    "columns": output.columns,
                    "rows": output.rows,
                    "total": output.total
                })
            elif isinstance(output, ChartOutput):
                outputs_data.append({
                    "type": "chart",
                    "title": output.title,
                    "chart_type": output.chart_type.value,
                    "plotly_config": output.plotly_config
                })
            elif isinstance(output, StatsOutput):
                outputs_data.append({
                    "type": "stats",
                    "title": output.title,
                    "stats": output.stats
                })
        
        return {
            "success": self.success,
            "code": self.code,
            "outputs": outputs_data,
            "error": self.error,
            "execution_time_ms": round(self.execution_time_ms, 2),
            "timestamp": self.timestamp.isoformat()
        }


class DSLSecurityError(Exception):
    """Error de seguridad en el DSL"""
    pass


class DSLExecutor:
    """
    Ejecutor seguro de código DSL.
    
    - NO usa exec() directo
    - Parsea el AST y ejecuta solo operaciones permitidas
    - Timeout de ejecución
    - Validación estricta de operaciones
    """
    
    # Operaciones permitidas
    ALLOWED_FUNCTIONS = {
        'Query', 'col', 'display_table', 'create_chart', 'print_stats',
        # Nuevas funciones para datos historicos y SEC
        'get_bars', 'get_dilution', 'get_sec_filings', 'get_warrants',
        'add_technicals', 'compare_symbols'
    }
    
    ALLOWED_METHODS = {
        # Query methods
        'select', 'from_source', 'where', 'order_by', 'limit', 'execute',
        # Column methods
        'between', 'isin', 'contains', 'is_null', 'not_null'
    }
    
    def __init__(self, data_provider, timeout_seconds: float = 30.0):
        """
        Inicializa el executor.
        
        Args:
            data_provider: Proveedor de datos para queries
            timeout_seconds: Timeout máximo de ejecución
        """
        self.data_provider = data_provider
        self.timeout = timeout_seconds
    
    def _strip_imports(self, code: str) -> str:
        """
        Elimina lineas de import del codigo.
        El LLM a veces genera imports aunque no son necesarios.
        """
        lines = code.split('\n')
        filtered = []
        for line in lines:
            stripped = line.strip()
            # Ignorar lineas de import
            if stripped.startswith('import ') or stripped.startswith('from '):
                continue
            filtered.append(line)
        return '\n'.join(filtered)
    
    async def execute(self, code: str) -> ExecutionResult:
        """
        Ejecuta codigo DSL de forma segura.
        
        Args:
            code: Codigo DSL generado por el LLM
        
        Returns:
            ExecutionResult con los resultados
        """
        start_time = datetime.now()
        clear_outputs()
        
        # Pre-procesar: eliminar imports que el LLM pueda generar
        clean_code = self._strip_imports(code)
        
        try:
            # 1. Parsear AST
            tree = ast.parse(clean_code)
            
            # 2. Validar seguridad
            self._validate_ast(tree)
            
            # 3. Ejecutar con timeout
            try:
                await asyncio.wait_for(
                    self._execute_ast(tree),
                    timeout=self.timeout
                )
            except asyncio.TimeoutError:
                return ExecutionResult(
                    success=False,
                    code=code,
                    error=f"Timeout: La ejecución excedió {self.timeout} segundos",
                    execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
                )
            
            # 4. Recoger outputs
            outputs = get_outputs()
            
            return ExecutionResult(
                success=True,
                code=code,
                outputs=outputs,
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )
        
        except SyntaxError as e:
            return ExecutionResult(
                success=False,
                code=code,
                error=f"Error de sintaxis: {str(e)}",
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )
        
        except DSLSecurityError as e:
            return ExecutionResult(
                success=False,
                code=code,
                error=f"Error de seguridad: {str(e)}",
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )
        
        except QueryValidationError as e:
            return ExecutionResult(
                success=False,
                code=code,
                error=f"Error de validación: {str(e)}",
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )
        
        except Exception as e:
            return ExecutionResult(
                success=False,
                code=code,
                error=f"Error de ejecución: {str(e)}\n{traceback.format_exc()}",
                execution_time_ms=(datetime.now() - start_time).total_seconds() * 1000
            )
    
    def _validate_ast(self, tree: ast.AST) -> None:
        """
        Valida que el AST solo contiene operaciones permitidas.
        
        Raises:
            DSLSecurityError si hay operaciones no permitidas
        """
        for node in ast.walk(tree):
            # No permitir imports
            if isinstance(node, (ast.Import, ast.ImportFrom)):
                raise DSLSecurityError("Imports no permitidos")
            
            # No permitir exec/eval
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    func_name = node.func.id
                    if func_name in ('exec', 'eval', 'compile', '__import__', 'open', 'input'):
                        raise DSLSecurityError(f"Función '{func_name}' no permitida")
                    if func_name not in self.ALLOWED_FUNCTIONS:
                        raise DSLSecurityError(f"Función '{func_name}' no permitida. "
                                             f"Funciones válidas: {self.ALLOWED_FUNCTIONS}")
                
                elif isinstance(node.func, ast.Attribute):
                    method_name = node.func.attr
                    if method_name not in self.ALLOWED_METHODS:
                        raise DSLSecurityError(f"Método '{method_name}' no permitido. "
                                             f"Métodos válidos: {self.ALLOWED_METHODS}")
            
            # No permitir clases
            if isinstance(node, ast.ClassDef):
                raise DSLSecurityError("Definición de clases no permitida")
            
            # No permitir funciones definidas por el usuario
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                raise DSLSecurityError("Definición de funciones no permitida")
            
            # No permitir acceso a atributos peligrosos
            if isinstance(node, ast.Attribute):
                if node.attr.startswith('_'):
                    raise DSLSecurityError(f"Acceso a atributo privado '{node.attr}' no permitido")
    
    async def _execute_ast(self, tree: ast.AST) -> None:
        """
        Ejecuta el AST de forma controlada.
        """
        # Importar funciones adicionales
        from .functions import add_technicals
        
        # Contexto de ejecucion con funciones permitidas
        local_context = {
            'Query': Query,
            'col': col,
            'display_table': display_table,
            'create_chart': create_chart,
            'print_stats': print_stats,
            # Funciones de datos historicos (wrappers)
            'get_bars': self._wrap_get_bars,
            'get_dilution': self._wrap_get_dilution,
            'get_sec_filings': self._wrap_get_sec_filings,
            'get_warrants': self._wrap_get_warrants,
            'add_technicals': add_technicals,
        }
        
        # Variables para almacenar resultados intermedios
        variables = {}
        
        for node in tree.body:
            await self._execute_node(node, local_context, variables)
    
    async def _execute_node(
        self,
        node: ast.AST,
        context: Dict[str, Any],
        variables: Dict[str, Any]
    ) -> Any:
        """Ejecuta un nodo AST individual"""
        
        if isinstance(node, ast.Expr):
            return await self._execute_node(node.value, context, variables)
        
        elif isinstance(node, ast.Assign):
            # Asignación: total, df = query.execute()
            value = await self._execute_node(node.value, context, variables)
            
            for target in node.targets:
                if isinstance(target, ast.Tuple):
                    # Desempaquetado de tupla
                    if isinstance(value, tuple) and len(target.elts) == len(value):
                        for t, v in zip(target.elts, value):
                            if isinstance(t, ast.Name):
                                variables[t.id] = v
                elif isinstance(target, ast.Name):
                    variables[target.id] = value
            
            return value
        
        elif isinstance(node, ast.Call):
            func = await self._execute_node(node.func, context, variables)
            args = [await self._execute_node(arg, context, variables) for arg in node.args]
            kwargs = {
                kw.arg: await self._execute_node(kw.value, context, variables)
                for kw in node.keywords
            }
            
            # Caso especial: Query().execute() necesita data_provider
            if hasattr(func, '__name__') and func.__name__ == 'execute':
                # Es el método execute de Query
                if asyncio.iscoroutinefunction(func):
                    return await func(self.data_provider)
                return func(self.data_provider)
            
            if asyncio.iscoroutinefunction(func):
                return await func(*args, **kwargs)
            return func(*args, **kwargs)
        
        elif isinstance(node, ast.Attribute):
            value = await self._execute_node(node.value, context, variables)
            return getattr(value, node.attr)
        
        elif isinstance(node, ast.Name):
            if node.id in variables:
                return variables[node.id]
            if node.id in context:
                return context[node.id]
            raise DSLSecurityError(f"Variable '{node.id}' no definida")
        
        elif isinstance(node, ast.Constant):
            return node.value
        
        elif isinstance(node, ast.List):
            return [await self._execute_node(el, context, variables) for el in node.elts]
        
        elif isinstance(node, ast.Tuple):
            return tuple(await self._execute_node(el, context, variables) for el in node.elts)
        
        elif isinstance(node, ast.Dict):
            keys = [await self._execute_node(k, context, variables) for k in node.keys]
            values = [await self._execute_node(v, context, variables) for v in node.values]
            return dict(zip(keys, values))
        
        elif isinstance(node, ast.Compare):
            # Comparaciones: col('x') >= 5
            left = await self._execute_node(node.left, context, variables)
            
            for op, comparator in zip(node.ops, node.comparators):
                right = await self._execute_node(comparator, context, variables)
                
                # Proteccion contra tipos incompatibles (dict/list vs numeros)
                if isinstance(left, (dict, list)) and not isinstance(op, (ast.Eq, ast.NotEq)):
                    return False  # No se puede comparar dict/list con operadores numericos
                
                try:
                    if isinstance(op, ast.GtE):
                        if isinstance(left, Column):
                            return left >= right
                        left = left >= right
                    elif isinstance(op, ast.LtE):
                        if isinstance(left, Column):
                            return left <= right
                        left = left <= right
                    elif isinstance(op, ast.Gt):
                        if isinstance(left, Column):
                            return left > right
                        left = left > right
                    elif isinstance(op, ast.Lt):
                        if isinstance(left, Column):
                            return left < right
                        left = left < right
                    elif isinstance(op, ast.Eq):
                        if isinstance(left, Column):
                            return left == right
                        left = left == right
                    elif isinstance(op, ast.NotEq):
                        if isinstance(left, Column):
                            return left != right
                        left = left != right
                except TypeError:
                    # Tipos incompatibles para comparacion
                    return False
            
            return left
        
        elif isinstance(node, ast.UnaryOp):
            operand = await self._execute_node(node.operand, context, variables)
            if isinstance(node.op, ast.USub):
                return -operand
            elif isinstance(node.op, ast.Not):
                return not operand
            return operand
        
        elif isinstance(node, ast.BinOp):
            left = await self._execute_node(node.left, context, variables)
            right = await self._execute_node(node.right, context, variables)
            
            if isinstance(node.op, ast.Add):
                return left + right
            elif isinstance(node.op, ast.Sub):
                return left - right
            elif isinstance(node.op, ast.Mult):
                return left * right
            elif isinstance(node.op, ast.Div):
                return left / right
            
            raise DSLSecurityError(f"Operador binario no soportado")
        
        elif isinstance(node, ast.IfExp):
            # Expresiones ternarias: x if cond else y
            test = await self._execute_node(node.test, context, variables)
            if test:
                return await self._execute_node(node.body, context, variables)
            return await self._execute_node(node.orelse, context, variables)
        
        else:
            raise DSLSecurityError(f"Nodo AST no soportado: {type(node).__name__}")
    
    # =============================================
    # WRAPPERS PARA FUNCIONES DE DATOS
    # =============================================
    
    async def _wrap_get_bars(self, symbol: str, days: int = 5, timeframe: str = "1h"):
        """Wrapper para get_bars que retorna DataFrame"""
        bars = await self.data_provider.get_bars(symbol, days, timeframe)
        if bars:
            return pd.DataFrame(bars)
        return pd.DataFrame()
    
    async def _wrap_get_dilution(self, symbol: str):
        """Wrapper para get_dilution_profile"""
        profile = await self.data_provider.get_dilution_profile(symbol)
        if profile:
            # Convertir a lista de dicts para consistencia
            return [profile]
        return []
    
    async def _wrap_get_sec_filings(self, symbol: str, form_types: list = None, limit: int = 20):
        """Wrapper para get_sec_filings"""
        filings = await self.data_provider.get_sec_filings(symbol, form_types, limit)
        if filings:
            return pd.DataFrame(filings)
        return pd.DataFrame()
    
    async def _wrap_get_warrants(self, symbol: str):
        """Wrapper para get_warrants"""
        warrants = await self.data_provider.get_warrants(symbol)
        if warrants:
            return pd.DataFrame(warrants)
        return pd.DataFrame()

