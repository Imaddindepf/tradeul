"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFiltering),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   RowExpanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowExpanding),\n/* harmony export */   RowPagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPagination),\n/* harmony export */   RowPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   RowSorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBO0FBRUE7O0NBRUEsR0FDTyxTQUFTQSxXQUNkQyxJQUF3QixFQUN4QkMsS0FBYTtJQUViLE9BQU8sQ0FBQ0QsT0FBTyxPQUFPRSxpQkFBeUJGLFFBQUssY0FDbERHLGdEQUFBLENBQUNILE1BQVNDLFNBRVZEO0FBRUo7QUFFQSxTQUFTRSxpQkFDUEcsU0FBa0I7SUFFbEIsT0FDRUMsaUJBQWlCRCxjQUNqQixPQUFPQSxjQUFjLGNBQ3JCRSxrQkFBa0JGO0FBRXRCO0FBRUEsU0FBU0MsaUJBQWlCRCxTQUFjO0lBQ3RDLE9BQ0UsT0FBT0EsY0FBYyxjQUNyQixDQUFDO1FBQ0MsTUFBTUcsUUFBUUMsT0FBT0MsY0FBYyxDQUFDTDtRQUNwQyxPQUFPRyxNQUFNRyxTQUFTLElBQUlILE1BQU1HLFNBQVMsQ0FBQ1QsZ0JBQWdCO0lBQzVEO0FBRUo7QUFFQSxTQUFTSyxrQkFBa0JGLFNBQWM7SUFDdkMsT0FDRSxPQUFPQSxjQUFjLFlBQ3JCLE9BQU9BLFVBQVVPLFFBQVEsS0FBSyxZQUM5QjtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFFL0U7QUFFTyxTQUFTQyxjQUNkQyxPQUE0QjtJQUU1QjtJQUNBLE1BQU1DLGtCQUErQztRQUNuREMsT0FBTztRQUFJO1FBQ1hDLGVBQWVBLEtBQU07UUFBSTtRQUN6QkMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQUFBOztJQUdMO0lBQ0EsTUFBTSxDQUFDSyxTQUFTLEdBQUdsQiwyQ0FBYyxDQUFDLElBQU87WUFDdkNvQixTQUFTQyxpRUFBV0EsQ0FBUVA7UUFDOUI7SUFFQTtJQUNBLE1BQU0sQ0FBQ0MsT0FBT08sU0FBUyxHQUFHdEIsMkNBQWMsQ0FBQyxJQUFNa0IsU0FBU0UsT0FBTyxDQUFDRyxZQUFZO0lBRTVFO0lBQ0E7SUFDQUwsU0FBU0UsT0FBTyxDQUFDSSxVQUFVLENBQUNDLENBQUFBLE9BQVM7WUFDbkMsR0FBR0EsSUFBSTtZQUNQLEdBQUdaLE9BQU87WUFDVkUsT0FBTztnQkFDTCxHQUFHQSxLQUFLO2dCQUNSLEdBQUdGLFFBQVFFLEtBQUFBOztZQUViO1lBQ0E7WUFDQUMsZUFBZVUsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUYixRQUFRRyxhQUFhLElBQXJCSCxRQUFBQSxRQUFRRyxhQUFhLENBQUdVO1lBQzFCO1FBQ0Y7SUFFQSxPQUFPUixTQUFTRSxPQUFPO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9pbmRleC50c3g/ZWUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJ1xuXG5pbXBvcnQge1xuICBUYWJsZU9wdGlvbnMsXG4gIFRhYmxlT3B0aW9uc1Jlc29sdmVkLFxuICBSb3dEYXRhLFxuICBjcmVhdGVUYWJsZSxcbn0gZnJvbSAnQHRhbnN0YWNrL3RhYmxlLWNvcmUnXG5cbmV4cG9ydCB0eXBlIFJlbmRlcmFibGU8VFByb3BzPiA9IFJlYWN0LlJlYWN0Tm9kZSB8IFJlYWN0LkNvbXBvbmVudFR5cGU8VFByb3BzPlxuXG4vL1xuXG4vKipcbiAqIElmIHJlbmRlcmluZyBoZWFkZXJzLCBjZWxscywgb3IgZm9vdGVycyB3aXRoIGN1c3RvbSBtYXJrdXAsIHVzZSBmbGV4UmVuZGVyIGluc3RlYWQgb2YgYGNlbGwuZ2V0VmFsdWUoKWAgb3IgYGNlbGwucmVuZGVyVmFsdWUoKWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGV4UmVuZGVyPFRQcm9wcyBleHRlbmRzIG9iamVjdD4oXG4gIENvbXA6IFJlbmRlcmFibGU8VFByb3BzPixcbiAgcHJvcHM6IFRQcm9wc1xuKTogUmVhY3QuUmVhY3ROb2RlIHwgUmVhY3QuSlNYLkVsZW1lbnQge1xuICByZXR1cm4gIUNvbXAgPyBudWxsIDogaXNSZWFjdENvbXBvbmVudDxUUHJvcHM+KENvbXApID8gKFxuICAgIDxDb21wIHsuLi5wcm9wc30gLz5cbiAgKSA6IChcbiAgICBDb21wXG4gIClcbn1cblxuZnVuY3Rpb24gaXNSZWFjdENvbXBvbmVudDxUUHJvcHM+KFxuICBjb21wb25lbnQ6IHVua25vd25cbik6IGNvbXBvbmVudCBpcyBSZWFjdC5Db21wb25lbnRUeXBlPFRQcm9wcz4ge1xuICByZXR1cm4gKFxuICAgIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB8fFxuICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgfHxcbiAgICBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQ6IGFueSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAoKCkgPT4ge1xuICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcG9uZW50KVxuICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZSAmJiBwcm90by5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxuICAgIH0pKClcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQ6IGFueSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIGNvbXBvbmVudC4kJHR5cGVvZiA9PT0gJ3N5bWJvbCcgJiZcbiAgICBbJ3JlYWN0Lm1lbW8nLCAncmVhY3QuZm9yd2FyZF9yZWYnXS5pbmNsdWRlcyhjb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24pXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYWN0VGFibGU8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgb3B0aW9uczogVGFibGVPcHRpb25zPFREYXRhPlxuKSB7XG4gIC8vIENvbXBvc2UgaW4gdGhlIGdlbmVyaWMgb3B0aW9ucyB0byB0aGUgdXNlciBvcHRpb25zXG4gIGNvbnN0IHJlc29sdmVkT3B0aW9uczogVGFibGVPcHRpb25zUmVzb2x2ZWQ8VERhdGE+ID0ge1xuICAgIHN0YXRlOiB7fSwgLy8gRHVtbXkgc3RhdGVcbiAgICBvblN0YXRlQ2hhbmdlOiAoKSA9PiB7fSwgLy8gbm9vcFxuICAgIHJlbmRlckZhbGxiYWNrVmFsdWU6IG51bGwsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBhbmQgc3RvcmUgaXQgaW4gc3RhdGVcbiAgY29uc3QgW3RhYmxlUmVmXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgY3VycmVudDogY3JlYXRlVGFibGU8VERhdGE+KHJlc29sdmVkT3B0aW9ucyksXG4gIH0pKVxuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSlcblxuICAvLyBDb21wb3NlIHRoZSBkZWZhdWx0IHN0YXRlIGFib3ZlIHdpdGggYW55IHVzZXIgc3RhdGUuIFRoaXMgd2lsbCBhbGxvdyB0aGUgdXNlclxuICAvLyB0byBvbmx5IGNvbnRyb2wgYSBzdWJzZXQgb2YgdGhlIHN0YXRlIGlmIGRlc2lyZWQuXG4gIHRhYmxlUmVmLmN1cnJlbnQuc2V0T3B0aW9ucyhwcmV2ID0+ICh7XG4gICAgLi4ucHJldixcbiAgICAuLi5vcHRpb25zLFxuICAgIHN0YXRlOiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIC4uLm9wdGlvbnMuc3RhdGUsXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcilcbiAgICAgIG9wdGlvbnMub25TdGF0ZUNoYW5nZT8uKHVwZGF0ZXIpXG4gICAgfSxcbiAgfSkpXG5cbiAgcmV0dXJuIHRhYmxlUmVmLmN1cnJlbnRcbn1cbiJdLCJuYW1lcyI6WyJmbGV4UmVuZGVyIiwiQ29tcCIsInByb3BzIiwiaXNSZWFjdENvbXBvbmVudCIsIlJlYWN0IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsImNyZWF0ZVRhYmxlIiwic2V0U3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzZXRPcHRpb25zIiwicHJldiIsInVwZGF0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: ()=>typeof document !== \"undefined\" ? window.scrollY : 0,\n        ...options\n    });\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQSxNQUFNQSw0QkFDSixPQUFPQyxhQUFhLGNBQWNDLGtEQUFNLEdBQWtCQSw0Q0FBTTtBQUVsRSxTQUFTRyxtQkFJUEMsT0FBQTtJQUVNLE1BQUFDLFdBQVdMLDZDQUFNLENBQVcsSUFBTyxNQUFLLEdBQUUsQ0FBRSxFQUFDO0lBRW5ELE1BQU1PLGtCQUFvRTtRQUN4RSxHQUFHSCxPQUFBO1FBQ0hJLFVBQVUsQ0FBQ0MsV0FBVUM7O1lBQ25CLElBQUlBLE1BQU07Z0JBQ1JDLG9EQUFTQSxDQUFDTjtZQUFRLE9BQ2I7Z0JBQ0lBO1lBQUE7WUFFSE8sQ0FBQUEsS0FBQVIsUUFBQUksUUFBQSxxQkFBQUksR0FBQUMsSUFBQSxDQUFBVCxTQUFXSyxXQUFVQztRQUFJO0lBRXJDO0lBRU0sT0FBQ0QsU0FBUSxHQUFJVCwyQ0FBTSxDQUN2QixJQUFNLElBQUllLCtEQUFXQSxDQUErQlI7SUFHdERFLFNBQVNPLFVBQUEsQ0FBV1Q7SUFFcEJULDBCQUEwQjtRQUN4QixPQUFPVyxTQUFTUSxTQUFBO0lBQ2xCLEdBQUcsRUFBRTtJQUVMbkIsMEJBQTBCO1FBQ3hCLE9BQU9XLFNBQVNTLFdBQUE7SUFBWTtJQUd2QixPQUFBVDtBQUNUO0FBRU8sU0FBU1UsZUFJZGYsT0FBQTtJQUtBLE9BQU9ELG1CQUFpRDtRQUN0RGlCLGtCQUFrQkEsd0VBQUFBO1FBQ2xCQyxvQkFBb0JBLDBFQUFBQTtRQUNwQkMsWUFBWUMsaUVBQWFBO1FBQ3pCLEdBQUduQixPQUFBO0lBQUE7QUFFUDtBQUVPLFNBQVNvQixxQkFDZHBCLE9BQUE7SUFRQSxPQUFPRCxtQkFBeUM7UUFDOUNzQixrQkFBa0IsSUFBTyxPQUFPMUIsYUFBYSxjQUFjMkIsU0FBUztRQUNwRU4sb0JBQW9CTyxxRUFBaUJBO1FBQ3JDTixzQkFBc0JPLHVFQUFtQkE7UUFDekNOLFlBQVlPLGdFQUFZQTtRQUN4QkMsZUFBZSxJQUFPLE9BQU8vQixhQUFhLGNBQWMyQixPQUFPSyxPQUFBLEdBQVU7UUFDekUsR0FBRzNCLE9BQUE7SUFBQTtBQUVQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9pbmRleC50c3g/ZWUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSdcbmltcG9ydCB7XG4gIFZpcnR1YWxpemVyLFxuICBlbGVtZW50U2Nyb2xsLFxuICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICBvYnNlcnZlV2luZG93UmVjdCxcbiAgd2luZG93U2Nyb2xsLFxufSBmcm9tICdAdGFuc3RhY2svdmlydHVhbC1jb3JlJ1xuaW1wb3J0IHR5cGUgeyBQYXJ0aWFsS2V5cywgVmlydHVhbGl6ZXJPcHRpb25zIH0gZnJvbSAnQHRhbnN0YWNrL3ZpcnR1YWwtY29yZSdcblxuZXhwb3J0ICogZnJvbSAnQHRhbnN0YWNrL3ZpcnR1YWwtY29yZSdcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9XG4gIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3RcblxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXJCYXNlPFxuICBUU2Nyb2xsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBXaW5kb3csXG4gIFRJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4+KFxuICBvcHRpb25zOiBWaXJ0dWFsaXplck9wdGlvbnM8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4sXG4pOiBWaXJ0dWFsaXplcjxUU2Nyb2xsRWxlbWVudCwgVEl0ZW1FbGVtZW50PiB7XG4gIGNvbnN0IHJlcmVuZGVyID0gUmVhY3QudXNlUmVkdWNlcigoKSA9PiAoe30pLCB7fSlbMV1cblxuICBjb25zdCByZXNvbHZlZE9wdGlvbnM6IFZpcnR1YWxpemVyT3B0aW9uczxUU2Nyb2xsRWxlbWVudCwgVEl0ZW1FbGVtZW50PiA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uQ2hhbmdlOiAoaW5zdGFuY2UsIHN5bmMpID0+IHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGZsdXNoU3luYyhyZXJlbmRlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKClcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMub25DaGFuZ2U/LihpbnN0YW5jZSwgc3luYylcbiAgICB9LFxuICB9XG5cbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICgpID0+IG5ldyBWaXJ0dWFsaXplcjxUU2Nyb2xsRWxlbWVudCwgVEl0ZW1FbGVtZW50PihyZXNvbHZlZE9wdGlvbnMpLFxuICApXG5cbiAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhyZXNvbHZlZE9wdGlvbnMpXG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpXG4gIH0sIFtdKVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpXG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VWaXJ0dWFsaXplcjxcbiAgVFNjcm9sbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICBUSXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuPihcbiAgb3B0aW9uczogUGFydGlhbEtleXM8XG4gICAgVmlydHVhbGl6ZXJPcHRpb25zPFRTY3JvbGxFbGVtZW50LCBUSXRlbUVsZW1lbnQ+LFxuICAgICdvYnNlcnZlRWxlbWVudFJlY3QnIHwgJ29ic2VydmVFbGVtZW50T2Zmc2V0JyB8ICdzY3JvbGxUb0ZuJ1xuICA+LFxuKTogVmlydHVhbGl6ZXI8VFNjcm9sbEVsZW1lbnQsIFRJdGVtRWxlbWVudD4ge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlPFRTY3JvbGxFbGVtZW50LCBUSXRlbUVsZW1lbnQ+KHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3Q6IG9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogZWxlbWVudFNjcm9sbCxcbiAgICAuLi5vcHRpb25zLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXI8VEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oXG4gIG9wdGlvbnM6IFBhcnRpYWxLZXlzPFxuICAgIFZpcnR1YWxpemVyT3B0aW9uczxXaW5kb3csIFRJdGVtRWxlbWVudD4sXG4gICAgfCAnZ2V0U2Nyb2xsRWxlbWVudCdcbiAgICB8ICdvYnNlcnZlRWxlbWVudFJlY3QnXG4gICAgfCAnb2JzZXJ2ZUVsZW1lbnRPZmZzZXQnXG4gICAgfCAnc2Nyb2xsVG9GbidcbiAgPixcbik6IFZpcnR1YWxpemVyPFdpbmRvdywgVEl0ZW1FbGVtZW50PiB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2U8V2luZG93LCBUSXRlbUVsZW1lbnQ+KHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGwpLFxuICAgIG9ic2VydmVFbGVtZW50UmVjdDogb2JzZXJ2ZVdpbmRvd1JlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gICAgc2Nyb2xsVG9Gbjogd2luZG93U2Nyb2xsLFxuICAgIGluaXRpYWxPZmZzZXQ6ICgpID0+ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gd2luZG93LnNjcm9sbFkgOiAwKSxcbiAgICAuLi5vcHRpb25zLFxuICB9KVxufVxuIl0sIm5hbWVzIjpbInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJkb2N1bWVudCIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlVmlydHVhbGl6ZXJCYXNlIiwib3B0aW9ucyIsInJlcmVuZGVyIiwidXNlUmVkdWNlciIsInJlc29sdmVkT3B0aW9ucyIsIm9uQ2hhbmdlIiwiaW5zdGFuY2UiLCJzeW5jIiwiZmx1c2hTeW5jIiwiX2EiLCJjYWxsIiwidXNlU3RhdGUiLCJWaXJ0dWFsaXplciIsInNldE9wdGlvbnMiLCJfZGlkTW91bnQiLCJfd2lsbFVwZGF0ZSIsInVzZVZpcnR1YWxpemVyIiwib2JzZXJ2ZUVsZW1lbnRSZWN0Iiwib2JzZXJ2ZUVsZW1lbnRPZmZzZXQiLCJzY3JvbGxUb0ZuIiwiZWxlbWVudFNjcm9sbCIsInVzZVdpbmRvd1ZpcnR1YWxpemVyIiwiZ2V0U2Nyb2xsRWxlbWVudCIsIndpbmRvdyIsIm9ic2VydmVXaW5kb3dSZWN0Iiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIndpbmRvd1Njcm9sbCIsImluaXRpYWxPZmZzZXQiLCJzY3JvbGxZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* binding */ GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\n// Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return (depArgs)=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps(depArgs);\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n    return {\n        debug: ()=>{\n            var _tableOptions$debugAl;\n            return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n        },\n        key:  true && key,\n        onChange\n    };\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), getMemoOptions(table.options, \"debugCells\", \"cell.getContext\"))\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === \"function\" ? accessorKey.replaceAll(\".\", \"_\") : accessorKey.replace(/\\./g, \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getFlatColumns\")),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getLeafColumns\"))\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to unknown, because we know more than the compiler here.\n    return column;\n}\nconst debug = \"debugHeaders\";\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, getMemoOptions(table.options, debug, \"getHeaderGroups\"));\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, getMemoOptions(table.options, debug, \"getCenterHeaderGroups\"));\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, getMemoOptions(table.options, debug, \"getLeftHeaderGroups\"));\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, getMemoOptions(table.options, debug, \"getRightHeaderGroups\"));\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getFooterGroups\"));\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getLeftFooterGroups\"));\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getCenterFooterGroups\"));\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getRightFooterGroups\"));\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getFlatHeaders\"));\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeftFlatHeaders\"));\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getCenterFlatHeaders\"));\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getRightFlatHeaders\"));\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getCenterLeafHeaders\"));\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getLeftLeafHeaders\"));\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getRightLeafHeaders\"));\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeafHeaders\"));\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCells\")),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCellsByColumnId\"))\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n//\nconst ColumnFaceting = {\n    createColumn: (column, table)=>{\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _filterValue$toString, _row$getValue;\n    const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst ColumnFiltering = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousFilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousFilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n    },\n    createRow: (row, _table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst ColumnGrouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst ColumnOrdering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getIndex = memo((position)=>[\n                _getVisibleLeafColumns(table, position)\n            ], (columns)=>columns.findIndex((d)=>d.id === column.id), getMemoOptions(table.options, \"debugColumns\", \"getIndex\"));\n        column.getIsFirstColumn = (position)=>{\n            var _columns$;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n        };\n        column.getIsLastColumn = (position)=>{\n            var _columns;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, getMemoOptions(table.options, \"debugTable\", \"_getOrderColumnsFn\"));\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst ColumnPinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterVisibleCells\"));\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left\n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getLeftVisibleCells\"));\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getRightVisibleCells\"));\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getLeftLeafColumns\"));\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getRightLeafColumns\"));\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, getMemoOptions(table.options, \"debugColumns\", \"getCenterLeafColumns\"));\n    }\n};\nfunction safelyAccessDocument(_document) {\n    return _document || (typeof document !== \"undefined\" ? document : null);\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(0, column.getIndex(position)).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getStart\"));\n        column.getAfter = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(column.getIndex(position) + 1).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getAfter\"));\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = safelyAccessDocument(_contextDocument);\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst ColumnVisibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _ref, _table$getState$colum;\n            const childColumns = column.columns;\n            return (_ref = childColumns.length ? childColumns.some((c)=>c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, getMemoOptions(table.options, \"debugRows\", \"_getAllVisibleCells\"));\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], getMemoOptions(table.options, \"debugRows\", \"getVisibleCells\"));\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, getMemoOptions(table.options, \"debugColumns\", key));\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nfunction _getVisibleLeafColumns(table, position) {\n    return !position ? table.getVisibleLeafColumns() : position === \"center\" ? table.getCenterVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n//\nconst GlobalFaceting = {\n    createTable: (table)=>{\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\n//\nconst GlobalFiltering = {\n    getInitialState: (state)=>{\n        return {\n            globalFilter: undefined,\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\n            return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n    }\n};\n//\nconst RowExpanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst RowPagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        //deprecated\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPageOptions\"));\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.firstPage = ()=>{\n            return table.setPageIndex(0);\n        };\n        table.lastPage = ()=>{\n            return table.setPageIndex(table.getPageCount() - 1);\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n        };\n        table.getRowCount = ()=>{\n            var _table$options$rowCou;\n            return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n        };\n    }\n};\n//\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst RowPinning = {\n    getInitialState: (state)=>{\n        return {\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref)=>{\n                let { id } = _ref;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref3;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _ref4, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_ref4 = position === \"top\" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n    },\n    createTable: (table)=>{\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table._getPinnedRows = (visibleRows, pinnedRowIds, position)=>{\n            var _table$options$keepPi;\n            const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                const row = table.getRow(rowId, true);\n                return row.getIsAllParentsExpanded() ? row : null;\n            }) : //else get only visible rows that are pinned\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n            return rows.filter(Boolean).map((d)=>({\n                    ...d,\n                    position\n                }));\n        };\n        table.getTopRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top\n            ], (allRows, topPinnedRowIds)=>table._getPinnedRows(allRows, topPinnedRowIds, \"top\"), getMemoOptions(table.options, \"debugRows\", \"getTopRows\"));\n        table.getBottomRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.bottom\n            ], (allRows, bottomPinnedRowIds)=>table._getPinnedRows(allRows, bottomPinnedRowIds, \"bottom\"), getMemoOptions(table.options, \"debugRows\", \"getBottomRows\"));\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterRows\"));\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getSelectedRowModel\"));\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredSelectedRowModel\"));\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedSelectedRowModel\"));\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst RowSorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\nconst builtInFeatures = [\n    Headers,\n    ColumnVisibility,\n    ColumnOrdering,\n    ColumnPinning,\n    ColumnFaceting,\n    ColumnFiltering,\n    GlobalFaceting,\n    //depends on ColumnFaceting\n    GlobalFiltering,\n    //depends on ColumnFiltering\n    RowSorting,\n    ColumnGrouping,\n    //depends on RowSorting\n    RowExpanding,\n    RowPagination,\n    RowPinning,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$_features, _options$initialState;\n    if ( true && (options.debugAll || options.debugTable)) {\n        console.info(\"Creating Table Instance...\");\n    }\n    const _features = [\n        ...builtInFeatures,\n        ...(_options$_features = options._features) != null ? _options$_features : []\n    ];\n    let table = {\n        _features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, getMemoOptions(options, \"debugColumns\", \"_getDefaultColumnDef\")),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllColumns\")),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumns\")),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumnsById\")),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllLeafColumns\")),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getExpandedRowModel\"));\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return undefined;\n            const uniqueValues = facetedRowModel.flatRows.flatMap((flatRow)=>{\n                var _flatRow$getUniqueVal;\n                return (_flatRow$getUniqueVal = flatRow.getUniqueValues(columnId)) != null ? _flatRow$getUniqueVal : [];\n            }).map(Number).filter((value)=>!Number.isNaN(value));\n            if (!uniqueValues.length) return;\n            let facetedMinValue = uniqueValues[0];\n            let facetedMaxValue = uniqueValues[uniqueValues.length - 1];\n            for (const value of uniqueValues){\n                if (value < facetedMinValue) facetedMinValue = value;\n                else if (value > facetedMaxValue) facetedMaxValue = value;\n            }\n            return [\n                facetedMinValue,\n                facetedMaxValue\n            ];\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedMinMaxValues\"));\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedRowModel\"));\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, getMemoOptions(table.options, \"debugTable\", `getFacetedUniqueValues_${columnId}`));\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = (columnFilters != null ? columnFilters : []).map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                rowModel.rows.forEach((row)=>{\n                    row.depth = 0;\n                    row.parentId = undefined;\n                });\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Perform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    subRows.forEach((subRow)=>{\n                        subRow.parentId = id;\n                    });\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedRowModel\", ()=>{\n            table._queue(()=>{\n                table._autoResetExpanded();\n                table._autoResetPageIndex();\n            });\n        }));\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPaginationRowModel\"));\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const sortUndefined = columnInfo.sortUndefined;\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                if (sortUndefined === \"first\") return aUndefined ? -1 : 1;\n                                if (sortUndefined === \"last\") return aUndefined ? 1 : -1;\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getSortedRowModel\", ()=>table._autoResetPageIndex()));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBc0JPLFNBQVNBO0lBR2QsT0FBTztRQUNMQyxVQUFVQSxDQUFDQSxVQUFVQztZQUNuQixPQUFPLE9BQU9ELGFBQWEsYUFDdEI7Z0JBQ0MsR0FBR0MsTUFBTTtnQkFDVEMsWUFBWUY7WUFDZCxJQUNBO2dCQUNFLEdBQUdDLE1BQU07Z0JBQ1RFLGFBQWFIOzs7UUFHckJJLFNBQVNILENBQUFBLFNBQVVBO1FBQ25CSSxPQUFPSixDQUFBQSxTQUFVQTs7QUFFckI7QUM5REE7QUFPQTtBQTJDQTtBQUVPLFNBQVNLLGlCQUFvQkMsT0FBbUIsRUFBRUMsS0FBUTtJQUMvRCxPQUFPLE9BQU9ELFlBQVksYUFDckJBLFFBQTRCQyxTQUM3QkQ7QUFDTjtBQUVPLFNBQVNFO0FBQ2Q7QUFBQTtBQUdLLFNBQVNDLGlCQUNkQyxHQUFNLEVBQ05DLFFBQWlCO0lBRWpCLE9BQVFMLENBQUFBO1FBQ0pLLFNBQWlCQyxRQUFRLENBQWVDLENBQUFBO1lBQ3hDLE9BQU87Z0JBQ0wsR0FBR0EsR0FBRztnQkFDTixDQUFDSCxJQUFHLEVBQUdMLGlCQUFpQkMsU0FBVU8sR0FBRyxDQUFTSCxJQUFJOztRQUV0RDs7QUFFSjtBQUlPLFNBQVNJLFdBQWtDQyxDQUFNO0lBQ3RELE9BQU9BLGFBQWFDO0FBQ3RCO0FBRU8sU0FBU0MsY0FBY0Ys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Qzs0QkFDZDs0QkFFQSxPQUFPQTt3QkFDVDtvQkFDRjtvQkFFQSxPQUFPdEwsS0FBS3Z0QixLQUFLLEdBQUd3dEIsS0FBS3h0QixLQUFLO2dCQUNoQztnQkFFQTtnQkFDQXk0QixXQUFXNzVCLE9BQU8sQ0FBQzRDLENBQUFBO29CQUFPLElBQUFrVDtvQkFDeEJ5akIsZUFBZXI1QixJQUFJLENBQUMwQztvQkFDcEIsSUFBQWtULENBQUFBLGVBQUlsVCxJQUFJaUksT0FBTyxLQUFYaUwsUUFBQUEsYUFBYTFWLE1BQU0sRUFBRTt3QkFDdkJ3QyxJQUFJaUksT0FBTyxHQUFHK3VCLFNBQVNoM0IsSUFBSWlJLE9BQU87b0JBQ3BDO2dCQUNGO2dCQUVBLE9BQU9ndkI7O1lBR1QsT0FBTztnQkFDTHpSLE1BQU13UixTQUFTM04sU0FBUzdELElBQUk7Z0JBQzVCMVksVUFBVTZwQjtnQkFDVnJWLFVBQVUrSCxTQUFTL0gsUUFBQUE7O1FBRXZCLEdBQ0E5aEIsZUFBZU8sTUFBTU8sT0FBTyxFQUFFLGNBQWMscUJBQXFCLElBQy9EUCxNQUFNbWpCLG1CQUFtQjtBQUdqQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvY29sdW1uSGVscGVyLnRzP2JiYTUiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy50cz82MjUyIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvY29yZS9jZWxsLnRzP2FjMWQiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9jb3JlL2NvbHVtbi50cz9lODYwIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvY29yZS9oZWFkZXJzLnRzPzhiOTciLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9jb3JlL3Jvdy50cz84OTcwIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvQ29sdW1uRmFjZXRpbmcudHM/OTJlNiIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL2ZpbHRlckZucy50cz83ZjM5Iiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvQ29sdW1uRmlsdGVyaW5nLnRzP2IyMTUiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9hZ2dyZWdhdGlvbkZucy50cz81MjUxIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvQ29sdW1uR3JvdXBpbmcudHM/NGU3YiIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL2ZlYXR1cmVzL0NvbHVtbk9yZGVyaW5nLnRzPzI1YWQiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9mZWF0dXJlcy9Db2x1bW5QaW5uaW5nLnRzP2U0NDIiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy9kb2N1bWVudC50cz9jMGU1Iiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvQ29sdW1uU2l6aW5nLnRzPzg1YjgiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9mZWF0dXJlcy9Db2x1bW5WaXNpYmlsaXR5LnRzPzllZTIiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9mZWF0dXJlcy9HbG9iYWxGYWNldGluZy50cz81MDVhIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvR2xvYmFsRmlsdGVyaW5nLnRzPzI0OTIiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy9mZWF0dXJlcy9Sb3dFeHBhbmRpbmcudHM/MmYwOCIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL2ZlYXR1cmVzL1Jvd1BhZ2luYXRpb24udHM/NGQ0NiIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL2ZlYXR1cmVzL1Jvd1Bpbm5pbmcudHM/ZWYzZiIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL2ZlYXR1cmVzL1Jvd1NlbGVjdGlvbi50cz8yZWRjIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvc29ydGluZ0Zucy50cz8yNTc1Iiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvZmVhdHVyZXMvUm93U29ydGluZy50cz9hZTkzIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvY29yZS90YWJsZS50cz81NjE0Iiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvdXRpbHMvZ2V0Q29yZVJvd01vZGVsLnRzP2M3ZjIiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy9nZXRFeHBhbmRlZFJvd01vZGVsLnRzP2JkZDciLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy9nZXRGYWNldGVkTWluTWF4VmFsdWVzLnRzPzZmMWMiLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy9maWx0ZXJSb3dzVXRpbHMudHM/YmI5ZiIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL3V0aWxzL2dldEZhY2V0ZWRSb3dNb2RlbC50cz8zMjYwIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvdXRpbHMvZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcy50cz9kZWM5Iiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvdXRpbHMvZ2V0RmlsdGVyZWRSb3dNb2RlbC50cz8yZTRlIiwid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uLi8uLi9zcmMvdXRpbHMvZ2V0R3JvdXBlZFJvd01vZGVsLnRzP2U4MTciLCJ3ZWJwYWNrOi8vdHJhZGV1bC1zY2FubmVyLWZyb250ZW5kLy4uLy4uL3NyYy91dGlscy9nZXRQYWdpbmF0aW9uUm93TW9kZWwudHM/NzAyNCIsIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi4vLi4vc3JjL3V0aWxzL2dldFNvcnRlZFJvd01vZGVsLnRzP2JmNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWNjZXNzb3JGbixcbiAgQWNjZXNzb3JGbkNvbHVtbkRlZixcbiAgQWNjZXNzb3JLZXlDb2x1bW5EZWYsXG4gIERpc3BsYXlDb2x1bW5EZWYsXG4gIEdyb3VwQ29sdW1uRGVmLFxuICBJZGVudGlmaWVkQ29sdW1uRGVmLFxuICBSb3dEYXRhLFxufSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IHsgRGVlcEtleXMsIERlZXBWYWx1ZSB9IGZyb20gJy4vdXRpbHMnXG5cbi8vIHR5cGUgUGVyc29uID0ge1xuLy8gICBmaXJzdE5hbWU6IHN0cmluZ1xuLy8gICBsYXN0TmFtZTogc3RyaW5nXG4vLyAgIGFnZTogbnVtYmVyXG4vLyAgIHZpc2l0czogbnVtYmVyXG4vLyAgIHN0YXR1czogc3RyaW5nXG4vLyAgIHByb2dyZXNzOiBudW1iZXJcbi8vICAgY3JlYXRlZEF0OiBEYXRlXG4vLyAgIG5lc3RlZDoge1xuLy8gICAgIGZvbzogW1xuLy8gICAgICAge1xuLy8gICAgICAgICBiYXI6ICdiYXInXG4vLyAgICAgICB9XG4vLyAgICAgXVxuLy8gICAgIGJhcjogeyBzdWJCYXI6IGJvb2xlYW4gfVtdXG4vLyAgICAgYmF6OiB7XG4vLyAgICAgICBmb286ICdmb28nXG4vLyAgICAgICBiYXI6IHtcbi8vICAgICAgICAgYmF6OiAnYmF6J1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG4vLyBjb25zdCB0ZXN0OiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5mb28uMC5iYXInXG4vLyBjb25zdCB0ZXN0MjogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuYmFyJ1xuXG4vLyBjb25zdCBoZWxwZXIgPSBjcmVhdGVDb2x1bW5IZWxwZXI8UGVyc29uPigpXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvbycsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28uMC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbmV4cG9ydCB0eXBlIENvbHVtbkhlbHBlcjxURGF0YSBleHRlbmRzIFJvd0RhdGE+ID0ge1xuICBhY2Nlc3NvcjogPFxuICAgIFRBY2Nlc3NvciBleHRlbmRzIEFjY2Vzc29yRm48VERhdGE+IHwgRGVlcEtleXM8VERhdGE+LFxuICAgIFRWYWx1ZSBleHRlbmRzIFRBY2Nlc3NvciBleHRlbmRzIEFjY2Vzc29yRm48VERhdGEsIGluZmVyIFRSZXR1cm4+XG4gICAgICA/IFRSZXR1cm5cbiAgICAgIDogVEFjY2Vzc29yIGV4dGVuZHMgRGVlcEtleXM8VERhdGE+XG4gICAgICAgID8gRGVlcFZhbHVlPFREYXRhLCBUQWNjZXNzb3I+XG4gICAgICAgIDogbmV2ZXIsXG4gID4oXG4gICAgYWNjZXNzb3I6IFRBY2Nlc3NvcixcbiAgICBjb2x1bW46IFRBY2Nlc3NvciBleHRlbmRzIEFjY2Vzc29yRm48VERhdGE+XG4gICAgICA/IERpc3BsYXlDb2x1bW5EZWY8VERhdGEsIFRWYWx1ZT5cbiAgICAgIDogSWRlbnRpZmllZENvbHVtbkRlZjxURGF0YSwgVFZhbHVlPlxuICApID0+IFRBY2Nlc3NvciBleHRlbmRzIEFjY2Vzc29yRm48VERhdGE+XG4gICAgPyBBY2Nlc3NvckZuQ29sdW1uRGVmPFREYXRhLCBUVmFsdWU+XG4gICAgOiBBY2Nlc3NvcktleUNvbHVtbkRlZjxURGF0YSwgVFZhbHVlPlxuICBkaXNwbGF5OiAoY29sdW1uOiBEaXNwbGF5Q29sdW1uRGVmPFREYXRhPikgPT4gRGlzcGxheUNvbHVtbkRlZjxURGF0YSwgdW5rbm93bj5cbiAgZ3JvdXA6IChjb2x1bW46IEdyb3VwQ29sdW1uRGVmPFREYXRhPikgPT4gR3JvdXBDb2x1bW5EZWY8VERhdGEsIHVua25vd24+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2x1bW5IZWxwZXI8XG4gIFREYXRhIGV4dGVuZHMgUm93RGF0YSxcbj4oKTogQ29sdW1uSGVscGVyPFREYXRhPiB7XG4gIHJldHVybiB7XG4gICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKHtcbiAgICAgICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgICAgIGFjY2Vzc29yRm46IGFjY2Vzc29yLFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgICAgIGFjY2Vzc29yS2V5OiBhY2Nlc3NvcixcbiAgICAgICAgICB9XG4gICAgfSxcbiAgICBkaXNwbGF5OiBjb2x1bW4gPT4gY29sdW1uLFxuICAgIGdyb3VwOiBjb2x1bW4gPT4gY29sdW1uLFxuICB9XG59XG4iLCJpbXBvcnQgeyBUYWJsZU9wdGlvbnNSZXNvbHZlZCwgVGFibGVTdGF0ZSwgVXBkYXRlciB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIFBhcnRpYWxLZXlzPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IE9taXQ8VCwgSz4gJiBQYXJ0aWFsPFBpY2s8VCwgSz4+XG5leHBvcnQgdHlwZSBSZXF1aXJlZEtleXM8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gT21pdDxULCBLPiAmXG4gIFJlcXVpcmVkPFBpY2s8VCwgSz4+XG5leHBvcnQgdHlwZSBPdmVyd3JpdGU8VCwgVSBleHRlbmRzIHsgW1RLZXkgaW4ga2V5b2YgVF0/OiBhbnkgfT4gPSBPbWl0PFxuICBULFxuICBrZXlvZiBVXG4+ICZcbiAgVVxuXG5leHBvcnQgdHlwZSBVbmlvblRvSW50ZXJzZWN0aW9uPFQ+ID0gKFxuICBUIGV4dGVuZHMgYW55ID8gKHg6IFQpID0+IGFueSA6IG5ldmVyXG4pIGV4dGVuZHMgKHg6IGluZmVyIFIpID0+IGFueVxuICA/IFJcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBJc0FueTxULCBZLCBOPiA9IDEgZXh0ZW5kcyAwICYgVCA/IFkgOiBOXG5leHBvcnQgdHlwZSBJc0tub3duPFQsIFksIE4+ID0gdW5rbm93biBleHRlbmRzIFQgPyBOIDogWVxuXG50eXBlIENvbXB1dGVSYW5nZTxcbiAgTiBleHRlbmRzIG51bWJlcixcbiAgUmVzdWx0IGV4dGVuZHMgQXJyYXk8dW5rbm93bj4gPSBbXSxcbj4gPSBSZXN1bHRbJ2xlbmd0aCddIGV4dGVuZHMgTlxuICA/IFJlc3VsdFxuICA6IENvbXB1dGVSYW5nZTxOLCBbLi4uUmVzdWx0LCBSZXN1bHRbJ2xlbmd0aCddXT5cbnR5cGUgSW5kZXg0MCA9IENvbXB1dGVSYW5nZTw0MD5bbnVtYmVyXVxuXG4vLyBJcyB0aGlzIHR5cGUgYSB0dXBsZT9cbnR5cGUgSXNUdXBsZTxUPiA9IFQgZXh0ZW5kcyByZWFkb25seSBhbnlbXSAmIHsgbGVuZ3RoOiBpbmZlciBMZW5ndGggfVxuICA/IExlbmd0aCBleHRlbmRzIEluZGV4NDBcbiAgICA/IFRcbiAgICA6IG5ldmVyXG4gIDogbmV2ZXJcblxuLy8gSWYgdGhpcyB0eXBlIGlzIGEgdHVwbGUsIHdoYXQgaW5kaWNlcyBhcmUgYWxsb3dlZD9cbnR5cGUgQWxsb3dlZEluZGV4ZXM8XG4gIFR1cGxlIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxhbnk+LFxuICBLZXlzIGV4dGVuZHMgbnVtYmVyID0gbmV2ZXIsXG4+ID0gVHVwbGUgZXh0ZW5kcyByZWFkb25seSBbXVxuICA/IEtleXNcbiAgOiBUdXBsZSBleHRlbmRzIHJlYWRvbmx5IFtpbmZlciBfLCAuLi5pbmZlciBUYWlsXVxuICAgID8gQWxsb3dlZEluZGV4ZXM8VGFpbCwgS2V5cyB8IFRhaWxbJ2xlbmd0aCddPlxuICAgIDogS2V5c1xuXG5leHBvcnQgdHlwZSBEZWVwS2V5czxULCBURGVwdGggZXh0ZW5kcyBhbnlbXSA9IFtdPiA9IFREZXB0aFsnbGVuZ3RoJ10gZXh0ZW5kcyA1XG4gID8gbmV2ZXJcbiAgOiB1bmtub3duIGV4dGVuZHMgVFxuICAgID8gc3RyaW5nXG4gICAgOiBUIGV4dGVuZHMgcmVhZG9ubHkgYW55W10gJiBJc1R1cGxlPFQ+XG4gICAgICA/IEFsbG93ZWRJbmRleGVzPFQ+IHwgRGVlcEtleXNQcmVmaXg8VCwgQWxsb3dlZEluZGV4ZXM8VD4sIFREZXB0aD5cbiAgICAgIDogVCBleHRlbmRzIGFueVtdXG4gICAgICAgID8gRGVlcEtleXM8VFtudW1iZXJdLCBbLi4uVERlcHRoLCBhbnldPlxuICAgICAgICA6IFQgZXh0ZW5kcyBEYXRlXG4gICAgICAgICAgPyBuZXZlclxuICAgICAgICAgIDogVCBleHRlbmRzIG9iamVjdFxuICAgICAgICAgICAgPyAoa2V5b2YgVCAmIHN0cmluZykgfCBEZWVwS2V5c1ByZWZpeDxULCBrZXlvZiBULCBURGVwdGg+XG4gICAgICAgICAgICA6IG5ldmVyXG5cbnR5cGUgRGVlcEtleXNQcmVmaXg8XG4gIFQsXG4gIFRQcmVmaXgsXG4gIFREZXB0aCBleHRlbmRzIGFueVtdLFxuPiA9IFRQcmVmaXggZXh0ZW5kcyBrZXlvZiBUICYgKG51bWJlciB8IHN0cmluZylcbiAgPyBgJHtUUHJlZml4fS4ke0RlZXBLZXlzPFRbVFByZWZpeF0sIFsuLi5URGVwdGgsIGFueV0+ICYgc3RyaW5nfWBcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBEZWVwVmFsdWU8VCwgVFByb3A+ID1cbiAgVCBleHRlbmRzIFJlY29yZDxzdHJpbmcgfCBudW1iZXIsIGFueT5cbiAgICA/IFRQcm9wIGV4dGVuZHMgYCR7aW5mZXIgVEJyYW5jaH0uJHtpbmZlciBURGVlcFByb3B9YFxuICAgICAgPyBEZWVwVmFsdWU8VFtUQnJhbmNoXSwgVERlZXBQcm9wPlxuICAgICAgOiBUW1RQcm9wICYgc3RyaW5nXVxuICAgIDogbmV2ZXJcblxuZXhwb3J0IHR5cGUgTm9JbmZlcjxUPiA9IFtUXVtUIGV4dGVuZHMgYW55ID8gMCA6IG5ldmVyXVxuXG5leHBvcnQgdHlwZSBHZXR0ZXI8VFZhbHVlPiA9IDxUVFZhbHVlID0gVFZhbHVlPigpID0+IE5vSW5mZXI8VFRWYWx1ZT5cblxuLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlPFQ+KHVwZGF0ZXI6IFVwZGF0ZXI8VD4sIGlucHV0OiBUKTogVCB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gKHVwZGF0ZXIgYXMgKGlucHV0OiBUKSA9PiBUKShpbnB1dClcbiAgICA6IHVwZGF0ZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyPEsgZXh0ZW5kcyBrZXlvZiBUYWJsZVN0YXRlPihcbiAga2V5OiBLLFxuICBpbnN0YW5jZTogdW5rbm93blxuKSB7XG4gIHJldHVybiAodXBkYXRlcjogVXBkYXRlcjxUYWJsZVN0YXRlW0tdPikgPT4ge1xuICAgIDsoaW5zdGFuY2UgYXMgYW55KS5zZXRTdGF0ZSg8VFRhYmxlU3RhdGU+KG9sZDogVFRhYmxlU3RhdGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgW2tleV06IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgKG9sZCBhcyBhbnkpW2tleV0pLFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxudHlwZSBBbnlGdW5jdGlvbiA9ICguLi5hcmdzOiBhbnkpID0+IGFueVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbjxUIGV4dGVuZHMgQW55RnVuY3Rpb24+KGQ6IGFueSk6IGQgaXMgVCB7XG4gIHJldHVybiBkIGluc3RhbmNlb2YgRnVuY3Rpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoZDogYW55KTogZCBpcyBudW1iZXJbXSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbkJ5PFROb2RlPihcbiAgYXJyOiBUTm9kZVtdLFxuICBnZXRDaGlsZHJlbjogKGl0ZW06IFROb2RlKSA9PiBUTm9kZVtdXG4pIHtcbiAgY29uc3QgZmxhdDogVE5vZGVbXSA9IFtdXG5cbiAgY29uc3QgcmVjdXJzZSA9IChzdWJBcnI6IFROb2RlW10pID0+IHtcbiAgICBzdWJBcnIuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGZsYXQucHVzaChpdGVtKVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpdGVtKVxuICAgICAgaWYgKGNoaWxkcmVuPy5sZW5ndGgpIHtcbiAgICAgICAgcmVjdXJzZShjaGlsZHJlbilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmVjdXJzZShhcnIpXG5cbiAgcmV0dXJuIGZsYXRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW88VERlcHMgZXh0ZW5kcyByZWFkb25seSBhbnlbXSwgVERlcEFyZ3MsIFRSZXN1bHQ+KFxuICBnZXREZXBzOiAoZGVwQXJncz86IFREZXBBcmdzKSA9PiBbLi4uVERlcHNdLFxuICBmbjogKC4uLmFyZ3M6IE5vSW5mZXI8Wy4uLlREZXBzXT4pID0+IFRSZXN1bHQsXG4gIG9wdHM6IHtcbiAgICBrZXk6IGFueVxuICAgIGRlYnVnPzogKCkgPT4gYW55XG4gICAgb25DaGFuZ2U/OiAocmVzdWx0OiBUUmVzdWx0KSA9PiB2b2lkXG4gIH1cbik6IChkZXBBcmdzPzogVERlcEFyZ3MpID0+IFRSZXN1bHQge1xuICBsZXQgZGVwczogYW55W10gPSBbXVxuICBsZXQgcmVzdWx0OiBUUmVzdWx0IHwgdW5kZWZpbmVkXG5cbiAgcmV0dXJuIGRlcEFyZ3MgPT4ge1xuICAgIGxldCBkZXBUaW1lOiBudW1iZXJcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgZGVwVGltZSA9IERhdGUubm93KClcblxuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKGRlcEFyZ3MpXG5cbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9XG4gICAgICBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHxcbiAgICAgIG5ld0RlcHMuc29tZSgoZGVwOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApXG5cbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0IVxuICAgIH1cblxuICAgIGRlcHMgPSBuZXdEZXBzXG5cbiAgICBsZXQgcmVzdWx0VGltZTogbnVtYmVyXG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKVxuICAgIG9wdHM/Lm9uQ2hhbmdlPy4ocmVzdWx0KVxuXG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHtcbiAgICAgIGlmIChvcHRzPy5kZWJ1ZygpKSB7XG4gICAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSEpICogMTAwKSAvIDEwMFxuICAgICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUhKSAqIDEwMCkgLyAxMDBcbiAgICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNlxuXG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHI6IG51bWJlciB8IHN0cmluZywgbnVtOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHJcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgIGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsXG4gICAgICAgICAgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApXG4gICAgICAgICAgICApfWRlZyAxMDAlIDMxJSk7YCxcbiAgICAgICAgICBvcHRzPy5rZXlcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQhXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lbW9PcHRpb25zKFxuICB0YWJsZU9wdGlvbnM6IFBhcnRpYWw8VGFibGVPcHRpb25zUmVzb2x2ZWQ8YW55Pj4sXG4gIGRlYnVnTGV2ZWw6XG4gICAgfCAnZGVidWdBbGwnXG4gICAgfCAnZGVidWdDZWxscydcbiAgICB8ICdkZWJ1Z1RhYmxlJ1xuICAgIHwgJ2RlYnVnQ29sdW1ucydcbiAgICB8ICdkZWJ1Z1Jvd3MnXG4gICAgfCAnZGVidWdIZWFkZXJzJyxcbiAga2V5OiBzdHJpbmcsXG4gIG9uQ2hhbmdlPzogKHJlc3VsdDogYW55KSA9PiB2b2lkXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogKCkgPT4gdGFibGVPcHRpb25zPy5kZWJ1Z0FsbCA/PyB0YWJsZU9wdGlvbnNbZGVidWdMZXZlbF0sXG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBrZXksXG4gICAgb25DaGFuZ2UsXG4gIH1cbn1cbiIsImltcG9ydCB7IFJvd0RhdGEsIENlbGwsIENvbHVtbiwgUm93LCBUYWJsZSB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgR2V0dGVyLCBnZXRNZW1vT3B0aW9ucywgbWVtbyB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENlbGxDb250ZXh0PFREYXRhIGV4dGVuZHMgUm93RGF0YSwgVFZhbHVlPiB7XG4gIGNlbGw6IENlbGw8VERhdGEsIFRWYWx1ZT5cbiAgY29sdW1uOiBDb2x1bW48VERhdGEsIFRWYWx1ZT5cbiAgZ2V0VmFsdWU6IEdldHRlcjxUVmFsdWU+XG4gIHJlbmRlclZhbHVlOiBHZXR0ZXI8VFZhbHVlIHwgbnVsbD5cbiAgcm93OiBSb3c8VERhdGE+XG4gIHRhYmxlOiBUYWJsZTxURGF0YT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb3JlQ2VsbDxURGF0YSBleHRlbmRzIFJvd0RhdGEsIFRWYWx1ZT4ge1xuICAvKipcbiAgICogVGhlIGFzc29jaWF0ZWQgQ29sdW1uIG9iamVjdCBmb3IgdGhlIGNlbGwuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jZWxsI2NvbHVtbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NlbGxzKVxuICAgKi9cbiAgY29sdW1uOiBDb2x1bW48VERhdGEsIFRWYWx1ZT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBjb250ZXh0IChvciBwcm9wcykgZm9yIGNlbGwtYmFzZWQgY29tcG9uZW50cyBsaWtlIGNlbGxzIGFuZCBhZ2dyZWdhdGVkIGNlbGxzLiBVc2UgdGhlc2UgcHJvcHMgd2l0aCB5b3VyIGZyYW1ld29yaydzIGBmbGV4UmVuZGVyYCB1dGlsaXR5IHRvIHJlbmRlciB0aGVzZSB1c2luZyB0aGUgdGVtcGxhdGUgb2YgeW91ciBjaG9pY2U6XG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jZWxsI2dldGNvbnRleHQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jZWxscylcbiAgICovXG4gIGdldENvbnRleHQ6ICgpID0+IENlbGxDb250ZXh0PFREYXRhLCBUVmFsdWU+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGNlbGwsIGFjY2Vzc2VkIHZpYSB0aGUgYXNzb2NpYXRlZCBjb2x1bW4ncyBhY2Nlc3NvciBrZXkgb3IgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jZWxsI2dldHZhbHVlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY2VsbHMpXG4gICAqL1xuICBnZXRWYWx1ZTogQ2VsbENvbnRleHQ8VERhdGEsIFRWYWx1ZT5bJ2dldFZhbHVlJ11cbiAgLyoqXG4gICAqIFRoZSB1bmlxdWUgSUQgZm9yIHRoZSBjZWxsIGFjcm9zcyB0aGUgZW50aXJlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvY2VsbCNpZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NlbGxzKVxuICAgKi9cbiAgaWQ6IHN0cmluZ1xuICAvKipcbiAgICogUmVuZGVycyB0aGUgdmFsdWUgZm9yIGEgY2VsbCB0aGUgc2FtZSBhcyBgZ2V0VmFsdWVgLCBidXQgd2lsbCByZXR1cm4gdGhlIGByZW5kZXJGYWxsYmFja1ZhbHVlYCBpZiBubyB2YWx1ZSBpcyBmb3VuZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2NlbGwjcmVuZGVydmFsdWUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jZWxscylcbiAgICovXG4gIHJlbmRlclZhbHVlOiBDZWxsQ29udGV4dDxURGF0YSwgVFZhbHVlPlsncmVuZGVyVmFsdWUnXVxuICAvKipcbiAgICogVGhlIGFzc29jaWF0ZWQgUm93IG9iamVjdCBmb3IgdGhlIGNlbGwuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jZWxsI3JvdylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NlbGxzKVxuICAgKi9cbiAgcm93OiBSb3c8VERhdGE+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZWxsPFREYXRhIGV4dGVuZHMgUm93RGF0YSwgVFZhbHVlPihcbiAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgcm93OiBSb3c8VERhdGE+LFxuICBjb2x1bW46IENvbHVtbjxURGF0YSwgVFZhbHVlPixcbiAgY29sdW1uSWQ6IHN0cmluZ1xuKTogQ2VsbDxURGF0YSwgVFZhbHVlPiB7XG4gIGNvbnN0IGdldFJlbmRlclZhbHVlID0gKCkgPT5cbiAgICBjZWxsLmdldFZhbHVlKCkgPz8gdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlXG5cbiAgY29uc3QgY2VsbDogQ29yZUNlbGw8VERhdGEsIFRWYWx1ZT4gPSB7XG4gICAgaWQ6IGAke3Jvdy5pZH1fJHtjb2x1bW4uaWR9YCxcbiAgICByb3csXG4gICAgY29sdW1uLFxuICAgIGdldFZhbHVlOiAoKSA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpLFxuICAgIHJlbmRlclZhbHVlOiBnZXRSZW5kZXJWYWx1ZSxcbiAgICBnZXRDb250ZXh0OiBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLCBjb2x1bW4sIHJvdywgY2VsbF0sXG4gICAgICAodGFibGUsIGNvbHVtbiwgcm93LCBjZWxsKSA9PiAoe1xuICAgICAgICB0YWJsZSxcbiAgICAgICAgY29sdW1uLFxuICAgICAgICByb3csXG4gICAgICAgIGNlbGw6IGNlbGwgYXMgQ2VsbDxURGF0YSwgVFZhbHVlPixcbiAgICAgICAgZ2V0VmFsdWU6IGNlbGwuZ2V0VmFsdWUsXG4gICAgICAgIHJlbmRlclZhbHVlOiBjZWxsLnJlbmRlclZhbHVlLFxuICAgICAgfSksXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDZWxscycsICdjZWxsLmdldENvbnRleHQnKVxuICAgICksXG4gIH1cblxuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNlbGw/LihcbiAgICAgIGNlbGwgYXMgQ2VsbDxURGF0YSwgVFZhbHVlPixcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyBhcyBSb3c8VERhdGE+LFxuICAgICAgdGFibGVcbiAgICApXG4gIH0sIHt9KVxuXG4gIHJldHVybiBjZWxsIGFzIENlbGw8VERhdGEsIFRWYWx1ZT5cbn1cbiIsImltcG9ydCB7XG4gIENvbHVtbixcbiAgVGFibGUsXG4gIEFjY2Vzc29yRm4sXG4gIENvbHVtbkRlZixcbiAgUm93RGF0YSxcbiAgQ29sdW1uRGVmUmVzb2x2ZWQsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0TWVtb09wdGlvbnMsIG1lbW8gfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBDb3JlQ29sdW1uPFREYXRhIGV4dGVuZHMgUm93RGF0YSwgVFZhbHVlPiB7XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgYWNjZXNzb3IgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZXh0cmFjdGluZyB0aGUgdmFsdWUgZm9yIHRoZSBjb2x1bW4gZnJvbSBlYWNoIHJvdy4gV2lsbCBvbmx5IGJlIGRlZmluZWQgaWYgdGhlIGNvbHVtbiBkZWYgaGFzIGEgdmFsaWQgYWNjZXNzb3Iga2V5IG9yIGZ1bmN0aW9uIGRlZmluZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jb2x1bW4jYWNjZXNzb3JmbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1kZWZzKVxuICAgKi9cbiAgYWNjZXNzb3JGbj86IEFjY2Vzc29yRm48VERhdGEsIFRWYWx1ZT5cbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBjb2x1bW4gZGVmIHVzZWQgdG8gY3JlYXRlIHRoZSBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jb2x1bW4jY29sdW1uZGVmKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWRlZnMpXG4gICAqL1xuICBjb2x1bW5EZWY6IENvbHVtbkRlZjxURGF0YSwgVFZhbHVlPlxuICAvKipcbiAgICogVGhlIGNoaWxkIGNvbHVtbiAoaWYgdGhlIGNvbHVtbiBpcyBhIGdyb3VwIGNvbHVtbikuIFdpbGwgYmUgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIGNvbHVtbiBpcyBub3QgYSBncm91cCBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jb2x1bW4jY29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1kZWZzKVxuICAgKi9cbiAgY29sdW1uczogQ29sdW1uPFREYXRhLCBUVmFsdWU+W11cbiAgLyoqXG4gICAqIFRoZSBkZXB0aCBvZiB0aGUgY29sdW1uIChpZiBncm91cGVkKSByZWxhdGl2ZSB0byB0aGUgcm9vdCBjb2x1bW4gZGVmIGFycmF5LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvY29sdW1uI2RlcHRoKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWRlZnMpXG4gICAqL1xuICBkZXB0aDogbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmbGF0dGVuZWQgYXJyYXkgb2YgdGhpcyBjb2x1bW4gYW5kIGFsbCBjaGlsZC9ncmFuZC1jaGlsZCBjb2x1bW5zIGZvciB0aGlzIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2NvbHVtbiNnZXRmbGF0Y29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1kZWZzKVxuICAgKi9cbiAgZ2V0RmxhdENvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgVFZhbHVlPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBsZWFmLW5vZGUgY29sdW1ucyBmb3IgdGhpcyBjb2x1bW4uIElmIGEgY29sdW1uIGhhcyBubyBjaGlsZHJlbiwgaXQgaXMgY29uc2lkZXJlZCB0aGUgb25seSBsZWFmLW5vZGUgY29sdW1uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvY29sdW1uI2dldGxlYWZjb2x1bW5zKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWRlZnMpXG4gICAqL1xuICBnZXRMZWFmQ29sdW1uczogKCkgPT4gQ29sdW1uPFREYXRhLCBUVmFsdWU+W11cbiAgLyoqXG4gICAqIFRoZSByZXNvbHZlZCB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbHVtbiByZXNvbHZlZCBpbiB0aGlzIHByaW9yaXR5OlxuICAgICAgLSBBIG1hbnVhbCBgaWRgIHByb3BlcnR5IGZyb20gdGhlIGNvbHVtbiBkZWZcbiAgICAgIC0gVGhlIGFjY2Vzc29yIGtleSBmcm9tIHRoZSBjb2x1bW4gZGVmXG4gICAgICAtIFRoZSBoZWFkZXIgc3RyaW5nIGZyb20gdGhlIGNvbHVtbiBkZWZcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2NvbHVtbiNpZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1kZWZzKVxuICAgKi9cbiAgaWQ6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIHBhcmVudCBjb2x1bW4gZm9yIHRoaXMgY29sdW1uLiBXaWxsIGJlIHVuZGVmaW5lZCBpZiB0aGlzIGlzIGEgcm9vdCBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9jb2x1bW4jcGFyZW50KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWRlZnMpXG4gICAqL1xuICBwYXJlbnQ/OiBDb2x1bW48VERhdGEsIFRWYWx1ZT5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbHVtbjxURGF0YSBleHRlbmRzIFJvd0RhdGEsIFRWYWx1ZT4oXG4gIHRhYmxlOiBUYWJsZTxURGF0YT4sXG4gIGNvbHVtbkRlZjogQ29sdW1uRGVmPFREYXRhLCBUVmFsdWU+LFxuICBkZXB0aDogbnVtYmVyLFxuICBwYXJlbnQ/OiBDb2x1bW48VERhdGEsIFRWYWx1ZT5cbik6IENvbHVtbjxURGF0YSwgVFZhbHVlPiB7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpXG5cbiAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSB7XG4gICAgLi4uZGVmYXVsdENvbHVtbixcbiAgICAuLi5jb2x1bW5EZWYsXG4gIH0gYXMgQ29sdW1uRGVmUmVzb2x2ZWQ8VERhdGE+XG5cbiAgY29uc3QgYWNjZXNzb3JLZXkgPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleVxuXG4gIGxldCBpZCA9XG4gICAgcmVzb2x2ZWRDb2x1bW5EZWYuaWQgPz9cbiAgICAoYWNjZXNzb3JLZXlcbiAgICAgID8gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGFjY2Vzc29yS2V5LnJlcGxhY2VBbGwoJy4nLCAnXycpXG4gICAgICAgIDogYWNjZXNzb3JLZXkucmVwbGFjZSgvXFwuL2csICdfJylcbiAgICAgIDogdW5kZWZpbmVkKSA/P1xuICAgICh0eXBlb2YgcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyID09PSAnc3RyaW5nJ1xuICAgICAgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXJcbiAgICAgIDogdW5kZWZpbmVkKVxuXG4gIGxldCBhY2Nlc3NvckZuOiBBY2Nlc3NvckZuPFREYXRhPiB8IHVuZGVmaW5lZFxuXG4gIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgYWNjZXNzb3JGbiA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm5cbiAgfSBlbHNlIGlmIChhY2Nlc3NvcktleSkge1xuICAgIC8vIFN1cHBvcnQgZGVlcCBhY2Nlc3NvciBrZXlzXG4gICAgaWYgKGFjY2Vzc29yS2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGFjY2Vzc29yRm4gPSAob3JpZ2luYWxSb3c6IFREYXRhKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBvcmlnaW5hbFJvdyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWNjZXNzb3JLZXkuc3BsaXQoJy4nKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdD8uW2tleV1cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2Vzc29yRm4gPSAob3JpZ2luYWxSb3c6IFREYXRhKSA9PlxuICAgICAgICAob3JpZ2luYWxSb3cgYXMgYW55KVtyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleV1cbiAgICB9XG4gIH1cblxuICBpZiAoIWlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGblxuICAgICAgICAgID8gYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGFuIGFjY2Vzc29yRm5gXG4gICAgICAgICAgOiBgQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYSBub24tc3RyaW5nIGhlYWRlcmBcbiAgICAgIClcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfVxuXG4gIGxldCBjb2x1bW46IENvcmVDb2x1bW48VERhdGEsIGFueT4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50IGFzIGFueSxcbiAgICBkZXB0aCxcbiAgICBjb2x1bW5EZWY6IHJlc29sdmVkQ29sdW1uRGVmIGFzIENvbHVtbkRlZjxURGF0YSwgYW55PixcbiAgICBjb2x1bW5zOiBbXSxcbiAgICBnZXRGbGF0Q29sdW1uczogbWVtbyhcbiAgICAgICgpID0+IFt0cnVlXSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBjb2x1bW4gYXMgQ29sdW1uPFREYXRhLCBUVmFsdWU+LFxuICAgICAgICAgIC4uLmNvbHVtbi5jb2x1bW5zPy5mbGF0TWFwKGQgPT4gZC5nZXRGbGF0Q29sdW1ucygpKSxcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldEZsYXRDb2x1bW5zJylcbiAgICApLFxuICAgIGdldExlYWZDb2x1bW5zOiBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSxcbiAgICAgIG9yZGVyQ29sdW1ucyA9PiB7XG4gICAgICAgIGlmIChjb2x1bW4uY29sdW1ucz8ubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGxlYWZDb2x1bW5zID0gY29sdW1uLmNvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT5cbiAgICAgICAgICAgIGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbY29sdW1uIGFzIENvbHVtbjxURGF0YSwgVFZhbHVlPl1cbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRMZWFmQ29sdW1ucycpXG4gICAgKSxcbiAgfVxuXG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbj8uKGNvbHVtbiBhcyBDb2x1bW48VERhdGEsIFRWYWx1ZT4sIHRhYmxlKVxuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdW5rbm93biwgYmVjYXVzZSB3ZSBrbm93IG1vcmUgdGhhbiB0aGUgY29tcGlsZXIgaGVyZS5cbiAgcmV0dXJuIGNvbHVtbiBhcyBDb2x1bW48VERhdGEsIFRWYWx1ZT5cbn1cbiIsImltcG9ydCB7XG4gIFJvd0RhdGEsXG4gIENvbHVtbixcbiAgSGVhZGVyLFxuICBIZWFkZXJHcm91cCxcbiAgVGFibGUsXG4gIFRhYmxlRmVhdHVyZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBnZXRNZW1vT3B0aW9ucywgbWVtbyB9IGZyb20gJy4uL3V0aWxzJ1xuXG5jb25zdCBkZWJ1ZyA9ICdkZWJ1Z0hlYWRlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29yZUhlYWRlckdyb3VwPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBkZXB0aDogbnVtYmVyXG4gIGhlYWRlcnM6IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxuICBpZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyQ29udGV4dDxURGF0YSwgVFZhbHVlPiB7XG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIGNvbHVtbi5cbiAgICovXG4gIGNvbHVtbjogQ29sdW1uPFREYXRhLCBUVmFsdWU+XG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiBhIGhlYWRlci5cbiAgICovXG4gIGhlYWRlcjogSGVhZGVyPFREYXRhLCBUVmFsdWU+XG4gIC8qKlxuICAgKiBUaGUgdGFibGUgaW5zdGFuY2UuXG4gICAqL1xuICB0YWJsZTogVGFibGU8VERhdGE+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29yZUhlYWRlcjxURGF0YSBleHRlbmRzIFJvd0RhdGEsIFRWYWx1ZT4ge1xuICAvKipcbiAgICogVGhlIGNvbC1zcGFuIGZvciB0aGUgaGVhZGVyLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVyI2NvbHNwYW4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgY29sU3BhbjogbnVtYmVyXG4gIC8qKlxuICAgKiBUaGUgaGVhZGVyJ3MgYXNzb2NpYXRlZCBjb2x1bW4gb2JqZWN0LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVyI2NvbHVtbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBjb2x1bW46IENvbHVtbjxURGF0YSwgVFZhbHVlPlxuICAvKipcbiAgICogVGhlIGRlcHRoIG9mIHRoZSBoZWFkZXIsIHplcm8taW5kZXhlZCBiYXNlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlciNkZXB0aClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBkZXB0aDogbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJpbmcgY29udGV4dCAob3IgcHJvcHMpIGZvciBjb2x1bW4tYmFzZWQgY29tcG9uZW50cyBsaWtlIGhlYWRlcnMsIGZvb3RlcnMgYW5kIGZpbHRlcnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXIjZ2V0Y29udGV4dClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRDb250ZXh0OiAoKSA9PiBIZWFkZXJDb250ZXh0PFREYXRhLCBUVmFsdWU+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZWFmIGhlYWRlcnMgaGllcmFyY2hpY2FsbHkgbmVzdGVkIHVuZGVyIHRoaXMgaGVhZGVyLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVyI2dldGxlYWZoZWFkZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldExlYWZIZWFkZXJzOiAoKSA9PiBIZWFkZXI8VERhdGEsIHVua25vd24+W11cbiAgLyoqXG4gICAqIFRoZSBoZWFkZXIncyBhc3NvY2lhdGVkIGhlYWRlciBncm91cCBvYmplY3QuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXIjaGVhZGVyZ3JvdXApXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgaGVhZGVyR3JvdXA6IEhlYWRlckdyb3VwPFREYXRhPlxuICAvKipcbiAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgaGVhZGVyLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVyI2lkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGlkOiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBmb3IgdGhlIGhlYWRlciB3aXRoaW4gdGhlIGhlYWRlciBncm91cC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlciNpbmRleClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBpbmRleDogbnVtYmVyXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZGVub3RpbmcgaWYgdGhlIGhlYWRlciBpcyBhIHBsYWNlaG9sZGVyIGhlYWRlci5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlciNpc3BsYWNlaG9sZGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGlzUGxhY2Vob2xkZXI6IGJvb2xlYW5cbiAgLyoqXG4gICAqIElmIHRoZSBoZWFkZXIgaXMgYSBwbGFjZWhvbGRlciBoZWFkZXIsIHRoaXMgd2lsbCBiZSBhIHVuaXF1ZSBoZWFkZXIgSUQgdGhhdCBkb2VzIG5vdCBjb25mbGljdCB3aXRoIGFueSBvdGhlciBoZWFkZXJzIGFjcm9zcyB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXIjcGxhY2Vob2xkZXJpZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBwbGFjZWhvbGRlcklkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgcm93LXNwYW4gZm9yIHRoZSBoZWFkZXIuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXIjcm93c3BhbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICByb3dTcGFuOiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBoZWFkZXIncyBoaWVyYXJjaGljYWwgc3ViL2NoaWxkIGhlYWRlcnMuIFdpbGwgYmUgZW1wdHkgaWYgdGhlIGhlYWRlcidzIGFzc29jaWF0ZWQgY29sdW1uIGlzIGEgbGVhZi1jb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXIjc3ViaGVhZGVycylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBzdWJIZWFkZXJzOiBIZWFkZXI8VERhdGEsIFRWYWx1ZT5bXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRlcnNJbnN0YW5jZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGhlYWRlciBncm91cHMgZm9yIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0aGVhZGVyZ3JvdXBzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldEhlYWRlckdyb3VwczogKCkgPT4gSGVhZGVyR3JvdXA8VERhdGE+W11cbiAgLyoqXG4gICAqIElmIHBpbm5pbmcsIHJldHVybnMgdGhlIGhlYWRlciBncm91cHMgZm9yIHRoZSBsZWZ0IHBpbm5lZCBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRsZWZ0aGVhZGVyZ3JvdXBzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldExlZnRIZWFkZXJHcm91cHM6ICgpID0+IEhlYWRlckdyb3VwPFREYXRhPltdXG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIHRoZSBoZWFkZXIgZ3JvdXBzIGZvciBjb2x1bW5zIHRoYXQgYXJlIG5vdCBwaW5uZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXJzI2dldGNlbnRlcmhlYWRlcmdyb3VwcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRDZW50ZXJIZWFkZXJHcm91cHM6ICgpID0+IEhlYWRlckdyb3VwPFREYXRhPltdXG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIHRoZSBoZWFkZXIgZ3JvdXBzIGZvciB0aGUgcmlnaHQgcGlubmVkIGNvbHVtbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXJzI2dldHJpZ2h0aGVhZGVyZ3JvdXBzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldFJpZ2h0SGVhZGVyR3JvdXBzOiAoKSA9PiBIZWFkZXJHcm91cDxURGF0YT5bXVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb290ZXIgZ3JvdXBzIGZvciB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXJzI2dldGZvb3Rlcmdyb3VwcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRGb290ZXJHcm91cHM6ICgpID0+IEhlYWRlckdyb3VwPFREYXRhPltdXG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIHRoZSBmb290ZXIgZ3JvdXBzIGZvciB0aGUgbGVmdCBwaW5uZWQgY29sdW1ucy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0bGVmdGZvb3Rlcmdyb3VwcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRMZWZ0Rm9vdGVyR3JvdXBzOiAoKSA9PiBIZWFkZXJHcm91cDxURGF0YT5bXVxuICAvKipcbiAgICogSWYgcGlubmluZywgcmV0dXJucyB0aGUgZm9vdGVyIGdyb3VwcyBmb3IgY29sdW1ucyB0aGF0IGFyZSBub3QgcGlubmVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRjZW50ZXJmb290ZXJncm91cHMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0Q2VudGVyRm9vdGVyR3JvdXBzOiAoKSA9PiBIZWFkZXJHcm91cDxURGF0YT5bXVxuICAvKipcbiAgICogSWYgcGlubmluZywgcmV0dXJucyB0aGUgZm9vdGVyIGdyb3VwcyBmb3IgdGhlIHJpZ2h0IHBpbm5lZCBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRyaWdodGZvb3Rlcmdyb3VwcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRSaWdodEZvb3Rlckdyb3VwczogKCkgPT4gSGVhZGVyR3JvdXA8VERhdGE+W11cblxuICAvKipcbiAgICogUmV0dXJucyBoZWFkZXJzIGZvciBhbGwgY29sdW1ucyBpbiB0aGUgdGFibGUsIGluY2x1ZGluZyBwYXJlbnQgaGVhZGVycy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0ZmxhdGhlYWRlcnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0RmxhdEhlYWRlcnM6ICgpID0+IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogSWYgcGlubmluZywgcmV0dXJucyBoZWFkZXJzIGZvciBhbGwgbGVmdCBwaW5uZWQgY29sdW1ucyBpbiB0aGUgdGFibGUsIGluY2x1ZGluZyBwYXJlbnQgaGVhZGVycy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0bGVmdGZsYXRoZWFkZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldExlZnRGbGF0SGVhZGVyczogKCkgPT4gSGVhZGVyPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIGhlYWRlcnMgZm9yIGFsbCBjb2x1bW5zIHRoYXQgYXJlIG5vdCBwaW5uZWQsIGluY2x1ZGluZyBwYXJlbnQgaGVhZGVycy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0Y2VudGVyZmxhdGhlYWRlcnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0Q2VudGVyRmxhdEhlYWRlcnM6ICgpID0+IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogSWYgcGlubmluZywgcmV0dXJucyBoZWFkZXJzIGZvciBhbGwgcmlnaHQgcGlubmVkIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCBpbmNsdWRpbmcgcGFyZW50IGhlYWRlcnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9oZWFkZXJzI2dldHJpZ2h0ZmxhdGhlYWRlcnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0UmlnaHRGbGF0SGVhZGVyczogKCkgPT4gSGVhZGVyPFREYXRhLCB1bmtub3duPltdXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGVhZGVycyBmb3IgYWxsIGxlYWYgY29sdW1ucyBpbiB0aGUgdGFibGUsIChub3QgaW5jbHVkaW5nIHBhcmVudCBoZWFkZXJzKS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL2hlYWRlcnMjZ2V0bGVhZmhlYWRlcnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogSWYgcGlubmluZywgcmV0dXJucyBoZWFkZXJzIGZvciBhbGwgbGVmdCBwaW5uZWQgbGVhZiBjb2x1bW5zIGluIHRoZSB0YWJsZSwgKG5vdCBpbmNsdWRpbmcgcGFyZW50IGhlYWRlcnMpLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRsZWZ0bGVhZmhlYWRlcnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9oZWFkZXJzKVxuICAgKi9cbiAgZ2V0TGVmdExlYWZIZWFkZXJzOiAoKSA9PiBIZWFkZXI8VERhdGEsIHVua25vd24+W11cbiAgLyoqXG4gICAqIElmIHBpbm5pbmcsIHJldHVybnMgaGVhZGVycyBmb3IgYWxsIGNvbHVtbnMgdGhhdCBhcmUgbm90IHBpbm5lZCwgKG5vdCBpbmNsdWRpbmcgcGFyZW50IGhlYWRlcnMpLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRjZW50ZXJsZWFmaGVhZGVycylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2hlYWRlcnMpXG4gICAqL1xuICBnZXRDZW50ZXJMZWFmSGVhZGVyczogKCkgPT4gSGVhZGVyPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIGhlYWRlcnMgZm9yIGFsbCByaWdodCBwaW5uZWQgbGVhZiBjb2x1bW5zIGluIHRoZSB0YWJsZSwgKG5vdCBpbmNsdWRpbmcgcGFyZW50IGhlYWRlcnMpLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvaGVhZGVycyNnZXRyaWdodGxlYWZoZWFkZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvaGVhZGVycylcbiAgICovXG4gIGdldFJpZ2h0TGVhZkhlYWRlcnM6ICgpID0+IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxufVxuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXI8VERhdGEgZXh0ZW5kcyBSb3dEYXRhLCBUVmFsdWU+KFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICBjb2x1bW46IENvbHVtbjxURGF0YSwgVFZhbHVlPixcbiAgb3B0aW9uczoge1xuICAgIGlkPzogc3RyaW5nXG4gICAgaXNQbGFjZWhvbGRlcj86IGJvb2xlYW5cbiAgICBwbGFjZWhvbGRlcklkPzogc3RyaW5nXG4gICAgaW5kZXg6IG51bWJlclxuICAgIGRlcHRoOiBudW1iZXJcbiAgfVxuKTogSGVhZGVyPFREYXRhLCBUVmFsdWU+IHtcbiAgY29uc3QgaWQgPSBvcHRpb25zLmlkID8/IGNvbHVtbi5pZFxuXG4gIGxldCBoZWFkZXI6IENvcmVIZWFkZXI8VERhdGEsIFRWYWx1ZT4gPSB7XG4gICAgaWQsXG4gICAgY29sdW1uLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhb3B0aW9ucy5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG9wdGlvbnMucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwhLFxuICAgIGdldExlYWZIZWFkZXJzOiAoKTogSGVhZGVyPFREYXRhLCB1bmtub3duPltdID0+IHtcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzOiBIZWFkZXI8VERhdGEsIHVua25vd24+W10gPSBbXVxuXG4gICAgICBjb25zdCByZWN1cnNlSGVhZGVyID0gKGg6IENvcmVIZWFkZXI8VERhdGEsIGFueT4pID0+IHtcbiAgICAgICAgaWYgKGguc3ViSGVhZGVycyAmJiBoLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaC5zdWJIZWFkZXJzLm1hcChyZWN1cnNlSGVhZGVyKVxuICAgICAgICB9XG4gICAgICAgIGxlYWZIZWFkZXJzLnB1c2goaCBhcyBIZWFkZXI8VERhdGEsIHVua25vd24+KVxuICAgICAgfVxuXG4gICAgICByZWN1cnNlSGVhZGVyKGhlYWRlcilcblxuICAgICAgcmV0dXJuIGxlYWZIZWFkZXJzXG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiAoKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBoZWFkZXI6IGhlYWRlciBhcyBIZWFkZXI8VERhdGEsIFRWYWx1ZT4sXG4gICAgICBjb2x1bW4sXG4gICAgfSksXG4gIH1cblxuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUhlYWRlcj8uKGhlYWRlciBhcyBIZWFkZXI8VERhdGEsIFRWYWx1ZT4sIHRhYmxlKVxuICB9KVxuXG4gIHJldHVybiBoZWFkZXIgYXMgSGVhZGVyPFREYXRhLCBUVmFsdWU+XG59XG5cbmV4cG9ydCBjb25zdCBIZWFkZXJzOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgLy8gSGVhZGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0SGVhZGVyR3JvdXBzID0gbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGFibGUuZ2V0QWxsQ29sdW1ucygpLFxuICAgICAgICB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSxcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodCxcbiAgICAgIF0sXG4gICAgICAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxlZnRDb2x1bW5zID1cbiAgICAgICAgICBsZWZ0XG4gICAgICAgICAgICA/Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpISlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgPz8gW11cblxuICAgICAgICBjb25zdCByaWdodENvbHVtbnMgPVxuICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICA/Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpISlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgPz8gW11cblxuICAgICAgICBjb25zdCBjZW50ZXJDb2x1bW5zID0gbGVhZkNvbHVtbnMuZmlsdGVyKFxuICAgICAgICAgIGNvbHVtbiA9PiAhbGVmdD8uaW5jbHVkZXMoY29sdW1uLmlkKSAmJiAhcmlnaHQ/LmluY2x1ZGVzKGNvbHVtbi5pZClcbiAgICAgICAgKVxuXG4gICAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKFxuICAgICAgICAgIGFsbENvbHVtbnMsXG4gICAgICAgICAgWy4uLmxlZnRDb2x1bW5zLCAuLi5jZW50ZXJDb2x1bW5zLCAuLi5yaWdodENvbHVtbnNdLFxuICAgICAgICAgIHRhYmxlXG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXBzXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRIZWFkZXJHcm91cHMnKVxuICAgIClcblxuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRhYmxlLmdldEFsbENvbHVtbnMoKSxcbiAgICAgICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHQsXG4gICAgICBdLFxuICAgICAgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihcbiAgICAgICAgICBjb2x1bW4gPT4gIWxlZnQ/LmluY2x1ZGVzKGNvbHVtbi5pZCkgJiYgIXJpZ2h0Py5pbmNsdWRlcyhjb2x1bW4uaWQpXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJIZWFkZXJHcm91cHMnKVxuICAgIClcblxuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0YWJsZS5nZXRBbGxDb2x1bW5zKCksXG4gICAgICAgIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCxcbiAgICAgIF0sXG4gICAgICAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID1cbiAgICAgICAgICBsZWZ0XG4gICAgICAgICAgICA/Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpISlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgPz8gW11cblxuICAgICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEhlYWRlckdyb3VwcycpXG4gICAgKVxuXG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0YWJsZS5nZXRBbGxDb2x1bW5zKCksXG4gICAgICAgIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHQsXG4gICAgICBdLFxuICAgICAgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCByaWdodCkgPT4ge1xuICAgICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPVxuICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgICA/Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpISlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbikgPz8gW11cblxuICAgICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0JylcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJylcbiAgICApXG5cbiAgICAvLyBGb290ZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRGb290ZXJHcm91cHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSxcbiAgICAgIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZvb3Rlckdyb3VwcycpXG4gICAgKVxuXG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSxcbiAgICAgIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRGb290ZXJHcm91cHMnKVxuICAgIClcblxuICAgIHRhYmxlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCldLFxuICAgICAgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyRm9vdGVyR3JvdXBzJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRSaWdodEZvb3Rlckdyb3VwcyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sXG4gICAgICBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZvb3Rlckdyb3VwcycpXG4gICAgKVxuXG4gICAgLy8gRmxhdCBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRGbGF0SGVhZGVycyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLFxuICAgICAgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwc1xuICAgICAgICAgIC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mbGF0KClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZsYXRIZWFkZXJzJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sXG4gICAgICBsZWZ0ID0+IHtcbiAgICAgICAgcmV0dXJuIGxlZnRcbiAgICAgICAgICAubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmxhdCgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0RmxhdEhlYWRlcnMnKVxuICAgIClcblxuICAgIHRhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sXG4gICAgICBsZWZ0ID0+IHtcbiAgICAgICAgcmV0dXJuIGxlZnRcbiAgICAgICAgICAubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmxhdCgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGbGF0SGVhZGVycycpXG4gICAgKVxuXG4gICAgdGFibGUuZ2V0UmlnaHRGbGF0SGVhZGVycyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sXG4gICAgICBsZWZ0ID0+IHtcbiAgICAgICAgcmV0dXJuIGxlZnRcbiAgICAgICAgICAubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmxhdCgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZsYXRIZWFkZXJzJylcbiAgICApXG5cbiAgICAvLyBMZWFmIEhlYWRlcnNcblxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycygpXSxcbiAgICAgIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4gIWhlYWRlci5zdWJIZWFkZXJzPy5sZW5ndGgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJMZWFmSGVhZGVycycpXG4gICAgKVxuXG4gICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sXG4gICAgICBmbGF0SGVhZGVycyA9PiB7XG4gICAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+ICFoZWFkZXIuc3ViSGVhZGVycz8ubGVuZ3RoKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdExlYWZIZWFkZXJzJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRSaWdodExlYWZIZWFkZXJzID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLFxuICAgICAgZmxhdEhlYWRlcnMgPT4ge1xuICAgICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiAhaGVhZGVyLnN1YkhlYWRlcnM/Lmxlbmd0aClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0TGVhZkhlYWRlcnMnKVxuICAgIClcblxuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLFxuICAgICAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSxcbiAgICAgICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKSxcbiAgICAgIF0sXG4gICAgICAobGVmdCwgY2VudGVyLCByaWdodCkgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIC4uLihsZWZ0WzBdPy5oZWFkZXJzID8/IFtdKSxcbiAgICAgICAgICAuLi4oY2VudGVyWzBdPy5oZWFkZXJzID8/IFtdKSxcbiAgICAgICAgICAuLi4ocmlnaHRbMF0/LmhlYWRlcnMgPz8gW10pLFxuICAgICAgICBdXG4gICAgICAgICAgLm1hcChoZWFkZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlci5nZXRMZWFmSGVhZGVycygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmxhdCgpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWFmSGVhZGVycycpXG4gICAgKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgYWxsQ29sdW1uczogQ29sdW1uPFREYXRhLCB1bmtub3duPltdLFxuICBjb2x1bW5zVG9Hcm91cDogQ29sdW1uPFREYXRhLCB1bmtub3duPltdLFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICBoZWFkZXJGYW1pbHk/OiAnY2VudGVyJyB8ICdsZWZ0JyB8ICdyaWdodCdcbikge1xuICAvLyBGaW5kIHRoZSBtYXggZGVwdGggb2YgdGhlIGNvbHVtbnM6XG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcbiAgLy8gYnVpbGQgZWFjaCBidWZmZXIgcm93IGdvaW5nIHVwXG4gIC8vICAgIHBsYWNlaG9sZGVyIGZvciBub24tZXhpc3RlbnQgbGV2ZWxcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXG5cbiAgbGV0IG1heERlcHRoID0gMFxuXG4gIGNvbnN0IGZpbmRNYXhEZXB0aCA9IChjb2x1bW5zOiBDb2x1bW48VERhdGEsIHVua25vd24+W10sIGRlcHRoID0gMSkgPT4ge1xuICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGRlcHRoKVxuXG4gICAgY29sdW1uc1xuICAgICAgLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldElzVmlzaWJsZSgpKVxuICAgICAgLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbi5jb2x1bW5zPy5sZW5ndGgpIHtcbiAgICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSlcbiAgICAgICAgfVxuICAgICAgfSwgMClcbiAgfVxuXG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKVxuXG4gIGxldCBoZWFkZXJHcm91cHM6IEhlYWRlckdyb3VwPFREYXRhPltdID0gW11cblxuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChcbiAgICBoZWFkZXJzVG9Hcm91cDogSGVhZGVyPFREYXRhLCB1bmtub3duPltdLFxuICAgIGRlcHRoOiBudW1iZXJcbiAgKSA9PiB7XG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcbiAgICBjb25zdCBoZWFkZXJHcm91cDogSGVhZGVyR3JvdXA8VERhdGE+ID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdLFxuICAgIH1cblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVyczogSGVhZGVyPFREYXRhLCB1bmtub3duPltdID0gW11cblxuICAgIC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcbiAgICBoZWFkZXJzVG9Hcm91cC5mb3JFYWNoKGhlYWRlclRvR3JvdXAgPT4ge1xuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xuXG4gICAgICBjb25zdCBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID0gWy4uLnBlbmRpbmdQYXJlbnRIZWFkZXJzXS5yZXZlcnNlKClbMF1cblxuICAgICAgY29uc3QgaXNMZWFmSGVhZGVyID0gaGVhZGVyVG9Hcm91cC5jb2x1bW4uZGVwdGggPT09IGhlYWRlckdyb3VwLmRlcHRoXG5cbiAgICAgIGxldCBjb2x1bW46IENvbHVtbjxURGF0YSwgdW5rbm93bj5cbiAgICAgIGxldCBpc1BsYWNlaG9sZGVyID0gZmFsc2VcblxuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgcmVwZWF0ZWRcbiAgICAgICAgY29sdW1uID0gaGVhZGVyVG9Hcm91cC5jb2x1bW5cbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmXG4gICAgICAgIGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXI/LmNvbHVtbiA9PT0gY29sdW1uXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cD8uaWRdXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAuam9pbignXycpLFxuICAgICAgICAgIGlzUGxhY2Vob2xkZXIsXG4gICAgICAgICAgcGxhY2Vob2xkZXJJZDogaXNQbGFjZWhvbGRlclxuICAgICAgICAgICAgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YFxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aCxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcbiAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKVxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKVxuICAgICAgfVxuXG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cClcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cFxuICAgIH0pXG5cbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cClcblxuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIGNyZWF0ZUhlYWRlckdyb3VwKHBlbmRpbmdQYXJlbnRIZWFkZXJzLCBkZXB0aCAtIDEpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYm90dG9tSGVhZGVycyA9IGNvbHVtbnNUb0dyb3VwLm1hcCgoY29sdW1uLCBpbmRleCkgPT5cbiAgICBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgICAgZGVwdGg6IG1heERlcHRoLFxuICAgICAgaW5kZXgsXG4gICAgfSlcbiAgKVxuXG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSlcblxuICBoZWFkZXJHcm91cHMucmV2ZXJzZSgpXG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gKFxuICAgIGhlYWRlcnM6IEhlYWRlcjxURGF0YSwgdW5rbm93bj5bXVxuICApOiB7IGNvbFNwYW46IG51bWJlcjsgcm93U3BhbjogbnVtYmVyIH1bXSA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+XG4gICAgICBoZWFkZXIuY29sdW1uLmdldElzVmlzaWJsZSgpXG4gICAgKVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkSGVhZGVycy5tYXAoaGVhZGVyID0+IHtcbiAgICAgIGxldCBjb2xTcGFuID0gMFxuICAgICAgbGV0IHJvd1NwYW4gPSAwXG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXVxuXG4gICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMgJiYgaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkUm93U3BhbnMgPSBbXVxuXG4gICAgICAgIHJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMoaGVhZGVyLnN1YkhlYWRlcnMpLmZvckVhY2goXG4gICAgICAgICAgKHsgY29sU3BhbjogY2hpbGRDb2xTcGFuLCByb3dTcGFuOiBjaGlsZFJvd1NwYW4gfSkgPT4ge1xuICAgICAgICAgICAgY29sU3BhbiArPSBjaGlsZENvbFNwYW5cbiAgICAgICAgICAgIGNoaWxkUm93U3BhbnMucHVzaChjaGlsZFJvd1NwYW4pXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtaW5DaGlsZFJvd1NwYW4gPSBNYXRoLm1pbiguLi5jaGlsZFJvd1NwYW5zKVxuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW5cblxuICAgICAgaGVhZGVyLmNvbFNwYW4gPSBjb2xTcGFuXG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW5cblxuICAgICAgcmV0dXJuIHsgY29sU3Bhbiwgcm93U3BhbiB9XG4gICAgfSlcbiAgfVxuXG4gIHJlY3Vyc2VIZWFkZXJzRm9yU3BhbnMoaGVhZGVyR3JvdXBzWzBdPy5oZWFkZXJzID8/IFtdKVxuXG4gIHJldHVybiBoZWFkZXJHcm91cHNcbn1cbiIsImltcG9ydCB7IFJvd0RhdGEsIENlbGwsIFJvdywgVGFibGUgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGZsYXR0ZW5CeSwgZ2V0TWVtb09wdGlvbnMsIG1lbW8gfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGNyZWF0ZUNlbGwgfSBmcm9tICcuL2NlbGwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29yZVJvdzxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogKCkgPT4gUmVjb3JkPHN0cmluZywgQ2VsbDxURGF0YSwgdW5rbm93bj4+XG4gIF91bmlxdWVWYWx1ZXNDYWNoZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgX3ZhbHVlc0NhY2hlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAvKipcbiAgICogVGhlIGRlcHRoIG9mIHRoZSByb3cgKGlmIG5lc3RlZCBvciBncm91cGVkKSByZWxhdGl2ZSB0byB0aGUgcm9vdCByb3cgYXJyYXkuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9yb3cjZGVwdGgpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3dzKVxuICAgKi9cbiAgZGVwdGg6IG51bWJlclxuICAvKipcbiAgICogUmV0dXJucyBhbGwgb2YgdGhlIGNlbGxzIGZvciB0aGUgcm93LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvcm93I2dldGFsbGNlbGxzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93cylcbiAgICovXG4gIGdldEFsbENlbGxzOiAoKSA9PiBDZWxsPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZWFmIHJvd3MgZm9yIHRoZSByb3csIG5vdCBpbmNsdWRpbmcgYW55IHBhcmVudCByb3dzLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvcm93I2dldGxlYWZyb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93cylcbiAgICovXG4gIGdldExlYWZSb3dzOiAoKSA9PiBSb3c8VERhdGE+W11cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCByb3cgZm9yIHRoZSByb3csIGlmIGl0IGV4aXN0cy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3JvdyNnZXRwYXJlbnRyb3cpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3dzKVxuICAgKi9cbiAgZ2V0UGFyZW50Um93OiAoKSA9PiBSb3c8VERhdGE+IHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgcm93cyBmb3IgdGhlIHJvdywgYWxsIHRoZSB3YXkgdXAgdG8gYSByb290IHJvdy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3JvdyNnZXRwYXJlbnRyb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93cylcbiAgICovXG4gIGdldFBhcmVudFJvd3M6ICgpID0+IFJvdzxURGF0YT5bXVxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBhcnJheSBvZiB2YWx1ZXMgZnJvbSB0aGUgcm93IGZvciBhIGdpdmVuIGNvbHVtbklkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvcm93I2dldHVuaXF1ZXZhbHVlcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvd3MpXG4gICAqL1xuICBnZXRVbmlxdWVWYWx1ZXM6IDxUVmFsdWU+KGNvbHVtbklkOiBzdHJpbmcpID0+IFRWYWx1ZVtdXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSByb3cgZm9yIGEgZ2l2ZW4gY29sdW1uSWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9yb3cjZ2V0dmFsdWUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3dzKVxuICAgKi9cbiAgZ2V0VmFsdWU6IDxUVmFsdWU+KGNvbHVtbklkOiBzdHJpbmcpID0+IFRWYWx1ZVxuICAvKipcbiAgICogVGhlIHJlc29sdmVkIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcm93IHJlc29sdmVkIHZpYSB0aGUgYG9wdGlvbnMuZ2V0Um93SWRgIG9wdGlvbi4gRGVmYXVsdHMgdG8gdGhlIHJvdydzIGluZGV4IChvciByZWxhdGl2ZSBpbmRleCBpZiBpdCBpcyBhIHN1YlJvdykuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9yb3cjaWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3dzKVxuICAgKi9cbiAgaWQ6IHN0cmluZ1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSByb3cgd2l0aGluIGl0cyBwYXJlbnQgYXJyYXkgKG9yIHRoZSByb290IGRhdGEgYXJyYXkpLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvcm93I2luZGV4KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93cylcbiAgICovXG4gIGluZGV4OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCByb3cgb2JqZWN0IHByb3ZpZGVkIHRvIHRoZSB0YWJsZS4gSWYgdGhlIHJvdyBpcyBhIGdyb3VwZWQgcm93LCB0aGUgb3JpZ2luYWwgcm93IG9iamVjdCB3aWxsIGJlIHRoZSBmaXJzdCBvcmlnaW5hbCBpbiB0aGUgZ3JvdXAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9yb3cjb3JpZ2luYWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3dzKVxuICAgKi9cbiAgb3JpZ2luYWw6IFREYXRhXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiB0aGUgb3JpZ2luYWwgc3ViUm93cyBhcyByZXR1cm5lZCBieSB0aGUgYG9wdGlvbnMuZ2V0U3ViUm93c2Agb3B0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvcm93I29yaWdpbmFsc3Vicm93cylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvd3MpXG4gICAqL1xuICBvcmlnaW5hbFN1YlJvd3M/OiBURGF0YVtdXG4gIC8qKlxuICAgKiBJZiBuZXN0ZWQsIHRoaXMgcm93J3MgcGFyZW50IHJvdyBpZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3JvdyNwYXJlbnRpZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvd3MpXG4gICAqL1xuICBwYXJlbnRJZD86IHN0cmluZ1xuICAvKipcbiAgICogUmVuZGVycyB0aGUgdmFsdWUgZm9yIHRoZSByb3cgaW4gYSBnaXZlbiBjb2x1bW5JZCB0aGUgc2FtZSBhcyBgZ2V0VmFsdWVgLCBidXQgd2lsbCByZXR1cm4gdGhlIGByZW5kZXJGYWxsYmFja1ZhbHVlYCBpZiBubyB2YWx1ZSBpcyBmb3VuZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3JvdyNyZW5kZXJ2YWx1ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvd3MpXG4gICAqL1xuICByZW5kZXJWYWx1ZTogPFRWYWx1ZT4oY29sdW1uSWQ6IHN0cmluZykgPT4gVFZhbHVlXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBzdWJSb3dzIGZvciB0aGUgcm93IGFzIHJldHVybmVkIGFuZCBjcmVhdGVkIGJ5IHRoZSBgb3B0aW9ucy5nZXRTdWJSb3dzYCBvcHRpb24uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS9yb3cjc3Vicm93cylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvd3MpXG4gICAqL1xuICBzdWJSb3dzOiBSb3c8VERhdGE+W11cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdyA9IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICBpZDogc3RyaW5nLFxuICBvcmlnaW5hbDogVERhdGEsXG4gIHJvd0luZGV4OiBudW1iZXIsXG4gIGRlcHRoOiBudW1iZXIsXG4gIHN1YlJvd3M/OiBSb3c8VERhdGE+W10sXG4gIHBhcmVudElkPzogc3RyaW5nXG4pOiBSb3c8VERhdGE+ID0+IHtcbiAgbGV0IHJvdzogQ29yZVJvdzxURGF0YT4gPSB7XG4gICAgaWQsXG4gICAgaW5kZXg6IHJvd0luZGV4LFxuICAgIG9yaWdpbmFsLFxuICAgIGRlcHRoLFxuICAgIHBhcmVudElkLFxuICAgIF92YWx1ZXNDYWNoZToge30sXG4gICAgX3VuaXF1ZVZhbHVlc0NhY2hlOiB7fSxcbiAgICBnZXRWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpXG5cbiAgICAgIGlmICghY29sdW1uPy5hY2Nlc3NvckZuKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihcbiAgICAgICAgcm93Lm9yaWdpbmFsIGFzIFREYXRhLFxuICAgICAgICByb3dJbmRleFxuICAgICAgKVxuXG4gICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gYXMgYW55XG4gICAgfSxcbiAgICBnZXRVbmlxdWVWYWx1ZXM6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3VuaXF1ZVZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF1cbiAgICAgIH1cblxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKVxuXG4gICAgICBpZiAoIWNvbHVtbj8uYWNjZXNzb3JGbikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmICghY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV1cbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdXG4gICAgICB9XG5cbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMoXG4gICAgICAgIHJvdy5vcmlnaW5hbCBhcyBURGF0YSxcbiAgICAgICAgcm93SW5kZXhcbiAgICAgIClcblxuICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdIGFzIGFueVxuICAgIH0sXG4gICAgcmVuZGVyVmFsdWU6IGNvbHVtbklkID0+XG4gICAgICByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID8/IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZSxcbiAgICBzdWJSb3dzOiBzdWJSb3dzID8/IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBmbGF0dGVuQnkocm93LnN1YlJvd3MsIGQgPT4gZC5zdWJSb3dzKSxcbiAgICBnZXRQYXJlbnRSb3c6ICgpID0+XG4gICAgICByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgcGFyZW50Um93czogUm93PFREYXRhPltdID0gW11cbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3cgPSBjdXJyZW50Um93LmdldFBhcmVudFJvdygpXG4gICAgICAgIGlmICghcGFyZW50Um93KSBicmVha1xuICAgICAgICBwYXJlbnRSb3dzLnB1c2gocGFyZW50Um93KVxuICAgICAgICBjdXJyZW50Um93ID0gcGFyZW50Um93XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKClcbiAgICB9LFxuICAgIGdldEFsbENlbGxzOiBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLFxuICAgICAgbGVhZkNvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gbGVhZkNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNlbGwodGFibGUsIHJvdyBhcyBSb3c8VERhdGE+LCBjb2x1bW4sIGNvbHVtbi5pZClcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEFsbENlbGxzJylcbiAgICApLFxuXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbyhcbiAgICAgICgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKV0sXG4gICAgICBhbGxDZWxscyA9PiB7XG4gICAgICAgIHJldHVybiBhbGxDZWxscy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY2VsbCkgPT4ge1xuICAgICAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGxcbiAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIENlbGw8VERhdGEsIHVua25vd24+PlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxsc0J5Q29sdW1uSWQnKVxuICAgICksXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV1cbiAgICBmZWF0dXJlPy5jcmVhdGVSb3c/Lihyb3cgYXMgUm93PFREYXRhPiwgdGFibGUpXG4gIH1cblxuICByZXR1cm4gcm93IGFzIFJvdzxURGF0YT5cbn1cbiIsImltcG9ydCB7IFJvd01vZGVsIH0gZnJvbSAnLi4nXG5pbXBvcnQgeyBDb2x1bW4sIFJvd0RhdGEsIFRhYmxlLCBUYWJsZUZlYXR1cmUgfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBGYWNldGVkQ29sdW1uPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcz86ICgpID0+IHVuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl1cbiAgX2dldEZhY2V0ZWRSb3dNb2RlbD86ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICBfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcz86ICgpID0+IE1hcDxhbnksIG51bWJlcj5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCAqKmNvbXB1dGVzIGFuZCByZXR1cm5zKiogYSBtaW4vbWF4IHR1cGxlIGRlcml2ZWQgZnJvbSBgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbGAuIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBmYWNldGVkIHJlc3VsdCB2YWx1ZXMuXG4gICAqID4g4pqg77iPIFJlcXVpcmVzIHRoYXQgeW91IHBhc3MgYSB2YWxpZCBgZ2V0RmFjZXRlZE1pbk1heFZhbHVlc2AgZnVuY3Rpb24gdG8gYG9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlc2AuIEEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBwcm92aWRlZCB2aWEgdGhlIGV4cG9ydGVkIGBnZXRGYWNldGVkTWluTWF4VmFsdWVzYCBmdW5jdGlvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmFjZXRpbmcjZ2V0ZmFjZXRlZG1pbm1heHZhbHVlcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1mYWNldGluZylcbiAgICovXG4gIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXM6ICgpID0+IHVuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCB3aXRoIGFsbCBvdGhlciBjb2x1bW4gZmlsdGVycyBhcHBsaWVkLCBleGNsdWRpbmcgaXRzIG93biBmaWx0ZXIuIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBmYWNldGVkIHJlc3VsdCBjb3VudHMuXG4gICAqID4g4pqg77iPIFJlcXVpcmVzIHRoYXQgeW91IHBhc3MgYSB2YWxpZCBgZ2V0RmFjZXRlZFJvd01vZGVsYCBmdW5jdGlvbiB0byBgb3B0aW9ucy5mYWNldGVkUm93TW9kZWxgLiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgcHJvdmlkZWQgdmlhIHRoZSBleHBvcnRlZCBgZ2V0RmFjZXRlZFJvd01vZGVsYCBmdW5jdGlvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmFjZXRpbmcjZ2V0ZmFjZXRlZHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZhY2V0aW5nKVxuICAgKi9cbiAgZ2V0RmFjZXRlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCAqKmNvbXB1dGVzIGFuZCByZXR1cm5zKiogYSBgTWFwYCBvZiB1bmlxdWUgdmFsdWVzIGFuZCB0aGVpciBvY2N1cnJlbmNlcyBkZXJpdmVkIGZyb20gYGNvbHVtbi5nZXRGYWNldGVkUm93TW9kZWxgLiBVc2VmdWwgZm9yIGRpc3BsYXlpbmcgZmFjZXRlZCByZXN1bHQgdmFsdWVzLlxuICAgKiA+IOKaoO+4jyBSZXF1aXJlcyB0aGF0IHlvdSBwYXNzIGEgdmFsaWQgYGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNgIGZ1bmN0aW9uIHRvIGBvcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXNgLiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgcHJvdmlkZWQgdmlhIHRoZSBleHBvcnRlZCBgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlc2AgZnVuY3Rpb24uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZhY2V0aW5nI2dldGZhY2V0ZWR1bmlxdWV2YWx1ZXMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmFjZXRpbmcpXG4gICAqL1xuICBnZXRGYWNldGVkVW5pcXVlVmFsdWVzOiAoKSA9PiBNYXA8YW55LCBudW1iZXI+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmFjZXRlZE9wdGlvbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXM/OiAoXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgICBjb2x1bW5JZDogc3RyaW5nXG4gICkgPT4gKCkgPT4gdW5kZWZpbmVkIHwgW251bWJlciwgbnVtYmVyXVxuICBnZXRGYWNldGVkUm93TW9kZWw/OiAoXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgICBjb2x1bW5JZDogc3RyaW5nXG4gICkgPT4gKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXM/OiAoXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgICBjb2x1bW5JZDogc3RyaW5nXG4gICkgPT4gKCkgPT4gTWFwPGFueSwgbnVtYmVyPlxufVxuXG4vL1xuXG5leHBvcnQgY29uc3QgQ29sdW1uRmFjZXRpbmc6IFRhYmxlRmVhdHVyZSA9IHtcbiAgY3JlYXRlQ29sdW1uOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgICBjb2x1bW46IENvbHVtbjxURGF0YSwgdW5rbm93bj4sXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCA9XG4gICAgICB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJlxuICAgICAgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsIGNvbHVtbi5pZClcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCgpXG4gICAgfVxuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9XG4gICAgICB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiZcbiAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKVxuICAgIGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKClcbiAgICB9XG4gICAgY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzID1cbiAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJlxuICAgICAgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpXG4gICAgY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKVxuICAgIH1cbiAgfSxcbn1cbiIsImltcG9ydCB7IEZpbHRlckZuIH0gZnJvbSAnLi9mZWF0dXJlcy9Db2x1bW5GaWx0ZXJpbmcnXG5cbmNvbnN0IGluY2x1ZGVzU3RyaW5nOiBGaWx0ZXJGbjxhbnk+ID0gKFxuICByb3csXG4gIGNvbHVtbklkOiBzdHJpbmcsXG4gIGZpbHRlclZhbHVlOiBzdHJpbmdcbikgPT4ge1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZT8udG9TdHJpbmcoKT8udG9Mb3dlckNhc2UoKVxuICByZXR1cm4gQm9vbGVhbihcbiAgICByb3dcbiAgICAgIC5nZXRWYWx1ZTxzdHJpbmcgfCBudWxsPihjb2x1bW5JZClcbiAgICAgID8udG9TdHJpbmcoKVxuICAgICAgPy50b0xvd2VyQ2FzZSgpXG4gICAgICA/LmluY2x1ZGVzKHNlYXJjaClcbiAgKVxufVxuXG5pbmNsdWRlc1N0cmluZy5hdXRvUmVtb3ZlID0gKHZhbDogYW55KSA9PiB0ZXN0RmFsc2V5KHZhbClcblxuY29uc3QgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmU6IEZpbHRlckZuPGFueT4gPSAoXG4gIHJvdyxcbiAgY29sdW1uSWQ6IHN0cmluZyxcbiAgZmlsdGVyVmFsdWU6IHN0cmluZ1xuKSA9PiB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHJvdy5nZXRWYWx1ZTxzdHJpbmcgfCBudWxsPihjb2x1bW5JZCk/LnRvU3RyaW5nKCk/LmluY2x1ZGVzKGZpbHRlclZhbHVlKVxuICApXG59XG5cbmluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLmF1dG9SZW1vdmUgPSAodmFsOiBhbnkpID0+IHRlc3RGYWxzZXkodmFsKVxuXG5jb25zdCBlcXVhbHNTdHJpbmc6IEZpbHRlckZuPGFueT4gPSAoXG4gIHJvdyxcbiAgY29sdW1uSWQ6IHN0cmluZyxcbiAgZmlsdGVyVmFsdWU6IHN0cmluZ1xuKSA9PiB7XG4gIHJldHVybiAoXG4gICAgcm93LmdldFZhbHVlPHN0cmluZyB8IG51bGw+KGNvbHVtbklkKT8udG9TdHJpbmcoKT8udG9Mb3dlckNhc2UoKSA9PT1cbiAgICBmaWx0ZXJWYWx1ZT8udG9Mb3dlckNhc2UoKVxuICApXG59XG5cbmVxdWFsc1N0cmluZy5hdXRvUmVtb3ZlID0gKHZhbDogYW55KSA9PiB0ZXN0RmFsc2V5KHZhbClcblxuY29uc3QgYXJySW5jbHVkZXM6IEZpbHRlckZuPGFueT4gPSAoXG4gIHJvdyxcbiAgY29sdW1uSWQ6IHN0cmluZyxcbiAgZmlsdGVyVmFsdWU6IHVua25vd25cbikgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlPHVua25vd25bXT4oY29sdW1uSWQpPy5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSlcbn1cblxuYXJySW5jbHVkZXMuYXV0b1JlbW92ZSA9ICh2YWw6IGFueSkgPT4gdGVzdEZhbHNleSh2YWwpXG5cbmNvbnN0IGFyckluY2x1ZGVzQWxsOiBGaWx0ZXJGbjxhbnk+ID0gKFxuICByb3csXG4gIGNvbHVtbklkOiBzdHJpbmcsXG4gIGZpbHRlclZhbHVlOiB1bmtub3duW11cbikgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUoXG4gICAgdmFsID0+ICFyb3cuZ2V0VmFsdWU8dW5rbm93bltdPihjb2x1bW5JZCk/LmluY2x1ZGVzKHZhbClcbiAgKVxufVxuXG5hcnJJbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gKHZhbDogYW55KSA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgIXZhbD8ubGVuZ3RoXG5cbmNvbnN0IGFyckluY2x1ZGVzU29tZTogRmlsdGVyRm48YW55PiA9IChcbiAgcm93LFxuICBjb2x1bW5JZDogc3RyaW5nLFxuICBmaWx0ZXJWYWx1ZTogdW5rbm93bltdXG4pID0+IHtcbiAgcmV0dXJuIGZpbHRlclZhbHVlLnNvbWUodmFsID0+XG4gICAgcm93LmdldFZhbHVlPHVua25vd25bXT4oY29sdW1uSWQpPy5pbmNsdWRlcyh2YWwpXG4gIClcbn1cblxuYXJySW5jbHVkZXNTb21lLmF1dG9SZW1vdmUgPSAodmFsOiBhbnkpID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhdmFsPy5sZW5ndGhcblxuY29uc3QgZXF1YWxzOiBGaWx0ZXJGbjxhbnk+ID0gKHJvdywgY29sdW1uSWQ6IHN0cmluZywgZmlsdGVyVmFsdWU6IHVua25vd24pID0+IHtcbiAgcmV0dXJuIHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkgPT09IGZpbHRlclZhbHVlXG59XG5cbmVxdWFscy5hdXRvUmVtb3ZlID0gKHZhbDogYW55KSA9PiB0ZXN0RmFsc2V5KHZhbClcblxuY29uc3Qgd2Vha0VxdWFsczogRmlsdGVyRm48YW55PiA9IChcbiAgcm93LFxuICBjb2x1bW5JZDogc3RyaW5nLFxuICBmaWx0ZXJWYWx1ZTogdW5rbm93blxuKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlXG59XG5cbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9ICh2YWw6IGFueSkgPT4gdGVzdEZhbHNleSh2YWwpXG5cbmNvbnN0IGluTnVtYmVyUmFuZ2U6IEZpbHRlckZuPGFueT4gPSAoXG4gIHJvdyxcbiAgY29sdW1uSWQ6IHN0cmluZyxcbiAgZmlsdGVyVmFsdWU6IFtudW1iZXIsIG51bWJlcl1cbikgPT4ge1xuICBsZXQgW21pbiwgbWF4XSA9IGZpbHRlclZhbHVlXG5cbiAgY29uc3Qgcm93VmFsdWUgPSByb3cuZ2V0VmFsdWU8bnVtYmVyPihjb2x1bW5JZClcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXhcbn1cblxuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSAodmFsOiBbYW55LCBhbnldKSA9PiB7XG4gIGxldCBbdW5zYWZlTWluLCB1bnNhZmVNYXhdID0gdmFsXG5cbiAgbGV0IHBhcnNlZE1pbiA9XG4gICAgdHlwZW9mIHVuc2FmZU1pbiAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1pbiBhcyBzdHJpbmcpIDogdW5zYWZlTWluXG4gIGxldCBwYXJzZWRNYXggPVxuICAgIHR5cGVvZiB1bnNhZmVNYXggIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNYXggYXMgc3RyaW5nKSA6IHVuc2FmZU1heFxuXG4gIGxldCBtaW4gPVxuICAgIHVuc2FmZU1pbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocGFyc2VkTWluKSA/IC1JbmZpbml0eSA6IHBhcnNlZE1pblxuICBsZXQgbWF4ID0gdW5zYWZlTWF4ID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNYXgpID8gSW5maW5pdHkgOiBwYXJzZWRNYXhcblxuICBpZiAobWluID4gbWF4KSB7XG4gICAgY29uc3QgdGVtcCA9IG1pblxuICAgIG1pbiA9IG1heFxuICAgIG1heCA9IHRlbXBcbiAgfVxuXG4gIHJldHVybiBbbWluLCBtYXhdIGFzIGNvbnN0XG59XG5cbmluTnVtYmVyUmFuZ2UuYXV0b1JlbW92ZSA9ICh2YWw6IGFueSkgPT5cbiAgdGVzdEZhbHNleSh2YWwpIHx8ICh0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pKVxuXG4vLyBFeHBvcnRcblxuZXhwb3J0IGNvbnN0IGZpbHRlckZucyA9IHtcbiAgaW5jbHVkZXNTdHJpbmcsXG4gIGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLFxuICBlcXVhbHNTdHJpbmcsXG4gIGFyckluY2x1ZGVzLFxuICBhcnJJbmNsdWRlc0FsbCxcbiAgYXJySW5jbHVkZXNTb21lLFxuICBlcXVhbHMsXG4gIHdlYWtFcXVhbHMsXG4gIGluTnVtYmVyUmFuZ2UsXG59XG5cbmV4cG9ydCB0eXBlIEJ1aWx0SW5GaWx0ZXJGbiA9IGtleW9mIHR5cGVvZiBmaWx0ZXJGbnNcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gdGVzdEZhbHNleSh2YWw6IGFueSkge1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJydcbn1cbiIsImltcG9ydCB7IFJvd01vZGVsIH0gZnJvbSAnLi4nXG5pbXBvcnQgeyBCdWlsdEluRmlsdGVyRm4sIGZpbHRlckZucyB9IGZyb20gJy4uL2ZpbHRlckZucydcbmltcG9ydCB7XG4gIENvbHVtbixcbiAgRmlsdGVyRm5zLFxuICBGaWx0ZXJNZXRhLFxuICBPbkNoYW5nZUZuLFxuICBSb3csXG4gIFJvd0RhdGEsXG4gIFRhYmxlLFxuICBUYWJsZUZlYXR1cmUsXG4gIFVwZGF0ZXIsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgZnVuY3Rpb25hbFVwZGF0ZSwgaXNGdW5jdGlvbiwgbWFrZVN0YXRlVXBkYXRlciB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbkZpbHRlcnNUYWJsZVN0YXRlIHtcbiAgY29sdW1uRmlsdGVyczogQ29sdW1uRmlsdGVyc1N0YXRlXG59XG5cbmV4cG9ydCB0eXBlIENvbHVtbkZpbHRlcnNTdGF0ZSA9IENvbHVtbkZpbHRlcltdXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uRmlsdGVyIHtcbiAgaWQ6IHN0cmluZ1xuICB2YWx1ZTogdW5rbm93blxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc29sdmVkQ29sdW1uRmlsdGVyPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBmaWx0ZXJGbjogRmlsdGVyRm48VERhdGE+XG4gIGlkOiBzdHJpbmdcbiAgcmVzb2x2ZWRWYWx1ZTogdW5rbm93blxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlckZuPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAoXG4gICAgcm93OiBSb3c8VERhdGE+LFxuICAgIGNvbHVtbklkOiBzdHJpbmcsXG4gICAgZmlsdGVyVmFsdWU6IGFueSxcbiAgICBhZGRNZXRhOiAobWV0YTogRmlsdGVyTWV0YSkgPT4gdm9pZFxuICApOiBib29sZWFuXG4gIGF1dG9SZW1vdmU/OiBDb2x1bW5GaWx0ZXJBdXRvUmVtb3ZlVGVzdEZuPFREYXRhPlxuICByZXNvbHZlRmlsdGVyVmFsdWU/OiBUcmFuc2Zvcm1GaWx0ZXJWYWx1ZUZuPFREYXRhPlxufVxuXG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1GaWx0ZXJWYWx1ZUZuPFREYXRhIGV4dGVuZHMgUm93RGF0YT4gPSAoXG4gIHZhbHVlOiBhbnksXG4gIGNvbHVtbj86IENvbHVtbjxURGF0YSwgdW5rbm93bj5cbikgPT4gdW5rbm93blxuXG5leHBvcnQgdHlwZSBDb2x1bW5GaWx0ZXJBdXRvUmVtb3ZlVGVzdEZuPFREYXRhIGV4dGVuZHMgUm93RGF0YT4gPSAoXG4gIHZhbHVlOiBhbnksXG4gIGNvbHVtbj86IENvbHVtbjxURGF0YSwgdW5rbm93bj5cbikgPT4gYm9vbGVhblxuXG5leHBvcnQgdHlwZSBDdXN0b21GaWx0ZXJGbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiA9IFJlY29yZDxcbiAgc3RyaW5nLFxuICBGaWx0ZXJGbjxURGF0YT5cbj5cblxuZXhwb3J0IHR5cGUgRmlsdGVyRm5PcHRpb248VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiA9XG4gIHwgJ2F1dG8nXG4gIHwgQnVpbHRJbkZpbHRlckZuXG4gIHwga2V5b2YgRmlsdGVyRm5zXG4gIHwgRmlsdGVyRm48VERhdGE+XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uRmlsdGVyc0NvbHVtbkRlZjxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgdGhlICoqY29sdW1uKiogZmlsdGVyIGZvciB0aGlzIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI2VuYWJsZWNvbHVtbmZpbHRlcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBlbmFibGVDb2x1bW5GaWx0ZXI/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgZmlsdGVyIGZ1bmN0aW9uIHRvIHVzZSB3aXRoIHRoaXMgY29sdW1uLiBDYW4gYmUgdGhlIG5hbWUgb2YgYSBidWlsdC1pbiBmaWx0ZXIgZnVuY3Rpb24gb3IgYSBjdXN0b20gZmlsdGVyIGZ1bmN0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZmlsdGVyZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgZmlsdGVyRm4/OiBGaWx0ZXJGbk9wdGlvbjxURGF0YT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5GaWx0ZXJzQ29sdW1uPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogUmV0dXJucyBhbiBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgZmlsdGVyIGZ1bmN0aW9uIGZvciB0aGUgY29sdW1uIGJhc2VkIG9mZiBvZiB0aGUgY29sdW1ucyBmaXJzdCBrbm93biB2YWx1ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI2dldGF1dG9maWx0ZXJmbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBnZXRBdXRvRmlsdGVyRm46ICgpID0+IEZpbHRlckZuPFREYXRhPiB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29sdW1uIGNhbiBiZSAqKmNvbHVtbioqIGZpbHRlcmVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZ2V0Y2FuZmlsdGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIGdldENhbkZpbHRlcjogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsdGVyIGZ1bmN0aW9uIChlaXRoZXIgdXNlci1kZWZpbmVkIG9yIGF1dG9tYXRpYywgZGVwZW5kaW5nIG9uIGNvbmZpZ3VyYXRpb24pIGZvciB0aGUgY29sdW1uSWQgc3BlY2lmaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZ2V0ZmlsdGVyZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgZ2V0RmlsdGVyRm46ICgpID0+IEZpbHRlckZuPFREYXRhPiB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggKGluY2x1ZGluZyBgLTFgKSBvZiB0aGUgY29sdW1uIGZpbHRlciBpbiB0aGUgdGFibGUncyBgc3RhdGUuY29sdW1uRmlsdGVyc2AgYXJyYXkuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNnZXRmaWx0ZXJpbmRleClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBnZXRGaWx0ZXJJbmRleDogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZSBmb3IgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI2dldGZpbHRlcnZhbHVlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIGdldEZpbHRlclZhbHVlOiAoKSA9PiB1bmtub3duXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IGZpbHRlcmVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZ2V0aXNmaWx0ZXJlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBnZXRJc0ZpbHRlcmVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgc2V0cyB0aGUgY3VycmVudCBmaWx0ZXIgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFlvdSBjYW4gcGFzcyBpdCBhIHZhbHVlIG9yIGFuIHVwZGF0ZXIgZnVuY3Rpb24gZm9yIGltbXV0YWJpbGl0eS1zYWZlIG9wZXJhdGlvbnMgb24gZXhpc3RpbmcgdmFsdWVzLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjc2V0ZmlsdGVydmFsdWUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgc2V0RmlsdGVyVmFsdWU6ICh1cGRhdGVyOiBVcGRhdGVyPGFueT4pID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5GaWx0ZXJzUm93PFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogVGhlIGNvbHVtbiBmaWx0ZXJzIG1hcCBmb3IgdGhlIHJvdy4gVGhpcyBvYmplY3QgdHJhY2tzIHdoZXRoZXIgYSByb3cgaXMgcGFzc2luZy9mYWlsaW5nIHNwZWNpZmljIGZpbHRlcnMgYnkgdGhlaXIgY29sdW1uIElELlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjY29sdW1uZmlsdGVycylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBjb2x1bW5GaWx0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPlxuICAvKipcbiAgICogVGhlIGNvbHVtbiBmaWx0ZXJzIG1ldGEgbWFwIGZvciB0aGUgcm93LiBUaGlzIG9iamVjdCB0cmFja3MgYW55IGZpbHRlciBtZXRhIGZvciBhIHJvdyBhcyBvcHRpb25hbGx5IHByb3ZpZGVkIGR1cmluZyB0aGUgZmlsdGVyaW5nIHByb2Nlc3MuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNjb2x1bW5maWx0ZXJzbWV0YSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBjb2x1bW5GaWx0ZXJzTWV0YTogUmVjb3JkPHN0cmluZywgRmlsdGVyTWV0YT5cbn1cblxuaW50ZXJmYWNlIENvbHVtbkZpbHRlcnNPcHRpb25zQmFzZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgKipjb2x1bW4qKiBmaWx0ZXJpbmcgZm9yIGFsbCBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZW5hYmxlY29sdW1uZmlsdGVycylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBlbmFibGVDb2x1bW5GaWx0ZXJzPzogYm9vbGVhblxuICAvKipcbiAgICogRW5hYmxlcy9kaXNhYmxlcyBhbGwgZmlsdGVyaW5nIGZvciB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNlbmFibGVmaWx0ZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIGVuYWJsZUZpbHRlcnM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBmaWx0ZXJpbmcgaXMgZG9uZSBmcm9tIHBhcmVudCByb3dzIGRvd24gKHNvIGlmIGEgcGFyZW50IHJvdyBpcyBmaWx0ZXJlZCBvdXQsIGFsbCBvZiBpdHMgY2hpbGRyZW4gd2lsbCBiZSBmaWx0ZXJlZCBvdXQgYXMgd2VsbCkuIFNldHRpbmcgdGhpcyBvcHRpb24gdG8gYHRydWVgIHdpbGwgY2F1c2UgZmlsdGVyaW5nIHRvIGJlIGRvbmUgZnJvbSBsZWFmIHJvd3MgdXAgKHdoaWNoIG1lYW5zIHBhcmVudCByb3dzIHdpbGwgYmUgaW5jbHVkZWQgc28gbG9uZyBhcyBvbmUgb2YgdGhlaXIgY2hpbGQgb3IgZ3JhbmQtY2hpbGQgcm93cyBpcyBhbHNvIGluY2x1ZGVkKS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI2ZpbHRlcmZyb21sZWFmcm93cylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBmaWx0ZXJGcm9tTGVhZlJvd3M/OiBib29sZWFuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgKipvbmNlKiogcGVyIHRhYmxlIGFuZCBzaG91bGQgcmV0dXJuIGEgKipuZXcgZnVuY3Rpb24qKiB3aGljaCB3aWxsIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZSB3aGVuIGl0J3MgZmlsdGVyZWQuXG4gICAqIC0gRm9yIHNlcnZlci1zaWRlIGZpbHRlcmluZywgdGhpcyBmdW5jdGlvbiBpcyB1bm5lY2Vzc2FyeSBhbmQgY2FuIGJlIGlnbm9yZWQgc2luY2UgdGhlIHNlcnZlciBzaG91bGQgYWxyZWFkeSByZXR1cm4gdGhlIGZpbHRlcmVkIHJvdyBtb2RlbC5cbiAgICogLSBGb3IgY2xpZW50LXNpZGUgZmlsdGVyaW5nLCB0aGlzIGZ1bmN0aW9uIGlzIHJlcXVpcmVkLiBBIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgcHJvdmlkZWQgdmlhIGFueSB0YWJsZSBhZGFwdGVyJ3MgYHsgZ2V0RmlsdGVyZWRSb3dNb2RlbCB9YCBleHBvcnQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNnZXRmaWx0ZXJlZHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIGdldEZpbHRlcmVkUm93TW9kZWw/OiAodGFibGU6IFRhYmxlPGFueT4pID0+ICgpID0+IFJvd01vZGVsPGFueT5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBgZ2V0RmlsdGVyZWRSb3dNb2RlbGAgZnJvbSBiZWluZyB1c2VkIHRvIGZpbHRlciBkYXRhLiBUaGlzIG1heSBiZSB1c2VmdWwgaWYgeW91ciB0YWJsZSBuZWVkcyB0byBkeW5hbWljYWxseSBzdXBwb3J0IGJvdGggY2xpZW50LXNpZGUgYW5kIHNlcnZlci1zaWRlIGZpbHRlcmluZy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI21hbnVhbGZpbHRlcmluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBtYW51YWxGaWx0ZXJpbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCBmaWx0ZXJpbmcgaXMgZG9uZSBmb3IgYWxsIHJvd3MgKG1heCBkZXB0aCBvZiAxMDApLCBubyBtYXR0ZXIgaWYgdGhleSBhcmUgcm9vdCBsZXZlbCBwYXJlbnQgcm93cyBvciB0aGUgY2hpbGQgbGVhZiByb3dzIG9mIGEgcGFyZW50IHJvdy4gU2V0dGluZyB0aGlzIG9wdGlvbiB0byBgMGAgd2lsbCBjYXVzZSBmaWx0ZXJpbmcgdG8gb25seSBiZSBhcHBsaWVkIHRvIHRoZSByb290IGxldmVsIHBhcmVudCByb3dzLCB3aXRoIGFsbCBzdWItcm93cyByZW1haW5pbmcgdW5maWx0ZXJlZC4gU2ltaWxhcmx5LCBzZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGAxYCB3aWxsIGNhdXNlIGZpbHRlcmluZyB0byBvbmx5IGJlIGFwcGxpZWQgdG8gY2hpbGQgbGVhZiByb3dzIDEgbGV2ZWwgZGVlcCwgYW5kIHNvIG9uLlxuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSB3YW50IGEgcm93J3MgZW50aXJlIGNoaWxkIGhpZXJhcmNoeSB0byBiZSB2aXNpYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlIGFwcGxpZWQgZmlsdGVyLlxuICAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI21heGxlYWZyb3dmaWx0ZXJkZXB0aClcbiAgICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoPzogbnVtYmVyXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVyRm5gIHdoZW4gYHN0YXRlLmNvbHVtbkZpbHRlcnNgIGNoYW5nZXMuIFRoaXMgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGludGVybmFsIHN0YXRlIG1hbmFnZW1lbnQsIHNvIHlvdSB3aWxsIG5lZWQgdG8gcGVyc2lzdCB0aGUgc3RhdGUgY2hhbmdlIGVpdGhlciBmdWxseSBvciBwYXJ0aWFsbHkgb3V0c2lkZSBvZiB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNvbmNvbHVtbmZpbHRlcnNjaGFuZ2UpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgb25Db2x1bW5GaWx0ZXJzQ2hhbmdlPzogT25DaGFuZ2VGbjxDb2x1bW5GaWx0ZXJzU3RhdGU+XG59XG5cbnR5cGUgUmVzb2x2ZWRGaWx0ZXJGbnMgPSBrZXlvZiBGaWx0ZXJGbnMgZXh0ZW5kcyBuZXZlclxuICA/IHtcbiAgICAgIGZpbHRlckZucz86IFJlY29yZDxzdHJpbmcsIEZpbHRlckZuPGFueT4+XG4gICAgfVxuICA6IHtcbiAgICAgIGZpbHRlckZuczogUmVjb3JkPGtleW9mIEZpbHRlckZucywgRmlsdGVyRm48YW55Pj5cbiAgICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uRmlsdGVyc09wdGlvbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPlxuICBleHRlbmRzIENvbHVtbkZpbHRlcnNPcHRpb25zQmFzZTxURGF0YT4sXG4gICAgUmVzb2x2ZWRGaWx0ZXJGbnMge31cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5GaWx0ZXJzSW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIF9nZXRGaWx0ZXJlZFJvd01vZGVsPzogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZSBhZnRlciAqKmNvbHVtbioqIGZpbHRlcmluZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjZ2V0ZmlsdGVyZWRyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1maWx0ZXJpbmcpXG4gICAqL1xuICBnZXRGaWx0ZXJlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBmb3IgdGhlIHRhYmxlIGJlZm9yZSBhbnkgKipjb2x1bW4qKiBmaWx0ZXJpbmcgaGFzIGJlZW4gYXBwbGllZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI2dldHByZWZpbHRlcmVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlICoqY29sdW1uRmlsdGVycyoqIHN0YXRlIHRvIGBpbml0aWFsU3RhdGUuY29sdW1uRmlsdGVyc2AsIG9yIGB0cnVlYCBjYW4gYmUgcGFzc2VkIHRvIGZvcmNlIGEgZGVmYXVsdCBibGFuayBzdGF0ZSByZXNldCB0byBgW11gLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1maWx0ZXJpbmcjcmVzZXRjb2x1bW5maWx0ZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIHJlc2V0Q29sdW1uRmlsdGVyczogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgKipnbG9iYWxGaWx0ZXIqKiBzdGF0ZSB0byBgaW5pdGlhbFN0YXRlLmdsb2JhbEZpbHRlcmAsIG9yIGB0cnVlYCBjYW4gYmUgcGFzc2VkIHRvIGZvcmNlIGEgZGVmYXVsdCBibGFuayBzdGF0ZSByZXNldCB0byBgdW5kZWZpbmVkYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tZmlsdGVyaW5nI3Jlc2V0Z2xvYmFsZmlsdGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIHJlc2V0R2xvYmFsRmlsdGVyOiAoZGVmYXVsdFN0YXRlPzogYm9vbGVhbikgPT4gdm9pZFxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBgc3RhdGUuY29sdW1uRmlsdGVyc2Agc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNzZXRjb2x1bW5maWx0ZXJzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLWZpbHRlcmluZylcbiAgICovXG4gIHNldENvbHVtbkZpbHRlcnM6ICh1cGRhdGVyOiBVcGRhdGVyPENvbHVtbkZpbHRlcnNTdGF0ZT4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgYHN0YXRlLmdsb2JhbEZpbHRlcmAgc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLWZpbHRlcmluZyNzZXRnbG9iYWxmaWx0ZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tZmlsdGVyaW5nKVxuICAgKi9cbiAgc2V0R2xvYmFsRmlsdGVyOiAodXBkYXRlcjogVXBkYXRlcjxhbnk+KSA9PiB2b2lkXG59XG5cbi8vXG5cbmV4cG9ydCBjb25zdCBDb2x1bW5GaWx0ZXJpbmc6IFRhYmxlRmVhdHVyZSA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogPFxuICAgIFREYXRhIGV4dGVuZHMgUm93RGF0YSxcbiAgPigpOiBDb2x1bW5GaWx0ZXJzQ29sdW1uRGVmPFREYXRhPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlckZuOiAnYXV0bycsXG4gICAgfVxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogQ29sdW1uRmlsdGVyc1RhYmxlU3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5GaWx0ZXJzOiBbXSxcbiAgICAgIC4uLnN0YXRlLFxuICAgIH1cbiAgfSxcblxuICBnZXREZWZhdWx0T3B0aW9uczogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiBDb2x1bW5GaWx0ZXJzT3B0aW9uczxURGF0YT4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbkZpbHRlcnNDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtbkZpbHRlcnMnLCB0YWJsZSksXG4gICAgICBmaWx0ZXJGcm9tTGVhZlJvd3M6IGZhbHNlLFxuICAgICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDAsXG4gICAgfSBhcyBDb2x1bW5GaWx0ZXJzT3B0aW9uczxURGF0YT5cbiAgfSxcblxuICBjcmVhdGVDb2x1bW46IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIGNvbHVtbjogQ29sdW1uPFREYXRhLCB1bmtub3duPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdXG5cbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3c/LmdldFZhbHVlKGNvbHVtbi5pZClcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbmNsdWRlc1N0cmluZ1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2VcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzXG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFsc1xuICAgIH1cbiAgICBjb2x1bW4uZ2V0RmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuKVxuICAgICAgICA/IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm5cbiAgICAgICAgOiBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuID09PSAnYXV0bydcbiAgICAgICAgICA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKVxuICAgICAgICAgIDogLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGFibGUub3B0aW9ucy5maWx0ZXJGbnM/Lltjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuIGFzIHN0cmluZ10gPz9cbiAgICAgICAgICAgIGZpbHRlckZuc1tjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuIGFzIEJ1aWx0SW5GaWx0ZXJGbl1cbiAgICB9XG4gICAgY29sdW1uLmdldENhbkZpbHRlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlciA/PyB0cnVlKSAmJlxuICAgICAgICAodGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzID8/IHRydWUpICYmXG4gICAgICAgICh0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMgPz8gdHJ1ZSkgJiZcbiAgICAgICAgISFjb2x1bW4uYWNjZXNzb3JGblxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbHVtbi5nZXRJc0ZpbHRlcmVkID0gKCkgPT4gY29sdW1uLmdldEZpbHRlckluZGV4KCkgPiAtMVxuXG4gICAgY29sdW1uLmdldEZpbHRlclZhbHVlID0gKCkgPT5cbiAgICAgIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycz8uZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk/LnZhbHVlXG5cbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PlxuICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzPy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpID8/IC0xXG5cbiAgICBjb2x1bW4uc2V0RmlsdGVyVmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKG9sZCA9PiB7XG4gICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKClcbiAgICAgICAgY29uc3QgcHJldmlvdXNGaWx0ZXIgPSBvbGQ/LmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpXG5cbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZShcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91c0ZpbHRlciA/IHByZXZpb3VzRmlsdGVyLnZhbHVlIDogdW5kZWZpbmVkXG4gICAgICAgIClcblxuICAgICAgICAvL1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiBhcyBGaWx0ZXJGbjxURGF0YT4sIG5ld0ZpbHRlciwgY29sdW1uKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gb2xkPy5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpID8/IFtdXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7IGlkOiBjb2x1bW4uaWQsIHZhbHVlOiBuZXdGaWx0ZXIgfVxuXG4gICAgICAgIGlmIChwcmV2aW91c0ZpbHRlcikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvbGQ/Lm1hcChkID0+IHtcbiAgICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGaWx0ZXJPYmpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZFxuICAgICAgICAgICAgfSkgPz8gW11cbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2xkPy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gWy4uLm9sZCwgbmV3RmlsdGVyT2JqXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuZXdGaWx0ZXJPYmpdXG4gICAgICB9KVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVSb3c6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHJvdzogUm93PFREYXRhPixcbiAgICBfdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9XG4gICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhID0ge31cbiAgfSxcblxuICBjcmVhdGVUYWJsZTogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4odGFibGU6IFRhYmxlPFREYXRhPik6IHZvaWQgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMgPSAodXBkYXRlcjogVXBkYXRlcjxDb2x1bW5GaWx0ZXJzU3RhdGU+KSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKClcblxuICAgICAgY29uc3QgdXBkYXRlRm4gPSAob2xkOiBDb2x1bW5GaWx0ZXJzU3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKT8uZmlsdGVyKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZClcblxuICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKClcblxuICAgICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZT8uKHVwZGF0ZUZuKVxuICAgIH1cblxuICAgIHRhYmxlLnJlc2V0Q29sdW1uRmlsdGVycyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKFxuICAgICAgICBkZWZhdWx0U3RhdGUgPyBbXSA6IHRhYmxlLmluaXRpYWxTdGF0ZT8uY29sdW1uRmlsdGVycyA/PyBbXVxuICAgICAgKVxuICAgIH1cblxuICAgIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKVxuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRmlsdGVyaW5nIHx8ICF0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcjxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICBmaWx0ZXJGbj86IEZpbHRlckZuPFREYXRhPixcbiAgdmFsdWU/OiBhbnksXG4gIGNvbHVtbj86IENvbHVtbjxURGF0YSwgdW5rbm93bj5cbikge1xuICByZXR1cm4gKFxuICAgIChmaWx0ZXJGbiAmJiBmaWx0ZXJGbi5hdXRvUmVtb3ZlXG4gICAgICA/IGZpbHRlckZuLmF1dG9SZW1vdmUodmFsdWUsIGNvbHVtbilcbiAgICAgIDogZmFsc2UpIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZSlcbiAgKVxufVxuIiwiaW1wb3J0IHsgQWdncmVnYXRpb25GbiB9IGZyb20gJy4vZmVhdHVyZXMvQ29sdW1uR3JvdXBpbmcnXG5pbXBvcnQgeyBpc051bWJlckFycmF5IH0gZnJvbSAnLi91dGlscydcblxuY29uc3Qgc3VtOiBBZ2dyZWdhdGlvbkZuPGFueT4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIC8vIEl0J3MgZmFzdGVyIHRvIGp1c3QgYWRkIHRoZSBhZ2dyZWdhdGlvbnMgdG9nZXRoZXIgaW5zdGVhZCBvZlxuICAvLyBwcm9jZXNzIGxlYWYgbm9kZXMgaW5kaXZpZHVhbGx5XG4gIHJldHVybiBjaGlsZFJvd3MucmVkdWNlKChzdW0sIG5leHQpID0+IHtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0LmdldFZhbHVlKGNvbHVtbklkKVxuICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHRWYWx1ZSA9PT0gJ251bWJlcicgPyBuZXh0VmFsdWUgOiAwKVxuICB9LCAwKVxufVxuXG5jb25zdCBtaW46IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZTxudW1iZXI+KGNvbHVtbklkKVxuXG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgICAgKG1pbiEgPiB2YWx1ZSB8fCAobWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKVxuICAgICkge1xuICAgICAgbWluID0gdmFsdWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG1pblxufVxuXG5jb25zdCBtYXg6IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1heDogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZTxudW1iZXI+KGNvbHVtbklkKVxuICAgIGlmIChcbiAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgIChtYXghIDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSlcbiAgICApIHtcbiAgICAgIG1heCA9IHZhbHVlXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBtYXhcbn1cblxuY29uc3QgZXh0ZW50OiBBZ2dyZWdhdGlvbkZuPGFueT4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW46IG51bWJlciB8IHVuZGVmaW5lZFxuICBsZXQgbWF4OiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlPG51bWJlcj4oY29sdW1uSWQpXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlXG4gICAgICAgIGlmIChtYXghIDwgdmFsdWUpIG1heCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBbbWluLCBtYXhdXG59XG5cbmNvbnN0IG1lYW46IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgbGV0IGNvdW50ID0gMFxuICBsZXQgc3VtID0gMFxuXG4gIGxlYWZSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBsZXQgdmFsdWUgPSByb3cuZ2V0VmFsdWU8bnVtYmVyPihjb2x1bW5JZClcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICArK2NvdW50LCAoc3VtICs9IHZhbHVlKVxuICAgIH1cbiAgfSlcblxuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudFxuXG4gIHJldHVyblxufVxuXG5jb25zdCBtZWRpYW46IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgaWYgKCFsZWFmUm93cy5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHZhbHVlcyA9IGxlYWZSb3dzLm1hcChyb3cgPT4gcm93LmdldFZhbHVlKGNvbHVtbklkKSlcbiAgaWYgKCFpc051bWJlckFycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF1cbiAgfVxuXG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpXG4gIGNvbnN0IG51bXMgPSB2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIHJldHVybiB2YWx1ZXMubGVuZ3RoICUgMiAhPT0gMCA/IG51bXNbbWlkXSA6IChudW1zW21pZCAtIDFdISArIG51bXNbbWlkXSEpIC8gMlxufVxuXG5jb25zdCB1bmlxdWU6IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnZhbHVlcygpKVxufVxuXG5jb25zdCB1bmlxdWVDb3VudDogQWdncmVnYXRpb25Gbjxhbnk+ID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICByZXR1cm4gbmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnNpemVcbn1cblxuY29uc3QgY291bnQ6IEFnZ3JlZ2F0aW9uRm48YW55PiA9IChfY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBsZWFmUm93cy5sZW5ndGhcbn1cblxuZXhwb3J0IGNvbnN0IGFnZ3JlZ2F0aW9uRm5zID0ge1xuICBzdW0sXG4gIG1pbixcbiAgbWF4LFxuICBleHRlbnQsXG4gIG1lYW4sXG4gIG1lZGlhbixcbiAgdW5pcXVlLFxuICB1bmlxdWVDb3VudCxcbiAgY291bnQsXG59XG5cbmV4cG9ydCB0eXBlIEJ1aWx0SW5BZ2dyZWdhdGlvbkZuID0ga2V5b2YgdHlwZW9mIGFnZ3JlZ2F0aW9uRm5zXG4iLCJpbXBvcnQgeyBSb3dNb2RlbCB9IGZyb20gJy4uJ1xuaW1wb3J0IHsgQnVpbHRJbkFnZ3JlZ2F0aW9uRm4sIGFnZ3JlZ2F0aW9uRm5zIH0gZnJvbSAnLi4vYWdncmVnYXRpb25GbnMnXG5pbXBvcnQge1xuICBBZ2dyZWdhdGlvbkZucyxcbiAgQ2VsbCxcbiAgQ29sdW1uLFxuICBDb2x1bW5EZWZUZW1wbGF0ZSxcbiAgT25DaGFuZ2VGbixcbiAgUm93LFxuICBSb3dEYXRhLFxuICBUYWJsZSxcbiAgVGFibGVGZWF0dXJlLFxuICBVcGRhdGVyLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGlzRnVuY3Rpb24sIG1ha2VTdGF0ZVVwZGF0ZXIgfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IHR5cGUgR3JvdXBpbmdTdGF0ZSA9IHN0cmluZ1tdXG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBpbmdUYWJsZVN0YXRlIHtcbiAgZ3JvdXBpbmc6IEdyb3VwaW5nU3RhdGVcbn1cblxuZXhwb3J0IHR5cGUgQWdncmVnYXRpb25GbjxURGF0YSBleHRlbmRzIFJvd0RhdGE+ID0gKFxuICBjb2x1bW5JZDogc3RyaW5nLFxuICBsZWFmUm93czogUm93PFREYXRhPltdLFxuICBjaGlsZFJvd3M6IFJvdzxURGF0YT5bXVxuKSA9PiBhbnlcblxuZXhwb3J0IHR5cGUgQ3VzdG9tQWdncmVnYXRpb25GbnMgPSBSZWNvcmQ8c3RyaW5nLCBBZ2dyZWdhdGlvbkZuPGFueT4+XG5cbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0aW9uRm5PcHRpb248VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiA9XG4gIHwgJ2F1dG8nXG4gIHwga2V5b2YgQWdncmVnYXRpb25GbnNcbiAgfCBCdWlsdEluQWdncmVnYXRpb25GblxuICB8IEFnZ3JlZ2F0aW9uRm48VERhdGE+XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBpbmdDb2x1bW5EZWY8VERhdGEgZXh0ZW5kcyBSb3dEYXRhLCBUVmFsdWU+IHtcbiAgLyoqXG4gICAqIFRoZSBjZWxsIHRvIGRpc3BsYXkgZWFjaCByb3cgZm9yIHRoZSBjb2x1bW4gaWYgdGhlIGNlbGwgaXMgYW4gYWdncmVnYXRlLiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSBwYXNzZWQgYSBwcm9wcyBvYmplY3Qgd2l0aCB0aGUgY29udGV4dCBvZiB0aGUgY2VsbCBhbmQgc2hvdWxkIHJldHVybiB0aGUgcHJvcGVydHkgdHlwZSBmb3IgeW91ciBhZGFwdGVyICh0aGUgZXhhY3QgdHlwZSBkZXBlbmRzIG9uIHRoZSBhZGFwdGVyIGJlaW5nIHVzZWQpLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2FnZ3JlZ2F0ZWRjZWxsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBhZ2dyZWdhdGVkQ2VsbD86IENvbHVtbkRlZlRlbXBsYXRlPFxuICAgIFJldHVyblR5cGU8Q2VsbDxURGF0YSwgVFZhbHVlPlsnZ2V0Q29udGV4dCddPlxuICA+XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgYWdncmVnYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjYWdncmVnYXRpb25mbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgYWdncmVnYXRpb25Gbj86IEFnZ3JlZ2F0aW9uRm5PcHRpb248VERhdGE+XG4gIC8qKlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIGdyb3VwaW5nIGZvciB0aGlzIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNlbmFibGVncm91cGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZW5hYmxlR3JvdXBpbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgdmFsdWUgdG8gYmUgdXNlZCBmb3IgZ3JvdXBpbmcgcm93cyBvbiB0aGlzIGNvbHVtbi4gSWYgdGhpcyBvcHRpb24gaXMgbm90IHNwZWNpZmllZCwgdGhlIHZhbHVlIGRlcml2ZWQgZnJvbSBgYWNjZXNzb3JLZXlgIC8gYGFjY2Vzc29yRm5gIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2dldGdyb3VwaW5ndmFsdWUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdldEdyb3VwaW5nVmFsdWU/OiAocm93OiBURGF0YSkgPT4gYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBpbmdDb2x1bW48VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXRhZ2dyZWdhdGlvbmZuKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBnZXRBZ2dyZWdhdGlvbkZuOiAoKSA9PiBBZ2dyZWdhdGlvbkZuPFREYXRhPiB8IHVuZGVmaW5lZFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXV0b21hdGljYWxseSBpbmZlcnJlZCBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXRhdXRvYWdncmVnYXRpb25mbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0QXV0b0FnZ3JlZ2F0aW9uRm46ICgpID0+IEFnZ3JlZ2F0aW9uRm48VERhdGE+IHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb2x1bW4gY2FuIGJlIGdyb3VwZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZ2V0Y2FuZ3JvdXApXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdldENhbkdyb3VwOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGluIHRoZSBncm91cGluZyBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXRncm91cGVkaW5kZXgpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdldEdyb3VwZWRJbmRleDogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IGdyb3VwZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZ2V0aXNncm91cGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBnZXRJc0dyb3VwZWQ6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRvZ2dsZXMgdGhlIGdyb3VwaW5nIHN0YXRlIG9mIHRoZSBjb2x1bW4uIFRoaXMgaXMgdXNlZnVsIGZvciBwYXNzaW5nIHRvIHRoZSBgb25DbGlja2AgcHJvcCBvZiBhIGJ1dHRvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXR0b2dnbGVncm91cGluZ2hhbmRsZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdldFRvZ2dsZUdyb3VwaW5nSGFuZGxlcjogKCkgPT4gKCkgPT4gdm9pZFxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZ3JvdXBpbmcgc3RhdGUgb2YgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyN0b2dnbGVncm91cGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgdG9nZ2xlR3JvdXBpbmc6ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ1JvdyB7XG4gIF9ncm91cGluZ1ZhbHVlc0NhY2hlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBncm91cGluZyB2YWx1ZSBmb3IgYW55IHJvdyBhbmQgY29sdW1uIChpbmNsdWRpbmcgbGVhZiByb3dzKS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXRncm91cGluZ3ZhbHVlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBnZXRHcm91cGluZ1ZhbHVlOiAoY29sdW1uSWQ6IHN0cmluZykgPT4gdW5rbm93blxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcm93IGlzIGN1cnJlbnRseSBncm91cGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2dldGlzZ3JvdXBlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0SXNHcm91cGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHJvdyBpcyBncm91cGVkLCB0aGlzIGlzIHRoZSBpZCBvZiB0aGUgY29sdW1uIHRoYXQgdGhpcyByb3cgaXMgZ3JvdXBlZCBieS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNncm91cGluZ2NvbHVtbmlkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBncm91cGluZ0NvbHVtbklkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBJZiB0aGlzIHJvdyBpcyBncm91cGVkLCB0aGlzIGlzIHRoZSB1bmlxdWUvc2hhcmVkIHZhbHVlIGZvciB0aGUgYGdyb3VwaW5nQ29sdW1uSWRgIGZvciBhbGwgb2YgdGhlIHJvd3MgaW4gdGhpcyBncm91cC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNncm91cGluZ3ZhbHVlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBncm91cGluZ1ZhbHVlPzogdW5rbm93blxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwaW5nQ2VsbCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjZWxsIGlzIGN1cnJlbnRseSBhZ2dyZWdhdGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2dldGlzYWdncmVnYXRlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0SXNBZ2dyZWdhdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjZWxsIGlzIGN1cnJlbnRseSBncm91cGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2dldGlzZ3JvdXBlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0SXNHcm91cGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjZWxsIGlzIGN1cnJlbnRseSBhIHBsYWNlaG9sZGVyIGNlbGwuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZ2V0aXNwbGFjZWhvbGRlcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0SXNQbGFjZWhvbGRlcjogKCkgPT4gYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbkRlZmF1bHRPcHRpb25zIHtcbiAgZW5hYmxlR3JvdXBpbmc6IGJvb2xlYW5cbiAgb25Hcm91cGluZ0NoYW5nZTogT25DaGFuZ2VGbjxHcm91cGluZ1N0YXRlPlxufVxuXG5pbnRlcmZhY2UgR3JvdXBpbmdPcHRpb25zQmFzZSB7XG4gIC8qKlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIGdyb3VwaW5nIGZvciB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZW5hYmxlZ3JvdXBpbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGVuYWJsZUdyb3VwaW5nPzogYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93IG1vZGVsIGFmdGVyIGdyb3VwaW5nIGhhcyB0YWtlbiBwbGFjZSwgYnV0IG5vIGZ1cnRoZXIuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZ2V0Z3JvdXBlZHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBnZXRHcm91cGVkUm93TW9kZWw/OiAodGFibGU6IFRhYmxlPGFueT4pID0+ICgpID0+IFJvd01vZGVsPGFueT5cbiAgLyoqXG4gICAqIEdyb3VwaW5nIGNvbHVtbnMgYXJlIGF1dG9tYXRpY2FsbHkgcmVvcmRlcmVkIGJ5IGRlZmF1bHQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW5zIGxpc3QuIElmIHlvdSB3b3VsZCByYXRoZXIgcmVtb3ZlIHRoZW0gb3IgbGVhdmUgdGhlbSBhcy1pcywgc2V0IHRoZSBhcHByb3ByaWF0ZSBtb2RlIGhlcmUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjZ3JvdXBlZGNvbHVtbm1vZGUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdyb3VwZWRDb2x1bW5Nb2RlPzogZmFsc2UgfCAncmVvcmRlcicgfCAncmVtb3ZlJ1xuICAvKipcbiAgICogRW5hYmxlcyBtYW51YWwgZ3JvdXBpbmcuIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSB0YWJsZSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGdyb3VwIHJvd3MgdXNpbmcgYGdldEdyb3VwZWRSb3dNb2RlbCgpYCBhbmQgaW5zdGVhZCB3aWxsIGV4cGVjdCB5b3UgdG8gbWFudWFsbHkgZ3JvdXAgdGhlIHJvd3MgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byB0aGUgdGFibGUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhcmUgZG9pbmcgc2VydmVyLXNpZGUgZ3JvdXBpbmcgYW5kIGFnZ3JlZ2F0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI21hbnVhbGdyb3VwaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBtYW51YWxHcm91cGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIElmIHRoaXMgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGdyb3VwaW5nIHN0YXRlIGNoYW5nZXMgYW5kIHlvdSB3aWxsIGJlIGV4cGVjdGVkIHRvIG1hbmFnZSB0aGUgc3RhdGUgeW91cnNlbGYuIFlvdSBjYW4gcGFzcyB0aGUgbWFuYWdlZCBzdGF0ZSBiYWNrIHRvIHRoZSB0YWJsZSB2aWEgdGhlIGB0YWJsZU9wdGlvbnMuc3RhdGUuZ3JvdXBpbmdgIG9wdGlvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNvbmdyb3VwaW5nY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBvbkdyb3VwaW5nQ2hhbmdlPzogT25DaGFuZ2VGbjxHcm91cGluZ1N0YXRlPlxufVxuXG50eXBlIFJlc29sdmVkQWdncmVnYXRpb25GbnMgPSBrZXlvZiBBZ2dyZWdhdGlvbkZucyBleHRlbmRzIG5ldmVyXG4gID8ge1xuICAgICAgYWdncmVnYXRpb25GbnM/OiBSZWNvcmQ8c3RyaW5nLCBBZ2dyZWdhdGlvbkZuPGFueT4+XG4gICAgfVxuICA6IHtcbiAgICAgIGFnZ3JlZ2F0aW9uRm5zOiBSZWNvcmQ8a2V5b2YgQWdncmVnYXRpb25GbnMsIEFnZ3JlZ2F0aW9uRm48YW55Pj5cbiAgICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JvdXBpbmdPcHRpb25zXG4gIGV4dGVuZHMgR3JvdXBpbmdPcHRpb25zQmFzZSxcbiAgICBSZXNvbHZlZEFnZ3JlZ2F0aW9uRm5zIHt9XG5cbmV4cG9ydCB0eXBlIEdyb3VwaW5nQ29sdW1uTW9kZSA9IGZhbHNlIHwgJ3Jlb3JkZXInIHwgJ3JlbW92ZSdcblxuZXhwb3J0IGludGVyZmFjZSBHcm91cGluZ0luc3RhbmNlPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBfZ2V0R3JvdXBlZFJvd01vZGVsPzogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZSBhZnRlciBncm91cGluZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI2dldGdyb3VwZWRyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgZ2V0R3JvdXBlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBmb3IgdGhlIHRhYmxlIGJlZm9yZSBhbnkgZ3JvdXBpbmcgaGFzIGJlZW4gYXBwbGllZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9ncm91cGluZyNnZXRwcmVncm91cGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9ncm91cGluZylcbiAgICovXG4gIGdldFByZUdyb3VwZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlICoqZ3JvdXBpbmcqKiBzdGF0ZSB0byBgaW5pdGlhbFN0YXRlLmdyb3VwaW5nYCwgb3IgYHRydWVgIGNhbiBiZSBwYXNzZWQgdG8gZm9yY2UgYSBkZWZhdWx0IGJsYW5rIHN0YXRlIHJlc2V0IHRvIGBbXWAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ3JvdXBpbmcjcmVzZXRncm91cGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dyb3VwaW5nKVxuICAgKi9cbiAgcmVzZXRHcm91cGluZzogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGdyb3VwaW5nIHN0YXRlIG9mIHRoZSB0YWJsZSB2aWEgYW4gdXBkYXRlIGZ1bmN0aW9uIG9yIHZhbHVlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dyb3VwaW5nI3NldGdyb3VwaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ3JvdXBpbmcpXG4gICAqL1xuICBzZXRHcm91cGluZzogKHVwZGF0ZXI6IFVwZGF0ZXI8R3JvdXBpbmdTdGF0ZT4pID0+IHZvaWRcbn1cblxuLy9cblxuZXhwb3J0IGNvbnN0IENvbHVtbkdyb3VwaW5nOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KCk6IEdyb3VwaW5nQ29sdW1uRGVmPFxuICAgIFREYXRhLFxuICAgIHVua25vd25cbiAgPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFnZ3JlZ2F0ZWRDZWxsOiBwcm9wcyA9PiAocHJvcHMuZ2V0VmFsdWUoKSBhcyBhbnkpPy50b1N0cmluZz8uKCkgPz8gbnVsbCxcbiAgICAgIGFnZ3JlZ2F0aW9uRm46ICdhdXRvJyxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAoc3RhdGUpOiBHcm91cGluZ1RhYmxlU3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBncm91cGluZzogW10sXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogR3JvdXBpbmdPcHRpb25zID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXG4gICAgICBncm91cGVkQ29sdW1uTW9kZTogJ3Jlb3JkZXInLFxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVDb2x1bW46IDxURGF0YSBleHRlbmRzIFJvd0RhdGEsIFRWYWx1ZT4oXG4gICAgY29sdW1uOiBDb2x1bW48VERhdGEsIFRWYWx1ZT4sXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBncm91cGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgaWYgKG9sZD8uaW5jbHVkZXMoY29sdW1uLmlkKSkge1xuICAgICAgICAgIHJldHVybiBvbGQuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uLmlkKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsuLi4ob2xkID8/IFtdKSwgY29sdW1uLmlkXVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0Q2FuR3JvdXAgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHcm91cGluZyA/PyB0cnVlKSAmJlxuICAgICAgICAodGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZyA/PyB0cnVlKSAmJlxuICAgICAgICAoISFjb2x1bW4uYWNjZXNzb3JGbiB8fCAhIWNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0SXNHcm91cGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmc/LmluY2x1ZGVzKGNvbHVtbi5pZClcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0R3JvdXBlZEluZGV4ID0gKCkgPT4gdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZz8uaW5kZXhPZihjb2x1bW4uaWQpXG5cbiAgICBjb2x1bW4uZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuR3JvdXAgPSBjb2x1bW4uZ2V0Q2FuR3JvdXAoKVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkdyb3VwKSByZXR1cm5cbiAgICAgICAgY29sdW1uLnRvZ2dsZUdyb3VwaW5nKClcbiAgICAgIH1cbiAgICB9XG4gICAgY29sdW1uLmdldEF1dG9BZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93Py5nZXRWYWx1ZShjb2x1bW4uaWQpXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW1cbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICByZXR1cm4gYWdncmVnYXRpb25GbnMuZXh0ZW50XG4gICAgICB9XG4gICAgfVxuICAgIGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuKVxuICAgICAgICA/IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GblxuICAgICAgICA6IGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbiA9PT0gJ2F1dG8nXG4gICAgICAgICAgPyBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4oKVxuICAgICAgICAgIDogdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucz8uW1xuICAgICAgICAgICAgICBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gYXMgc3RyaW5nXG4gICAgICAgICAgICBdID8/XG4gICAgICAgICAgICBhZ2dyZWdhdGlvbkZuc1tcbiAgICAgICAgICAgICAgY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuIGFzIEJ1aWx0SW5BZ2dyZWdhdGlvbkZuXG4gICAgICAgICAgICBdXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuc2V0R3JvdXBpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Hcm91cGluZ0NoYW5nZT8uKHVwZGF0ZXIpXG5cbiAgICB0YWJsZS5yZXNldEdyb3VwaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKGRlZmF1bHRTdGF0ZSA/IFtdIDogdGFibGUuaW5pdGlhbFN0YXRlPy5ncm91cGluZyA/PyBbXSlcbiAgICB9XG5cbiAgICB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKClcbiAgICB0YWJsZS5nZXRHcm91cGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0R3JvdXBlZFJvd01vZGVsKHRhYmxlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxHcm91cGluZyB8fCAhdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVSb3c6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHJvdzogUm93PFREYXRhPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIHJvdy5nZXRJc0dyb3VwZWQgPSAoKSA9PiAhIXJvdy5ncm91cGluZ0NvbHVtbklkXG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpXG5cbiAgICAgIGlmICghY29sdW1uPy5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKVxuICAgICAgfVxuXG4gICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRHcm91cGluZ1ZhbHVlKFxuICAgICAgICByb3cub3JpZ2luYWxcbiAgICAgIClcblxuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF1cbiAgICB9XG4gICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlID0ge31cbiAgfSxcblxuICBjcmVhdGVDZWxsOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhLCBUVmFsdWU+KFxuICAgIGNlbGw6IENlbGw8VERhdGEsIFRWYWx1ZT4sXG4gICAgY29sdW1uOiBDb2x1bW48VERhdGEsIFRWYWx1ZT4sXG4gICAgcm93OiBSb3c8VERhdGE+LFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogdm9pZCA9PiB7XG4gICAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PlxuICAgICAgY2VsbC5nZXRWYWx1ZSgpID8/IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZVxuXG4gICAgY2VsbC5nZXRJc0dyb3VwZWQgPSAoKSA9PlxuICAgICAgY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWRcbiAgICBjZWxsLmdldElzUGxhY2Vob2xkZXIgPSAoKSA9PiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiBjb2x1bW4uZ2V0SXNHcm91cGVkKClcbiAgICBjZWxsLmdldElzQWdncmVnYXRlZCA9ICgpID0+XG4gICAgICAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISFyb3cuc3ViUm93cz8ubGVuZ3RoXG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRlckNvbHVtbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgbGVhZkNvbHVtbnM6IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXSxcbiAgZ3JvdXBpbmc6IHN0cmluZ1tdLFxuICBncm91cGVkQ29sdW1uTW9kZT86IEdyb3VwaW5nQ29sdW1uTW9kZVxuKSB7XG4gIGlmICghZ3JvdXBpbmc/Lmxlbmd0aCB8fCAhZ3JvdXBlZENvbHVtbk1vZGUpIHtcbiAgICByZXR1cm4gbGVhZkNvbHVtbnNcbiAgfVxuXG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihcbiAgICBjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZClcbiAgKVxuXG4gIGlmIChncm91cGVkQ29sdW1uTW9kZSA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gbm9uR3JvdXBpbmdDb2x1bW5zXG4gIH1cblxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZ1xuICAgIC5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpISlcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG5cbiAgcmV0dXJuIFsuLi5ncm91cGluZ0NvbHVtbnMsIC4uLm5vbkdyb3VwaW5nQ29sdW1uc11cbn1cbiIsImltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmltcG9ydCB7XG4gIENvbHVtbixcbiAgT25DaGFuZ2VGbixcbiAgUm93RGF0YSxcbiAgVGFibGUsXG4gIFRhYmxlRmVhdHVyZSxcbiAgVXBkYXRlcixcbn0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCB7IG9yZGVyQ29sdW1ucyB9IGZyb20gJy4vQ29sdW1uR3JvdXBpbmcnXG5pbXBvcnQgeyBDb2x1bW5QaW5uaW5nUG9zaXRpb24sIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnMgfSBmcm9tICcuLidcblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5PcmRlclRhYmxlU3RhdGUge1xuICBjb2x1bW5PcmRlcjogQ29sdW1uT3JkZXJTdGF0ZVxufVxuXG5leHBvcnQgdHlwZSBDb2x1bW5PcmRlclN0YXRlID0gc3RyaW5nW11cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5PcmRlck9wdGlvbnMge1xuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBgdXBkYXRlckZuYCB3aGVuIGBzdGF0ZS5jb2x1bW5PcmRlcmAgY2hhbmdlcy4gVGhpcyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW50ZXJuYWwgc3RhdGUgbWFuYWdlbWVudCwgc28geW91IHdpbGwgbmVlZCB0byBwZXJzaXN0IHRoZSBzdGF0ZSBjaGFuZ2UgZWl0aGVyIGZ1bGx5IG9yIHBhcnRpYWxseSBvdXRzaWRlIG9mIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tb3JkZXJpbmcjb25jb2x1bW5vcmRlcmNoYW5nZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1vcmRlcmluZylcbiAgICovXG4gIG9uQ29sdW1uT3JkZXJDaGFuZ2U/OiBPbkNoYW5nZUZuPENvbHVtbk9yZGVyU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uT3JkZXJDb2x1bW4ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiBpbiB0aGUgb3JkZXIgb2YgdGhlIHZpc2libGUgY29sdW1ucy4gT3B0aW9uYWxseSBwYXNzIGEgYHBvc2l0aW9uYCBwYXJhbWV0ZXIgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGluIGEgc3ViLXNlY3Rpb24gb2YgdGhlIHRhYmxlXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLW9yZGVyaW5nI2dldGluZGV4KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLW9yZGVyaW5nKVxuICAgKi9cbiAgZ2V0SW5kZXg6IChwb3NpdGlvbj86IENvbHVtblBpbm5pbmdQb3NpdGlvbiB8ICdjZW50ZXInKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb2x1bW4gaXMgdGhlIGZpcnN0IGNvbHVtbiBpbiB0aGUgb3JkZXIgb2YgdGhlIHZpc2libGUgY29sdW1ucy4gT3B0aW9uYWxseSBwYXNzIGEgYHBvc2l0aW9uYCBwYXJhbWV0ZXIgdG8gY2hlY2sgaWYgdGhlIGNvbHVtbiBpcyB0aGUgZmlyc3QgaW4gYSBzdWItc2VjdGlvbiBvZiB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLW9yZGVyaW5nI2dldGlzZmlyc3Rjb2x1bW4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tb3JkZXJpbmcpXG4gICAqL1xuICBnZXRJc0ZpcnN0Q29sdW1uOiAocG9zaXRpb24/OiBDb2x1bW5QaW5uaW5nUG9zaXRpb24gfCAnY2VudGVyJykgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbHVtbiBpcyB0aGUgbGFzdCBjb2x1bW4gaW4gdGhlIG9yZGVyIG9mIHRoZSB2aXNpYmxlIGNvbHVtbnMuIE9wdGlvbmFsbHkgcGFzcyBhIGBwb3NpdGlvbmAgcGFyYW1ldGVyIHRvIGNoZWNrIGlmIHRoZSBjb2x1bW4gaXMgdGhlIGxhc3QgaW4gYSBzdWItc2VjdGlvbiBvZiB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLW9yZGVyaW5nI2dldGlzbGFzdGNvbHVtbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1vcmRlcmluZylcbiAgICovXG4gIGdldElzTGFzdENvbHVtbjogKHBvc2l0aW9uPzogQ29sdW1uUGlubmluZ1Bvc2l0aW9uIHwgJ2NlbnRlcicpID0+IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5PcmRlckRlZmF1bHRPcHRpb25zIHtcbiAgb25Db2x1bW5PcmRlckNoYW5nZTogT25DaGFuZ2VGbjxDb2x1bW5PcmRlclN0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbk9yZGVySW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIF9nZXRPcmRlckNvbHVtbnNGbjogKCkgPT4gKFxuICAgIGNvbHVtbnM6IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICApID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmVzZXRzIHRoZSAqKmNvbHVtbk9yZGVyKiogc3RhdGUgdG8gYGluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlcmAsIG9yIGB0cnVlYCBjYW4gYmUgcGFzc2VkIHRvIGZvcmNlIGEgZGVmYXVsdCBibGFuayBzdGF0ZSByZXNldCB0byBgW11gLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1vcmRlcmluZyNyZXNldGNvbHVtbm9yZGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLW9yZGVyaW5nKVxuICAgKi9cbiAgcmVzZXRDb2x1bW5PcmRlcjogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgYHN0YXRlLmNvbHVtbk9yZGVyYCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tb3JkZXJpbmcjc2V0Y29sdW1ub3JkZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tb3JkZXJpbmcpXG4gICAqL1xuICBzZXRDb2x1bW5PcmRlcjogKHVwZGF0ZXI6IFVwZGF0ZXI8Q29sdW1uT3JkZXJTdGF0ZT4pID0+IHZvaWRcbn1cblxuLy9cblxuZXhwb3J0IGNvbnN0IENvbHVtbk9yZGVyaW5nOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogQ29sdW1uT3JkZXJUYWJsZVN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uT3JkZXI6IFtdLFxuICAgICAgLi4uc3RhdGUsXG4gICAgfVxuICB9LFxuXG4gIGdldERlZmF1bHRPcHRpb25zOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IENvbHVtbk9yZGVyRGVmYXVsdE9wdGlvbnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtbk9yZGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5PcmRlcicsIHRhYmxlKSxcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlQ29sdW1uOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgICBjb2x1bW46IENvbHVtbjxURGF0YSwgdW5rbm93bj4sXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICBjb2x1bW4uZ2V0SW5kZXggPSBtZW1vKFxuICAgICAgcG9zaXRpb24gPT4gW19nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKV0sXG4gICAgICBjb2x1bW5zID0+IGNvbHVtbnMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0SW5kZXgnKVxuICAgIClcbiAgICBjb2x1bW4uZ2V0SXNGaXJzdENvbHVtbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbilcbiAgICAgIHJldHVybiBjb2x1bW5zWzBdPy5pZCA9PT0gY29sdW1uLmlkXG4gICAgfVxuICAgIGNvbHVtbi5nZXRJc0xhc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5zID0gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pXG4gICAgICByZXR1cm4gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdPy5pZCA9PT0gY29sdW1uLmlkXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uT3JkZXIgPSB1cGRhdGVyID0+XG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2U/Lih1cGRhdGVyKVxuICAgIHRhYmxlLnJlc2V0Q29sdW1uT3JkZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uT3JkZXIoXG4gICAgICAgIGRlZmF1bHRTdGF0ZSA/IFtdIDogdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyID8/IFtdXG4gICAgICApXG4gICAgfVxuICAgIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbiA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uT3JkZXIsXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsXG4gICAgICAgIHRhYmxlLm9wdGlvbnMuZ3JvdXBlZENvbHVtbk1vZGUsXG4gICAgICBdLFxuICAgICAgKGNvbHVtbk9yZGVyLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpID0+XG4gICAgICAgIChjb2x1bW5zOiBDb2x1bW48VERhdGEsIHVua25vd24+W10pID0+IHtcbiAgICAgICAgICAvLyBTb3J0IGdyb3VwZWQgY29sdW1ucyB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbHVtbiBsaXN0XG4gICAgICAgICAgLy8gYmVmb3JlIHRoZSBoZWFkZXJzIGFyZSBidWlsdFxuICAgICAgICAgIGxldCBvcmRlcmVkQ29sdW1uczogQ29sdW1uPFREYXRhLCB1bmtub3duPltdID0gW11cblxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgICAgICAgaWYgKCFjb2x1bW5PcmRlcj8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IGNvbHVtbnNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uT3JkZXJDb3B5ID0gWy4uLmNvbHVtbk9yZGVyXVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmRlciwgbWFrZSBhIGNvcHkgb2YgdGhlIGNvbHVtbnNcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnNDb3B5ID0gWy4uLmNvbHVtbnNdXG5cbiAgICAgICAgICAgIC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuICAgICAgICAgICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbHVtbklkID0gY29sdW1uT3JkZXJDb3B5LnNoaWZ0KClcbiAgICAgICAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGNvbHVtbnNDb3B5LmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICBkID0+IGQuaWQgPT09IHRhcmdldENvbHVtbklkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdISlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBbLi4ub3JkZXJlZENvbHVtbnMsIC4uLmNvbHVtbnNDb3B5XVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMob3JkZXJlZENvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSlcbiAgICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ19nZXRPcmRlckNvbHVtbnNGbicpXG4gICAgKVxuICB9LFxufVxuIiwiaW1wb3J0IHtcbiAgT25DaGFuZ2VGbixcbiAgVXBkYXRlcixcbiAgVGFibGUsXG4gIENvbHVtbixcbiAgUm93LFxuICBDZWxsLFxuICBSb3dEYXRhLFxuICBUYWJsZUZlYXR1cmUsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0TWVtb09wdGlvbnMsIG1ha2VTdGF0ZVVwZGF0ZXIsIG1lbW8gfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IHR5cGUgQ29sdW1uUGlubmluZ1Bvc2l0aW9uID0gZmFsc2UgfCAnbGVmdCcgfCAncmlnaHQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uUGlubmluZ1N0YXRlIHtcbiAgbGVmdD86IHN0cmluZ1tdXG4gIHJpZ2h0Pzogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5QaW5uaW5nVGFibGVTdGF0ZSB7XG4gIGNvbHVtblBpbm5pbmc6IENvbHVtblBpbm5pbmdTdGF0ZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtblBpbm5pbmdPcHRpb25zIHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgY29sdW1uIHBpbm5pbmcgZm9yIHRoZSB0YWJsZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1waW5uaW5nI2VuYWJsZWNvbHVtbnBpbm5pbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGVuYWJsZUNvbHVtblBpbm5pbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVuYWJsZUNvbHVtblBpbm5pbmdgIG9yIGBlbmFibGVSb3dQaW5uaW5nYCBpbnN0ZWFkLlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIGFsbCBwaW5uaW5nIGZvciB0aGUgdGFibGUuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNlbmFibGVwaW5uaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBlbmFibGVQaW5uaW5nPzogYm9vbGVhblxuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBgdXBkYXRlckZuYCB3aGVuIGBzdGF0ZS5jb2x1bW5QaW5uaW5nYCBjaGFuZ2VzLiBUaGlzIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbnRlcm5hbCBzdGF0ZSBtYW5hZ2VtZW50LCBzbyB5b3Ugd2lsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGBzdGF0ZS5jb2x1bW5QaW5uaW5nYCBmcm9tIHlvdXIgb3duIG1hbmFnZWQgc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjb25jb2x1bW5waW5uaW5nY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvb25jb2x1bW5waW5uaW5nY2hhbmdlKVxuICAgKi9cbiAgb25Db2x1bW5QaW5uaW5nQ2hhbmdlPzogT25DaGFuZ2VGbjxDb2x1bW5QaW5uaW5nU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uUGlubmluZ0RlZmF1bHRPcHRpb25zIHtcbiAgb25Db2x1bW5QaW5uaW5nQ2hhbmdlOiBPbkNoYW5nZUZuPENvbHVtblBpbm5pbmdTdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5QaW5uaW5nQ29sdW1uRGVmIHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgY29sdW1uIHBpbm5pbmcgZm9yIHRoaXMgY29sdW1uLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjZW5hYmxlcGlubmluZy0xKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBlbmFibGVQaW5uaW5nPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtblBpbm5pbmdDb2x1bW4ge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29sdW1uIGNhbiBiZSBwaW5uZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjZ2V0Y2FucGluKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBnZXRDYW5QaW46ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpbm5lZCBwb3NpdGlvbiBvZiB0aGUgY29sdW1uLiAoYCdsZWZ0J2AsIGAncmlnaHQnYCBvciBgZmFsc2VgKVxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1waW5uaW5nI2dldGlzcGlubmVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBnZXRJc1Bpbm5lZDogKCkgPT4gQ29sdW1uUGlubmluZ1Bvc2l0aW9uXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1lcmljIHBpbm5lZCBpbmRleCBvZiB0aGUgY29sdW1uIHdpdGhpbiBhIHBpbm5lZCBjb2x1bW4gZ3JvdXAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjZ2V0cGlubmVkaW5kZXgpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldFBpbm5lZEluZGV4OiAoKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFBpbnMgYSBjb2x1bW4gdG8gdGhlIGAnbGVmdCdgIG9yIGAncmlnaHQnYCwgb3IgdW5waW5zIHRoZSBjb2x1bW4gdG8gdGhlIGNlbnRlciBpZiBgZmFsc2VgIGlzIHBhc3NlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNwaW4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIHBpbjogKHBvc2l0aW9uOiBDb2x1bW5QaW5uaW5nUG9zaXRpb24pID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5QaW5uaW5nUm93PFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogUmV0dXJucyBhbGwgY2VudGVyIHBpbm5lZCAodW5waW5uZWQpIGxlYWYgY2VsbHMgaW4gdGhlIHJvdy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNnZXRjZW50ZXJ2aXNpYmxlY2VsbHMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldENlbnRlclZpc2libGVDZWxsczogKCkgPT4gQ2VsbDxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgbGVmdCBwaW5uZWQgbGVhZiBjZWxscyBpbiB0aGUgcm93LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1waW5uaW5nI2dldGxlZnR2aXNpYmxlY2VsbHMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldExlZnRWaXNpYmxlQ2VsbHM6ICgpID0+IENlbGw8VERhdGEsIHVua25vd24+W11cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJpZ2h0IHBpbm5lZCBsZWFmIGNlbGxzIGluIHRoZSByb3cuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjZ2V0cmlnaHR2aXNpYmxlY2VsbHMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldFJpZ2h0VmlzaWJsZUNlbGxzOiAoKSA9PiBDZWxsPFREYXRhLCB1bmtub3duPltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uUGlubmluZ0luc3RhbmNlPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogUmV0dXJucyBhbGwgY2VudGVyIHBpbm5lZCAodW5waW5uZWQpIGxlYWYgY29sdW1ucy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNnZXRjZW50ZXJsZWFmY29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1waW5uaW5nKVxuICAgKi9cbiAgZ2V0Q2VudGVyTGVhZkNvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbnkgY29sdW1ucyBhcmUgcGlubmVkLiBPcHRpb25hbGx5IHNwZWNpZnkgdG8gb25seSBjaGVjayBmb3IgcGlubmVkIGNvbHVtbnMgaW4gZWl0aGVyIHRoZSBgbGVmdGAgb3IgYHJpZ2h0YCBwb3NpdGlvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNnZXRpc3NvbWVjb2x1bW5zcGlubmVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBnZXRJc1NvbWVDb2x1bW5zUGlubmVkOiAocG9zaXRpb24/OiBDb2x1bW5QaW5uaW5nUG9zaXRpb24pID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGxlZnQgcGlubmVkIGxlYWYgY29sdW1ucy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNnZXRsZWZ0bGVhZmNvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldExlZnRMZWFmQ29sdW1uczogKCkgPT4gQ29sdW1uPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCByaWdodCBwaW5uZWQgbGVhZiBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1waW5uaW5nI2dldHJpZ2h0bGVhZmNvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tcGlubmluZylcbiAgICovXG4gIGdldFJpZ2h0TGVhZkNvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmVzZXRzIHRoZSAqKmNvbHVtblBpbm5pbmcqKiBzdGF0ZSB0byBgaW5pdGlhbFN0YXRlLmNvbHVtblBpbm5pbmdgLCBvciBgdHJ1ZWAgY2FuIGJlIHBhc3NlZCB0byBmb3JjZSBhIGRlZmF1bHQgYmxhbmsgc3RhdGUgcmVzZXQgdG8gYHsgbGVmdDogW10sIHJpZ2h0OiBbXSwgfWAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXBpbm5pbmcjcmVzZXRjb2x1bW5waW5uaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICByZXNldENvbHVtblBpbm5pbmc6IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgdGhlIGBzdGF0ZS5jb2x1bW5QaW5uaW5nYCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tcGlubmluZyNzZXRjb2x1bW5waW5uaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXBpbm5pbmcpXG4gICAqL1xuICBzZXRDb2x1bW5QaW5uaW5nOiAodXBkYXRlcjogVXBkYXRlcjxDb2x1bW5QaW5uaW5nU3RhdGU+KSA9PiB2b2lkXG59XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUgPSAoKTogQ29sdW1uUGlubmluZ1N0YXRlID0+ICh7XG4gIGxlZnQ6IFtdLFxuICByaWdodDogW10sXG59KVxuXG5leHBvcnQgY29uc3QgQ29sdW1uUGlubmluZzogVGFibGVGZWF0dXJlID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IChzdGF0ZSk6IENvbHVtblBpbm5pbmdUYWJsZVN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGUsXG4gICAgfVxuICB9LFxuXG4gIGdldERlZmF1bHRPcHRpb25zOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IENvbHVtblBpbm5pbmdEZWZhdWx0T3B0aW9ucyA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uUGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uUGlubmluZycsIHRhYmxlKSxcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlQ29sdW1uOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhLCBUVmFsdWU+KFxuICAgIGNvbHVtbjogQ29sdW1uPFREYXRhLCBUVmFsdWU+LFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogdm9pZCA9PiB7XG4gICAgY29sdW1uLnBpbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGNvbHVtblxuICAgICAgICAuZ2V0TGVhZkNvbHVtbnMoKVxuICAgICAgICAubWFwKGQgPT4gZC5pZClcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBzdHJpbmdbXVxuXG4gICAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAob2xkPy5sZWZ0ID8/IFtdKS5maWx0ZXIoZCA9PiAhY29sdW1uSWRzPy5pbmNsdWRlcyhkKSksXG4gICAgICAgICAgICByaWdodDogW1xuICAgICAgICAgICAgICAuLi4ob2xkPy5yaWdodCA/PyBbXSkuZmlsdGVyKGQgPT4gIWNvbHVtbklkcz8uaW5jbHVkZXMoZCkpLFxuICAgICAgICAgICAgICAuLi5jb2x1bW5JZHMsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IFtcbiAgICAgICAgICAgICAgLi4uKG9sZD8ubGVmdCA/PyBbXSkuZmlsdGVyKGQgPT4gIWNvbHVtbklkcz8uaW5jbHVkZXMoZCkpLFxuICAgICAgICAgICAgICAuLi5jb2x1bW5JZHMsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmlnaHQ6IChvbGQ/LnJpZ2h0ID8/IFtdKS5maWx0ZXIoZCA9PiAhY29sdW1uSWRzPy5pbmNsdWRlcyhkKSksXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiAob2xkPy5sZWZ0ID8/IFtdKS5maWx0ZXIoZCA9PiAhY29sdW1uSWRzPy5pbmNsdWRlcyhkKSksXG4gICAgICAgICAgcmlnaHQ6IChvbGQ/LnJpZ2h0ID8/IFtdKS5maWx0ZXIoZCA9PiAhY29sdW1uSWRzPy5pbmNsdWRlcyhkKSksXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29sdW1uLmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1uLmdldExlYWZDb2x1bW5zKClcblxuICAgICAgcmV0dXJuIGxlYWZDb2x1bW5zLnNvbWUoXG4gICAgICAgIGQgPT5cbiAgICAgICAgICAoZC5jb2x1bW5EZWYuZW5hYmxlUGlubmluZyA/PyB0cnVlKSAmJlxuICAgICAgICAgICh0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblBpbm5pbmcgPz9cbiAgICAgICAgICAgIHRhYmxlLm9wdGlvbnMuZW5hYmxlUGlubmluZyA/P1xuICAgICAgICAgICAgdHJ1ZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1uSWRzID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCkubWFwKGQgPT4gZC5pZClcblxuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nXG5cbiAgICAgIGNvbnN0IGlzTGVmdCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IGxlZnQ/LmluY2x1ZGVzKGQpKVxuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0Py5pbmNsdWRlcyhkKSlcblxuICAgICAgcmV0dXJuIGlzTGVmdCA/ICdsZWZ0JyA6IGlzUmlnaHQgPyAncmlnaHQnIDogZmFsc2VcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbHVtbi5nZXRJc1Bpbm5lZCgpXG5cbiAgICAgIHJldHVybiBwb3NpdGlvblxuICAgICAgICA/IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZz8uW3Bvc2l0aW9uXT8uaW5kZXhPZihjb2x1bW4uaWQpID8/IC0xXG4gICAgICAgIDogMFxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVSb3c6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHJvdzogUm93PFREYXRhPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICByb3cuX2dldEFsbFZpc2libGVDZWxscygpLFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCxcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0LFxuICAgICAgXSxcbiAgICAgIChhbGxDZWxscywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0OiBzdHJpbmdbXSA9IFsuLi4obGVmdCA/PyBbXSksIC4uLihyaWdodCA/PyBbXSldXG5cbiAgICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJylcbiAgICApXG4gICAgcm93LmdldExlZnRWaXNpYmxlQ2VsbHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSxcbiAgICAgIChhbGxDZWxscywgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjZWxscyA9IChsZWZ0ID8/IFtdKVxuICAgICAgICAgIC5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkhKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAubWFwKGQgPT4gKHsgLi4uZCwgcG9zaXRpb246ICdsZWZ0JyB9KSBhcyBDZWxsPFREYXRhLCB1bmtub3duPilcblxuICAgICAgICByZXR1cm4gY2VsbHNcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldExlZnRWaXNpYmxlQ2VsbHMnKVxuICAgIClcbiAgICByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sXG4gICAgICAoYWxsQ2VsbHMsIHJpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gKHJpZ2h0ID8/IFtdKVxuICAgICAgICAgIC5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkhKVxuICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAubWFwKGQgPT4gKHsgLi4uZCwgcG9zaXRpb246ICdyaWdodCcgfSkgYXMgQ2VsbDxURGF0YSwgdW5rbm93bj4pXG5cbiAgICAgICAgcmV0dXJuIGNlbGxzXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRSaWdodFZpc2libGVDZWxscycpXG4gICAgKVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyA9IHVwZGF0ZXIgPT5cbiAgICAgIHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlPy4odXBkYXRlcilcblxuICAgIHRhYmxlLnJlc2V0Q29sdW1uUGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PlxuICAgICAgdGFibGUuc2V0Q29sdW1uUGlubmluZyhcbiAgICAgICAgZGVmYXVsdFN0YXRlXG4gICAgICAgICAgPyBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKClcbiAgICAgICAgICA6IHRhYmxlLmluaXRpYWxTdGF0ZT8uY29sdW1uUGlubmluZyA/PyBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKClcbiAgICAgIClcblxuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmdcblxuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwaW5uaW5nU3RhdGUubGVmdD8ubGVuZ3RoIHx8IHBpbm5pbmdTdGF0ZS5yaWdodD8ubGVuZ3RoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4ocGlubmluZ1N0YXRlW3Bvc2l0aW9uXT8ubGVuZ3RoKVxuICAgIH1cblxuICAgIHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLFxuICAgICAgKGFsbENvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgICAgcmV0dXJuIChsZWZ0ID8/IFtdKVxuICAgICAgICAgIC5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSEpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0TGVmdExlYWZDb2x1bW5zJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLFxuICAgICAgKGFsbENvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICAgIHJldHVybiAocmlnaHQgPz8gW10pXG4gICAgICAgICAgLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpISlcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRSaWdodExlYWZDb2x1bW5zJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHQsXG4gICAgICBdLFxuICAgICAgKGFsbENvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICAgIGNvbnN0IGxlZnRBbmRSaWdodDogc3RyaW5nW10gPSBbLi4uKGxlZnQgPz8gW10pLCAuLi4ocmlnaHQgPz8gW10pXVxuXG4gICAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5pZCkpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRDZW50ZXJMZWFmQ29sdW1ucycpXG4gICAgKVxuICB9LFxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHNhZmVseUFjY2Vzc0RvY3VtZW50KF9kb2N1bWVudD86IERvY3VtZW50KTogRG9jdW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIF9kb2N1bWVudCB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVseUFjY2Vzc0RvY3VtZW50RXZlbnQoZXZlbnQ6IEV2ZW50KTogRG9jdW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuICEhZXZlbnQgJiZcbiAgICAhIWV2ZW50LnRhcmdldCAmJlxuICAgIHR5cGVvZiBldmVudC50YXJnZXQgPT09ICdvYmplY3QnICYmXG4gICAgJ293bmVyRG9jdW1lbnQnIGluIGV2ZW50LnRhcmdldFxuICAgID8gKGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IGFzIERvY3VtZW50IHwgbnVsbClcbiAgICA6IG51bGxcbn1cbiIsImltcG9ydCB7IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnMgfSBmcm9tICcuLidcbmltcG9ydCB7XG4gIFJvd0RhdGEsXG4gIENvbHVtbixcbiAgSGVhZGVyLFxuICBPbkNoYW5nZUZuLFxuICBUYWJsZSxcbiAgVXBkYXRlcixcbiAgVGFibGVGZWF0dXJlLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBDb2x1bW5QaW5uaW5nUG9zaXRpb24gfSBmcm9tICcuL0NvbHVtblBpbm5pbmcnXG5pbXBvcnQgeyBzYWZlbHlBY2Nlc3NEb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2RvY3VtZW50J1xuXG4vL1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtblNpemluZ1RhYmxlU3RhdGUge1xuICBjb2x1bW5TaXppbmc6IENvbHVtblNpemluZ1N0YXRlXG4gIGNvbHVtblNpemluZ0luZm86IENvbHVtblNpemluZ0luZm9TdGF0ZVxufVxuXG5leHBvcnQgdHlwZSBDb2x1bW5TaXppbmdTdGF0ZSA9IFJlY29yZDxzdHJpbmcsIG51bWJlcj5cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5TaXppbmdJbmZvU3RhdGUge1xuICBjb2x1bW5TaXppbmdTdGFydDogW3N0cmluZywgbnVtYmVyXVtdXG4gIGRlbHRhT2Zmc2V0OiBudWxsIHwgbnVtYmVyXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCB8IG51bWJlclxuICBpc1Jlc2l6aW5nQ29sdW1uOiBmYWxzZSB8IHN0cmluZ1xuICBzdGFydE9mZnNldDogbnVsbCB8IG51bWJlclxuICBzdGFydFNpemU6IG51bGwgfCBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgQ29sdW1uUmVzaXplTW9kZSA9ICdvbkNoYW5nZScgfCAnb25FbmQnXG5cbmV4cG9ydCB0eXBlIENvbHVtblJlc2l6ZURpcmVjdGlvbiA9ICdsdHInIHwgJ3J0bCdcblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5TaXppbmdPcHRpb25zIHtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hlbiB0aGUgY29sdW1uU2l6aW5nIHN0YXRlIGlzIHVwZGF0ZWQuIGBvbkNoYW5nZWAgdXBkYXRlcyB0aGUgc3RhdGUgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgcmVzaXplIGhhbmRsZS4gYG9uRW5kYCB1cGRhdGVzIHRoZSBzdGF0ZSB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSByZXNpemUgaGFuZGxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjY29sdW1ucmVzaXplbW9kZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBjb2x1bW5SZXNpemVNb2RlPzogQ29sdW1uUmVzaXplTW9kZVxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBjb2x1bW4gcmVzaXppbmcgZm9yIHRoZSBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNlbmFibGVjb2x1bW5yZXNpemluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBlbmFibGVDb2x1bW5SZXNpemluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcmlnaHQtdG8tbGVmdCBzdXBwb3J0IGZvciByZXNpemluZyB0aGUgY29sdW1uLiBkZWZhdWx0cyB0byAnbHRyJy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI2NvbHVtblJlc2l6ZURpcmVjdGlvbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBjb2x1bW5SZXNpemVEaXJlY3Rpb24/OiBDb2x1bW5SZXNpemVEaXJlY3Rpb25cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYHVwZGF0ZXJGbmAgd2hlbiBgc3RhdGUuY29sdW1uU2l6aW5nYCBjaGFuZ2VzLiBUaGlzIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbnRlcm5hbCBzdGF0ZSBtYW5hZ2VtZW50LCBzbyB5b3Ugd2lsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGBzdGF0ZS5jb2x1bW5TaXppbmdgIGZyb20geW91ciBvd24gbWFuYWdlZCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI29uY29sdW1uc2l6aW5nY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIG9uQ29sdW1uU2l6aW5nQ2hhbmdlPzogT25DaGFuZ2VGbjxDb2x1bW5TaXppbmdTdGF0ZT5cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYHVwZGF0ZXJGbmAgd2hlbiBgc3RhdGUuY29sdW1uU2l6aW5nSW5mb2AgY2hhbmdlcy4gVGhpcyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW50ZXJuYWwgc3RhdGUgbWFuYWdlbWVudCwgc28geW91IHdpbGwgYWxzbyBuZWVkIHRvIHN1cHBseSBgc3RhdGUuY29sdW1uU2l6aW5nSW5mb2AgZnJvbSB5b3VyIG93biBtYW5hZ2VkIHN0YXRlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjb25jb2x1bW5zaXppbmdpbmZvY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZT86IE9uQ2hhbmdlRm48Q29sdW1uU2l6aW5nSW5mb1N0YXRlPlxufVxuXG5leHBvcnQgdHlwZSBDb2x1bW5TaXppbmdEZWZhdWx0T3B0aW9ucyA9IFBpY2s8XG4gIENvbHVtblNpemluZ09wdGlvbnMsXG4gIHwgJ2NvbHVtblJlc2l6ZU1vZGUnXG4gIHwgJ29uQ29sdW1uU2l6aW5nQ2hhbmdlJ1xuICB8ICdvbkNvbHVtblNpemluZ0luZm9DaGFuZ2UnXG4gIHwgJ2NvbHVtblJlc2l6ZURpcmVjdGlvbidcbj5cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5TaXppbmdJbnN0YW5jZSB7XG4gIC8qKlxuICAgKiBJZiBwaW5uaW5nLCByZXR1cm5zIHRoZSB0b3RhbCBzaXplIG9mIHRoZSBjZW50ZXIgcG9ydGlvbiBvZiB0aGUgdGFibGUgYnkgY2FsY3VsYXRpbmcgdGhlIHN1bSBvZiB0aGUgc2l6ZXMgb2YgYWxsIHVucGlubmVkL2NlbnRlciBsZWFmLWNvbHVtbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRjZW50ZXJ0b3RhbHNpemUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tc2l6aW5nKVxuICAgKi9cbiAgZ2V0Q2VudGVyVG90YWxTaXplOiAoKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdGFsIHNpemUgb2YgdGhlIGxlZnQgcG9ydGlvbiBvZiB0aGUgdGFibGUgYnkgY2FsY3VsYXRpbmcgdGhlIHN1bSBvZiB0aGUgc2l6ZXMgb2YgYWxsIGxlZnQgbGVhZi1jb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjZ2V0bGVmdHRvdGFsc2l6ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBnZXRMZWZ0VG90YWxTaXplOiAoKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvdGFsIHNpemUgb2YgdGhlIHJpZ2h0IHBvcnRpb24gb2YgdGhlIHRhYmxlIGJ5IGNhbGN1bGF0aW5nIHRoZSBzdW0gb2YgdGhlIHNpemVzIG9mIGFsbCByaWdodCBsZWFmLWNvbHVtbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRyaWdodHRvdGFsc2l6ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBnZXRSaWdodFRvdGFsU2l6ZTogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBzaXplIG9mIHRoZSB0YWJsZSBieSBjYWxjdWxhdGluZyB0aGUgc3VtIG9mIHRoZSBzaXplcyBvZiBhbGwgbGVhZi1jb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjZ2V0dG90YWxzaXplKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIGdldFRvdGFsU2l6ZTogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXNldHMgY29sdW1uIHNpemluZyB0byBpdHMgaW5pdGlhbCBzdGF0ZS4gSWYgYGRlZmF1bHRTdGF0ZWAgaXMgYHRydWVgLCB0aGUgZGVmYXVsdCBzdGF0ZSBmb3IgdGhlIHRhYmxlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsVmFsdWUgcHJvdmlkZWQgdG8gdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjcmVzZXRjb2x1bW5zaXppbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tc2l6aW5nKVxuICAgKi9cbiAgcmVzZXRDb2x1bW5TaXppbmc6IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXNldHMgY29sdW1uIHNpemluZyBpbmZvIHRvIGl0cyBpbml0aWFsIHN0YXRlLiBJZiBgZGVmYXVsdFN0YXRlYCBpcyBgdHJ1ZWAsIHRoZSBkZWZhdWx0IHN0YXRlIGZvciB0aGUgdGFibGUgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGluaXRpYWxWYWx1ZSBwcm92aWRlZCB0byB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNyZXNldGhlYWRlcnNpemVpbmZvKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIHJlc2V0SGVhZGVyU2l6ZUluZm86IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb2x1bW4gc2l6aW5nIHN0YXRlIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gb3IgYSB2YWx1ZS4gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIHVuZGVybHlpbmcgYG9uQ29sdW1uU2l6aW5nQ2hhbmdlYCBmdW5jdGlvbiBpZiBvbmUgaXMgcGFzc2VkIHRvIHRoZSB0YWJsZSBvcHRpb25zLCBvdGhlcndpc2UgdGhlIHN0YXRlIHdpbGwgYmUgbWFuYWdlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI3NldGNvbHVtbnNpemluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBzZXRDb2x1bW5TaXppbmc6ICh1cGRhdGVyOiBVcGRhdGVyPENvbHVtblNpemluZ1N0YXRlPikgPT4gdm9pZFxuICAvKipcbiAgICogU2V0cyB0aGUgY29sdW1uIHNpemluZyBpbmZvIHN0YXRlIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gb3IgYSB2YWx1ZS4gVGhpcyB3aWxsIHRyaWdnZXIgdGhlIHVuZGVybHlpbmcgYG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZWAgZnVuY3Rpb24gaWYgb25lIGlzIHBhc3NlZCB0byB0aGUgdGFibGUgb3B0aW9ucywgb3RoZXJ3aXNlIHRoZSBzdGF0ZSB3aWxsIGJlIG1hbmFnZWQgYXV0b21hdGljYWxseSBieSB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNzZXRjb2x1bW5zaXppbmdpbmZvKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIHNldENvbHVtblNpemluZ0luZm86ICh1cGRhdGVyOiBVcGRhdGVyPENvbHVtblNpemluZ0luZm9TdGF0ZT4pID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5TaXppbmdDb2x1bW5EZWYge1xuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBjb2x1bW4gcmVzaXppbmcgZm9yIHRoZSBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNlbmFibGVyZXNpemluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBlbmFibGVSZXNpemluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBmb3IgdGhlIGNvbHVtblxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjbWF4c2l6ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBtYXhTaXplPzogbnVtYmVyXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBhbGxvd2VkIHNpemUgZm9yIHRoZSBjb2x1bW5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI21pbnNpemUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tc2l6aW5nKVxuICAgKi9cbiAgbWluU2l6ZT86IG51bWJlclxuICAvKipcbiAgICogVGhlIGRlc2lyZWQgc2l6ZSBmb3IgdGhlIGNvbHVtblxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjc2l6ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBzaXplPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uU2l6aW5nQ29sdW1uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRjYW5yZXNpemUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tc2l6aW5nKVxuICAgKi9cbiAgZ2V0Q2FuUmVzaXplOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyByZXNpemVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi1zaXppbmcjZ2V0aXNyZXNpemluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBnZXRJc1Jlc2l6aW5nOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI2dldHNpemUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tc2l6aW5nKVxuICAgKi9cbiAgZ2V0U2l6ZTogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgbWVhc3VyZW1lbnQgYWxvbmcgdGhlIHJvdy1heGlzICh1c3VhbGx5IHRoZSB4LWF4aXMgZm9yIHN0YW5kYXJkIHRhYmxlcykgZm9yIHRoZSBoZWFkZXIuIFRoaXMgaXMgZWZmZWN0aXZlbHkgYSBzdW0gb2YgdGhlIG9mZnNldCBtZWFzdXJlbWVudHMgb2YgYWxsIHByZWNlZGluZyAobGVmdCkgaGVhZGVycyBpbiByZWxhdGlvbiB0byB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRzdGFydClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICBnZXRTdGFydDogKHBvc2l0aW9uPzogQ29sdW1uUGlubmluZ1Bvc2l0aW9uIHwgJ2NlbnRlcicpID0+IG51bWJlclxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG1lYXN1cmVtZW50IGFsb25nIHRoZSByb3ctYXhpcyAodXN1YWxseSB0aGUgeC1heGlzIGZvciBzdGFuZGFyZCB0YWJsZXMpIGZvciB0aGUgaGVhZGVyLiBUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgc3VtIG9mIHRoZSBvZmZzZXQgbWVhc3VyZW1lbnRzIG9mIGFsbCBzdWNjZWVkaW5nIChyaWdodCkgaGVhZGVycyBpbiByZWxhdGlvbiB0byB0aGUgY3VycmVudCBjb2x1bW4uXG4gICAqL1xuICBnZXRBZnRlcjogKHBvc2l0aW9uPzogQ29sdW1uUGlubmluZ1Bvc2l0aW9uIHwgJ2NlbnRlcicpID0+IG51bWJlclxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjb2x1bW4gdG8gaXRzIGluaXRpYWwgc2l6ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI3Jlc2V0c2l6ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi1zaXppbmcpXG4gICAqL1xuICByZXNldFNpemU6ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5TaXppbmdIZWFkZXIge1xuICAvKipcbiAgICogUmV0dXJucyBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzaXplIHRoZSBoZWFkZXIuIEl0IGNhbiBiZSB1c2VkIGFzIGFuOlxuICAgKiAtIGBvbk1vdXNlRG93bmAgaGFuZGxlclxuICAgKiAtIGBvblRvdWNoU3RhcnRgIGhhbmRsZXJcbiAgICpcbiAgICogVGhlIGRyYWdnaW5nIGFuZCByZWxlYXNlIGV2ZW50cyBhcmUgYXV0b21hdGljYWxseSBoYW5kbGVkIGZvciB5b3UuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRyZXNpemVoYW5kbGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIGdldFJlc2l6ZUhhbmRsZXI6IChjb250ZXh0PzogRG9jdW1lbnQpID0+IChldmVudDogdW5rbm93bikgPT4gdm9pZFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBoZWFkZXIuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXNpemluZyNnZXRzaXplKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIGdldFNpemU6ICgpID0+IG51bWJlclxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0IG1lYXN1cmVtZW50IGFsb25nIHRoZSByb3ctYXhpcyAodXN1YWxseSB0aGUgeC1heGlzIGZvciBzdGFuZGFyZCB0YWJsZXMpIGZvciB0aGUgaGVhZGVyLiBUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgc3VtIG9mIHRoZSBvZmZzZXQgbWVhc3VyZW1lbnRzIG9mIGFsbCBwcmVjZWRpbmcgaGVhZGVycy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tc2l6aW5nI2dldHN0YXJ0KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXNpemluZylcbiAgICovXG4gIGdldFN0YXJ0OiAocG9zaXRpb24/OiBDb2x1bW5QaW5uaW5nUG9zaXRpb24pID0+IG51bWJlclxufVxuXG4vL1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcbiAgc2l6ZTogMTUwLFxuICBtaW5TaXplOiAyMCxcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG59XG5cbmNvbnN0IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUgPSAoKTogQ29sdW1uU2l6aW5nSW5mb1N0YXRlID0+ICh7XG4gIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICBzdGFydFNpemU6IG51bGwsXG4gIGRlbHRhT2Zmc2V0OiBudWxsLFxuICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICBjb2x1bW5TaXppbmdTdGFydDogW10sXG59KVxuXG5leHBvcnQgY29uc3QgQ29sdW1uU2l6aW5nOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpOiBDb2x1bW5TaXppbmdDb2x1bW5EZWYgPT4ge1xuICAgIHJldHVybiBkZWZhdWx0Q29sdW1uU2l6aW5nXG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogQ29sdW1uU2l6aW5nVGFibGVTdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblNpemluZzoge30sXG4gICAgICBjb2x1bW5TaXppbmdJbmZvOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogQ29sdW1uU2l6aW5nRGVmYXVsdE9wdGlvbnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5SZXNpemVNb2RlOiAnb25FbmQnLFxuICAgICAgY29sdW1uUmVzaXplRGlyZWN0aW9uOiAnbHRyJyxcbiAgICAgIG9uQ29sdW1uU2l6aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmcnLCB0YWJsZSksXG4gICAgICBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZ0luZm8nLCB0YWJsZSksXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUNvbHVtbjogPFREYXRhIGV4dGVuZHMgUm93RGF0YSwgVFZhbHVlPihcbiAgICBjb2x1bW46IENvbHVtbjxURGF0YSwgVFZhbHVlPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbHVtbi5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uU2l6ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nW2NvbHVtbi5pZF1cblxuICAgICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUgPz8gZGVmYXVsdENvbHVtblNpemluZy5taW5TaXplLFxuICAgICAgICAgIGNvbHVtblNpemUgPz8gY29sdW1uLmNvbHVtbkRlZi5zaXplID8/IGRlZmF1bHRDb2x1bW5TaXppbmcuc2l6ZVxuICAgICAgICApLFxuICAgICAgICBjb2x1bW4uY29sdW1uRGVmLm1heFNpemUgPz8gZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplXG4gICAgICApXG4gICAgfVxuXG4gICAgY29sdW1uLmdldFN0YXJ0ID0gbWVtbyhcbiAgICAgIHBvc2l0aW9uID0+IFtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSxcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmcsXG4gICAgICBdLFxuICAgICAgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PlxuICAgICAgICBjb2x1bW5zXG4gICAgICAgICAgLnNsaWNlKDAsIGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikpXG4gICAgICAgICAgLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRTdGFydCcpXG4gICAgKVxuXG4gICAgY29sdW1uLmdldEFmdGVyID0gbWVtbyhcbiAgICAgIHBvc2l0aW9uID0+IFtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKSxcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmcsXG4gICAgICBdLFxuICAgICAgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PlxuICAgICAgICBjb2x1bW5zXG4gICAgICAgICAgLnNsaWNlKGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikgKyAxKVxuICAgICAgICAgIC5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWZ0ZXInKVxuICAgIClcblxuICAgIGNvbHVtbi5yZXNldFNpemUgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoKHsgW2NvbHVtbi5pZF06IF8sIC4uLnJlc3QgfSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdFxuICAgICAgfSlcbiAgICB9XG4gICAgY29sdW1uLmdldENhblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nID8/IHRydWUpICYmXG4gICAgICAgICh0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nID8/IHRydWUpXG4gICAgICApXG4gICAgfVxuICAgIGNvbHVtbi5nZXRJc1Jlc2l6aW5nID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nSW5mby5pc1Jlc2l6aW5nQ29sdW1uID09PSBjb2x1bW4uaWRcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlSGVhZGVyOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhLCBUVmFsdWU+KFxuICAgIGhlYWRlcjogSGVhZGVyPFREYXRhLCBUVmFsdWU+LFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogdm9pZCA9PiB7XG4gICAgaGVhZGVyLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICBsZXQgc3VtID0gMFxuXG4gICAgICBjb25zdCByZWN1cnNlID0gKGhlYWRlcjogSGVhZGVyPFREYXRhLCBUVmFsdWU+KSA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VtICs9IGhlYWRlci5jb2x1bW4uZ2V0U2l6ZSgpID8/IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWN1cnNlKGhlYWRlcilcblxuICAgICAgcmV0dXJuIHN1bVxuICAgIH1cbiAgICBoZWFkZXIuZ2V0U3RhcnQgPSAoKSA9PiB7XG4gICAgICBpZiAoaGVhZGVyLmluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZ0hlYWRlciA9IGhlYWRlci5oZWFkZXJHcm91cC5oZWFkZXJzW2hlYWRlci5pbmRleCAtIDFdIVxuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdIZWFkZXIuZ2V0U3RhcnQoKSArIHByZXZTaWJsaW5nSGVhZGVyLmdldFNpemUoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBoZWFkZXIuZ2V0UmVzaXplSGFuZGxlciA9IF9jb250ZXh0RG9jdW1lbnQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGhlYWRlci5jb2x1bW4uaWQpXG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4/LmdldENhblJlc2l6ZSgpXG5cbiAgICAgIHJldHVybiAoZTogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAoIWNvbHVtbiB8fCAhY2FuUmVzaXplKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICA7KGUgYXMgYW55KS5wZXJzaXN0Py4oKVxuXG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIC8vIGxldHMgbm90IHJlc3BvbmQgdG8gbXVsdGlwbGUgdG91Y2hlcyAoZS5nLiAyIG9yIDMgZmluZ2VycylcbiAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdGFydFNpemUgPSBoZWFkZXIuZ2V0U2l6ZSgpXG5cbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQ6IFtzdHJpbmcsIG51bWJlcl1bXSA9IGhlYWRlclxuICAgICAgICAgID8gaGVhZGVyLmdldExlYWZIZWFkZXJzKCkubWFwKGQgPT4gW2QuY29sdW1uLmlkLCBkLmNvbHVtbi5nZXRTaXplKCldKVxuICAgICAgICAgIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXVxuXG4gICAgICAgIGNvbnN0IGNsaWVudFggPSBpc1RvdWNoU3RhcnRFdmVudChlKVxuICAgICAgICAgID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0hLmNsaWVudFgpXG4gICAgICAgICAgOiAoZSBhcyBNb3VzZUV2ZW50KS5jbGllbnRYXG5cbiAgICAgICAgY29uc3QgbmV3Q29sdW1uU2l6aW5nOiBDb2x1bW5TaXppbmdTdGF0ZSA9IHt9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlT2Zmc2V0ID0gKFxuICAgICAgICAgIGV2ZW50VHlwZTogJ21vdmUnIHwgJ2VuZCcsXG4gICAgICAgICAgY2xpZW50WFBvcz86IG51bWJlclxuICAgICAgICApID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudFhQb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9XG4gICAgICAgICAgICAgIHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMVxuICAgICAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPVxuICAgICAgICAgICAgICAoY2xpZW50WFBvcyAtIChvbGQ/LnN0YXJ0T2Zmc2V0ID8/IDApKSAqIGRlbHRhRGlyZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnRhZ2UgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQgLyAob2xkPy5zdGFydFNpemUgPz8gMCksXG4gICAgICAgICAgICAgIC0wLjk5OTk5OVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaCgoW2NvbHVtbklkLCBoZWFkZXJTaXplXSkgPT4ge1xuICAgICAgICAgICAgICBuZXdDb2x1bW5TaXppbmdbY29sdW1uSWRdID1cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoaGVhZGVyU2l6ZSArIGhlYWRlclNpemUgKiBkZWx0YVBlcmNlbnRhZ2UsIDApICogMTAwXG4gICAgICAgICAgICAgICAgKSAvIDEwMFxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICBkZWx0YU9mZnNldCxcbiAgICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZU1vZGUgPT09ICdvbkNoYW5nZScgfHxcbiAgICAgICAgICAgIGV2ZW50VHlwZSA9PT0gJ2VuZCdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmcsXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbk1vdmUgPSAoY2xpZW50WFBvcz86IG51bWJlcikgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcylcblxuICAgICAgICBjb25zdCBvbkVuZCA9IChjbGllbnRYUG9zPzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKVxuXG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBzdGFydFNpemU6IG51bGwsXG4gICAgICAgICAgICBkZWx0YU9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0OiBbXSxcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHREb2N1bWVudCA9IHNhZmVseUFjY2Vzc0RvY3VtZW50KF9jb250ZXh0RG9jdW1lbnQpXG5cbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IChlOiBNb3VzZUV2ZW50KSA9PiBvbk1vdmUoZS5jbGllbnRYKSxcbiAgICAgICAgICB1cEhhbmRsZXI6IChlOiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY29udGV4dERvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAgIG1vdXNlRXZlbnRzLnVwSGFuZGxlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZShlLnRvdWNoZXNbMF0hLmNsaWVudFgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwSGFuZGxlcjogKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgIHRvdWNoRXZlbnRzLnVwSGFuZGxlclxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FbmQoZS50b3VjaGVzWzBdPy5jbGllbnRYKVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXNzaXZlSWZTdXBwb3J0ZWQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKVxuICAgICAgICAgID8geyBwYXNzaXZlOiBmYWxzZSB9XG4gICAgICAgICAgOiBmYWxzZVxuXG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIsXG4gICAgICAgICAgICBwYXNzaXZlSWZTdXBwb3J0ZWRcbiAgICAgICAgICApXG4gICAgICAgICAgY29udGV4dERvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgIHRvdWNoRXZlbnRzLnVwSGFuZGxlcixcbiAgICAgICAgICAgIHBhc3NpdmVJZlN1cHBvcnRlZFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLFxuICAgICAgICAgICAgcGFzc2l2ZUlmU3VwcG9ydGVkXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnRleHREb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICdtb3VzZXVwJyxcbiAgICAgICAgICAgIG1vdXNlRXZlbnRzLnVwSGFuZGxlcixcbiAgICAgICAgICAgIHBhc3NpdmVJZlN1cHBvcnRlZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBjbGllbnRYLFxuICAgICAgICAgIHN0YXJ0U2l6ZSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uLmlkLFxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlVGFibGU6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KHRhYmxlOiBUYWJsZTxURGF0YT4pOiB2b2lkID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcgPSB1cGRhdGVyID0+XG4gICAgICB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlPy4odXBkYXRlcilcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvID0gdXBkYXRlciA9PlxuICAgICAgdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2U/Lih1cGRhdGVyKVxuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhcbiAgICAgICAgZGVmYXVsdFN0YXRlID8ge30gOiB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nID8/IHt9XG4gICAgICApXG4gICAgfVxuICAgIHRhYmxlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhcbiAgICAgICAgZGVmYXVsdFN0YXRlXG4gICAgICAgICAgPyBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKClcbiAgICAgICAgICA6IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmdJbmZvID8/XG4gICAgICAgICAgICAgIGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKVxuICAgICAgKVxuICAgIH1cbiAgICB0YWJsZS5nZXRUb3RhbFNpemUgPSAoKSA9PlxuICAgICAgdGFibGUuZ2V0SGVhZGVyR3JvdXBzKClbMF0/LmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKVxuICAgICAgfSwgMCkgPz8gMFxuICAgIHRhYmxlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PlxuICAgICAgdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdPy5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKClcbiAgICAgIH0sIDApID8/IDBcbiAgICB0YWJsZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PlxuICAgICAgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKClbMF0/LmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKVxuICAgICAgfSwgMCkgPz8gMFxuICAgIHRhYmxlLmdldFJpZ2h0VG90YWxTaXplID0gKCkgPT5cbiAgICAgIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKClbMF0/LmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKVxuICAgICAgfSwgMCkgPz8gMFxuICB9LFxufVxuXG5sZXQgcGFzc2l2ZVN1cHBvcnRlZDogYm9vbGVhbiB8IG51bGwgPSBudWxsXG5leHBvcnQgZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWRcblxuICBsZXQgc3VwcG9ydGVkID0gZmFsc2VcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wLCBvcHRpb25zKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2VcbiAgfVxuICBwYXNzaXZlU3VwcG9ydGVkID0gc3VwcG9ydGVkXG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkXG59XG5cbmZ1bmN0aW9uIGlzVG91Y2hTdGFydEV2ZW50KGU6IHVua25vd24pOiBlIGlzIFRvdWNoRXZlbnQge1xuICByZXR1cm4gKGUgYXMgVG91Y2hFdmVudCkudHlwZSA9PT0gJ3RvdWNoc3RhcnQnXG59XG4iLCJpbXBvcnQgeyBDb2x1bW5QaW5uaW5nUG9zaXRpb24gfSBmcm9tICcuLidcbmltcG9ydCB7XG4gIENlbGwsXG4gIENvbHVtbixcbiAgT25DaGFuZ2VGbixcbiAgVGFibGUsXG4gIFVwZGF0ZXIsXG4gIFJvdyxcbiAgUm93RGF0YSxcbiAgVGFibGVGZWF0dXJlLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCB0eXBlIFZpc2liaWxpdHlTdGF0ZSA9IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzaWJpbGl0eVRhYmxlU3RhdGUge1xuICBjb2x1bW5WaXNpYmlsaXR5OiBWaXNpYmlsaXR5U3RhdGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXNpYmlsaXR5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBjb2x1bW4gaGlkaW5nLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjZW5hYmxlaGlkaW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBlbmFibGVIaWRpbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVyRm5gIHdoZW4gYHN0YXRlLmNvbHVtblZpc2liaWxpdHlgIGNoYW5nZXMuIFRoaXMgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGludGVybmFsIHN0YXRlIG1hbmFnZW1lbnQsIHNvIHlvdSB3aWxsIG5lZWQgdG8gcGVyc2lzdCB0aGUgc3RhdGUgY2hhbmdlIGVpdGhlciBmdWxseSBvciBwYXJ0aWFsbHkgb3V0c2lkZSBvZiB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjb25jb2x1bW52aXNpYmlsaXR5Y2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U/OiBPbkNoYW5nZUZuPFZpc2liaWxpdHlTdGF0ZT5cbn1cblxuZXhwb3J0IHR5cGUgVmlzaWJpbGl0eURlZmF1bHRPcHRpb25zID0gUGljazxcbiAgVmlzaWJpbGl0eU9wdGlvbnMsXG4gICdvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UnXG4+XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzaWJpbGl0eUluc3RhbmNlPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogSWYgY29sdW1uIHBpbm5pbmcsIHJldHVybnMgYSBmbGF0IGFycmF5IG9mIGxlYWYtbm9kZSBjb2x1bW5zIHRoYXQgYXJlIHZpc2libGUgaW4gdGhlIHVucGlubmVkL2NlbnRlciBwb3J0aW9uIG9mIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSNnZXRjZW50ZXJ2aXNpYmxlbGVhZmNvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIGdldENlbnRlclZpc2libGVMZWFmQ29sdW1uczogKCkgPT4gQ29sdW1uPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYWxsIGNvbHVtbnMgYXJlIHZpc2libGVcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSNnZXRpc2FsbGNvbHVtbnN2aXNpYmxlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRJc0FsbENvbHVtbnNWaXNpYmxlOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYW55IGNvbHVtbnMgYXJlIHZpc2libGVcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSNnZXRpc3NvbWVjb2x1bW5zdmlzaWJsZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi12aXNpYmlsaXR5KVxuICAgKi9cbiAgZ2V0SXNTb21lQ29sdW1uc1Zpc2libGU6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIElmIGNvbHVtbiBwaW5uaW5nLCByZXR1cm5zIGEgZmxhdCBhcnJheSBvZiBsZWFmLW5vZGUgY29sdW1ucyB0aGF0IGFyZSB2aXNpYmxlIGluIHRoZSBsZWZ0IHBvcnRpb24gb2YgdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi12aXNpYmlsaXR5I2dldGxlZnR2aXNpYmxlbGVhZmNvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIGdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogSWYgY29sdW1uIHBpbm5pbmcsIHJldHVybnMgYSBmbGF0IGFycmF5IG9mIGxlYWYtbm9kZSBjb2x1bW5zIHRoYXQgYXJlIHZpc2libGUgaW4gdGhlIHJpZ2h0IHBvcnRpb24gb2YgdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi12aXNpYmlsaXR5I2dldHJpZ2h0dmlzaWJsZWxlYWZjb2x1bW5zKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRSaWdodFZpc2libGVMZWFmQ29sdW1uczogKCkgPT4gQ29sdW1uPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFuZGxlciBmb3IgdG9nZ2xpbmcgdGhlIHZpc2liaWxpdHkgb2YgYWxsIGNvbHVtbnMsIG1lYW50IHRvIGJlIGJvdW5kIHRvIGEgYGlucHV0W3R5cGU9Y2hlY2tib3hdYCBlbGVtZW50LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi12aXNpYmlsaXR5I2dldHRvZ2dsZWFsbGNvbHVtbnN2aXNpYmlsaXR5aGFuZGxlcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi12aXNpYmlsaXR5KVxuICAgKi9cbiAgZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyOiAoKSA9PiAoZXZlbnQ6IHVua25vd24pID0+IHZvaWRcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0IGFycmF5IG9mIGNvbHVtbnMgdGhhdCBhcmUgdmlzaWJsZSwgaW5jbHVkaW5nIHBhcmVudCBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi12aXNpYmlsaXR5I2dldHZpc2libGVmbGF0Y29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2NvbHVtbi12aXNpYmlsaXR5KVxuICAgKi9cbiAgZ2V0VmlzaWJsZUZsYXRDb2x1bW5zOiAoKSA9PiBDb2x1bW48VERhdGEsIHVua25vd24+W11cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0IGFycmF5IG9mIGxlYWYtbm9kZSBjb2x1bW5zIHRoYXQgYXJlIHZpc2libGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjZ2V0dmlzaWJsZWxlYWZjb2x1bW5zKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRWaXNpYmxlTGVhZkNvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmVzZXRzIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBzdGF0ZSB0byB0aGUgaW5pdGlhbCBzdGF0ZS4gSWYgYGRlZmF1bHRTdGF0ZWAgaXMgcHJvdmlkZWQsIHRoZSBzdGF0ZSB3aWxsIGJlIHJlc2V0IHRvIGB7fWBcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSNyZXNldGNvbHVtbnZpc2liaWxpdHkpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIHJlc2V0Q29sdW1uVmlzaWJpbGl0eTogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgYHN0YXRlLmNvbHVtblZpc2liaWxpdHlgIHN0YXRlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2NvbHVtbi12aXNpYmlsaXR5I3NldGNvbHVtbnZpc2liaWxpdHkpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIHNldENvbHVtblZpc2liaWxpdHk6ICh1cGRhdGVyOiBVcGRhdGVyPFZpc2liaWxpdHlTdGF0ZT4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgYWxsIGNvbHVtbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjdG9nZ2xlYWxsY29sdW1uc3Zpc2libGUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIHRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlOiAodmFsdWU/OiBib29sZWFuKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlzaWJpbGl0eUNvbHVtbkRlZiB7XG4gIGVuYWJsZUhpZGluZz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXNpYmlsaXR5Um93PFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBfZ2V0QWxsVmlzaWJsZUNlbGxzOiAoKSA9PiBDZWxsPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNlbGxzIHRoYXQgYWNjb3VudCBmb3IgY29sdW1uIHZpc2liaWxpdHkgZm9yIHRoZSByb3cuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjZ2V0dmlzaWJsZWNlbGxzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRWaXNpYmxlQ2VsbHM6ICgpID0+IENlbGw8VERhdGEsIHVua25vd24+W11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXNpYmlsaXR5Q29sdW1uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgY29sdW1uIGNhbiBiZSBoaWRkZW5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSNnZXRjYW5oaWRlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRDYW5IaWRlOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGNvbHVtbiBpcyB2aXNpYmxlXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjZ2V0aXN2aXNpYmxlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICBnZXRJc1Zpc2libGU6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHRvZ2dsZSB0aGUgY29sdW1uIHZpc2liaWxpdHkuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYmluZCB0byBhbiBldmVudCBoYW5kbGVyIHRvIGEgY2hlY2tib3guXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvY29sdW1uLXZpc2liaWxpdHkjZ2V0dG9nZ2xldmlzaWJpbGl0eWhhbmRsZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9jb2x1bW4tdmlzaWJpbGl0eSlcbiAgICovXG4gIGdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyOiAoKSA9PiAoZXZlbnQ6IHVua25vd24pID0+IHZvaWRcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9jb2x1bW4tdmlzaWJpbGl0eSN0b2dnbGV2aXNpYmlsaXR5KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvY29sdW1uLXZpc2liaWxpdHkpXG4gICAqL1xuICB0b2dnbGVWaXNpYmlsaXR5OiAodmFsdWU/OiBib29sZWFuKSA9PiB2b2lkXG59XG5cbi8vXG5cbmV4cG9ydCBjb25zdCBDb2x1bW5WaXNpYmlsaXR5OiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogVmlzaWJpbGl0eVRhYmxlU3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiB7fSxcbiAgICAgIC4uLnN0YXRlLFxuICAgIH1cbiAgfSxcblxuICBnZXREZWZhdWx0T3B0aW9uczogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiBWaXNpYmlsaXR5RGVmYXVsdE9wdGlvbnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblZpc2liaWxpdHknLCB0YWJsZSksXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUNvbHVtbjogPFREYXRhIGV4dGVuZHMgUm93RGF0YSwgVFZhbHVlPihcbiAgICBjb2x1bW46IENvbHVtbjxURGF0YSwgVFZhbHVlPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKGNvbHVtbi5nZXRDYW5IaWRlKCkpIHtcbiAgICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgW2NvbHVtbi5pZF06IHZhbHVlID8/ICFjb2x1bW4uZ2V0SXNWaXNpYmxlKCksXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2x1bW4uZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRDb2x1bW5zID0gY29sdW1uLmNvbHVtbnNcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjaGlsZENvbHVtbnMubGVuZ3RoXG4gICAgICAgICAgPyBjaGlsZENvbHVtbnMuc29tZShjID0+IGMuZ2V0SXNWaXNpYmxlKCkpXG4gICAgICAgICAgOiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHk/Lltjb2x1bW4uaWRdKSA/PyB0cnVlXG4gICAgICApXG4gICAgfVxuXG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY29sdW1uLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcgPz8gdHJ1ZSkgJiZcbiAgICAgICAgKHRhYmxlLm9wdGlvbnMuZW5hYmxlSGlkaW5nID8/IHRydWUpXG4gICAgICApXG4gICAgfVxuICAgIGNvbHVtbi5nZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoZTogdW5rbm93bikgPT4ge1xuICAgICAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eT8uKFxuICAgICAgICAgICgoZSBhcyBNb3VzZUV2ZW50KS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVJvdzogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gICAgcm93OiBSb3c8VERhdGE+LFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogdm9pZCA9PiB7XG4gICAgcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLFxuICAgICAgY2VsbHMgPT4ge1xuICAgICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGNlbGwgPT4gY2VsbC5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdfZ2V0QWxsVmlzaWJsZUNlbGxzJylcbiAgICApXG4gICAgcm93LmdldFZpc2libGVDZWxscyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHJvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzKCksXG4gICAgICAgIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSxcbiAgICAgICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzKCksXG4gICAgICBdLFxuICAgICAgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IFsuLi5sZWZ0LCAuLi5jZW50ZXIsIC4uLnJpZ2h0XSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0VmlzaWJsZUNlbGxzJylcbiAgICApXG4gIH0sXG5cbiAgY3JlYXRlVGFibGU6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KHRhYmxlOiBUYWJsZTxURGF0YT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QgPSAoXG4gICAgICBrZXk6IHN0cmluZyxcbiAgICAgIGdldENvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAgICk6ICgoKSA9PiBDb2x1bW48VERhdGEsIHVua25vd24+W10pID0+IHtcbiAgICAgIHJldHVybiBtZW1vKFxuICAgICAgICAoKSA9PiBbXG4gICAgICAgICAgZ2V0Q29sdW1ucygpLFxuICAgICAgICAgIGdldENvbHVtbnMoKVxuICAgICAgICAgICAgLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpXG4gICAgICAgICAgICAubWFwKGQgPT4gZC5pZClcbiAgICAgICAgICAgIC5qb2luKCdfJyksXG4gICAgICAgIF0sXG4gICAgICAgIGNvbHVtbnMgPT4ge1xuICAgICAgICAgIHJldHVybiBjb2x1bW5zLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlPy4oKSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsIGtleSlcbiAgICAgIClcbiAgICB9XG5cbiAgICB0YWJsZS5nZXRWaXNpYmxlRmxhdENvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoXG4gICAgICAnZ2V0VmlzaWJsZUZsYXRDb2x1bW5zJyxcbiAgICAgICgpID0+IHRhYmxlLmdldEFsbEZsYXRDb2x1bW5zKClcbiAgICApXG4gICAgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKFxuICAgICAgJ2dldFZpc2libGVMZWFmQ29sdW1ucycsXG4gICAgICAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpXG4gICAgKVxuICAgIHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoXG4gICAgICAnZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucycsXG4gICAgICAoKSA9PiB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMoKVxuICAgIClcbiAgICB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZChcbiAgICAgICdnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucycsXG4gICAgICAoKSA9PiB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zKClcbiAgICApXG4gICAgdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKFxuICAgICAgJ2dldENlbnRlclZpc2libGVMZWFmQ29sdW1ucycsXG4gICAgICAoKSA9PiB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucygpXG4gICAgKVxuXG4gICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IHVwZGF0ZXIgPT5cbiAgICAgIHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlPy4odXBkYXRlcilcblxuICAgIHRhYmxlLnJlc2V0Q29sdW1uVmlzaWJpbGl0eSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KFxuICAgICAgICBkZWZhdWx0U3RhdGUgPyB7fSA6IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5WaXNpYmlsaXR5ID8/IHt9XG4gICAgICApXG4gICAgfVxuXG4gICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUgPSB2YWx1ZSA9PiB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID8/ICF0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlKClcblxuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShcbiAgICAgICAgdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5yZWR1Y2UoXG4gICAgICAgICAgKG9iaiwgY29sdW1uKSA9PiAoe1xuICAgICAgICAgICAgLi4ub2JqLFxuICAgICAgICAgICAgW2NvbHVtbi5pZF06ICF2YWx1ZSA/ICFjb2x1bW4uZ2V0Q2FuSGlkZT8uKCkgOiB2YWx1ZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuXG4gICAgdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSA9ICgpID0+XG4gICAgICAhdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiAhY29sdW1uLmdldElzVmlzaWJsZT8uKCkpXG5cbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zVmlzaWJsZSA9ICgpID0+XG4gICAgICB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGU/LigpKVxuXG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIChlOiB1bmtub3duKSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKFxuICAgICAgICAgICgoZSBhcyBNb3VzZUV2ZW50KS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCk/LmNoZWNrZWRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRWaXNpYmxlTGVhZkNvbHVtbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgcG9zaXRpb24/OiBDb2x1bW5QaW5uaW5nUG9zaXRpb24gfCAnY2VudGVyJ1xuKSB7XG4gIHJldHVybiAhcG9zaXRpb25cbiAgICA/IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpXG4gICAgOiBwb3NpdGlvbiA9PT0gJ2NlbnRlcidcbiAgICAgID8gdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zKClcbiAgICAgIDogcG9zaXRpb24gPT09ICdsZWZ0J1xuICAgICAgICA/IHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMoKVxuICAgICAgICA6IHRhYmxlLmdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zKClcbn1cbiIsImltcG9ydCB7IFJvd01vZGVsIH0gZnJvbSAnLi4nXG5pbXBvcnQgeyBUYWJsZSwgUm93RGF0YSwgVGFibGVGZWF0dXJlIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsRmFjZXRpbmdJbnN0YW5jZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXM/OiAoKSA9PiB1bmRlZmluZWQgfCBbbnVtYmVyLCBudW1iZXJdXG4gIF9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWw/OiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXM/OiAoKSA9PiBNYXA8YW55LCBudW1iZXI+XG4gIC8qKlxuICAgKiBDdXJyZW50bHksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgYnVpbHQtaW4gYGluY2x1ZGVzU3RyaW5nYCBmaWx0ZXIgZnVuY3Rpb24uIEluIGZ1dHVyZSByZWxlYXNlcywgaXQgbWF5IHJldHVybiBtb3JlIGR5bmFtaWMgZmlsdGVyIGZ1bmN0aW9ucyBiYXNlZCBvbiB0aGUgbmF0dXJlIG9mIHRoZSBkYXRhIHByb3ZpZGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1mYWNldGluZyNnZXRnbG9iYWxhdXRvZmlsdGVyZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmFjZXRpbmcpXG4gICAqL1xuICBnZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzOiAoKSA9PiB1bmRlZmluZWQgfCBbbnVtYmVyLCBudW1iZXJdXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZSBhZnRlciAqKmdsb2JhbCoqIGZpbHRlcmluZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1mYWNldGluZyNnZXRnbG9iYWxmYWNldGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmFjZXRpbmcpXG4gICAqL1xuICBnZXRHbG9iYWxGYWNldGVkUm93TW9kZWw6ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjZXRlZCB1bmlxdWUgdmFsdWVzIGZvciB0aGUgZ2xvYmFsIGZpbHRlci5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9nbG9iYWwtZmFjZXRpbmcjZ2V0Z2xvYmFsZmFjZXRlZHVuaXF1ZXZhbHVlcylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dsb2JhbC1mYWNldGluZylcbiAgICovXG4gIGdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXM6ICgpID0+IE1hcDxhbnksIG51bWJlcj5cbn1cblxuLy9cblxuZXhwb3J0IGNvbnN0IEdsb2JhbEZhY2V0aW5nOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9XG4gICAgICB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJlxuICAgICAgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsICdfX2dsb2JhbF9fJylcblxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKClcbiAgICB9XG5cbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9XG4gICAgICB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiZcbiAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKVxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKClcbiAgICB9XG5cbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9XG4gICAgICB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiZcbiAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKVxuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKVxuICAgIH1cbiAgfSxcbn1cbiIsImltcG9ydCB7IEZpbHRlckZuLCBGaWx0ZXJGbk9wdGlvbiB9IGZyb20gJy4uJ1xuaW1wb3J0IHsgQnVpbHRJbkZpbHRlckZuLCBmaWx0ZXJGbnMgfSBmcm9tICcuLi9maWx0ZXJGbnMnXG5pbXBvcnQge1xuICBDb2x1bW4sXG4gIE9uQ2hhbmdlRm4sXG4gIFRhYmxlLFxuICBVcGRhdGVyLFxuICBSb3dEYXRhLFxuICBUYWJsZUZlYXR1cmUsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFrZVN0YXRlVXBkYXRlciB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlclRhYmxlU3RhdGUge1xuICBnbG9iYWxGaWx0ZXI6IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlckNvbHVtbkRlZiB7XG4gIC8qKlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSAqKmdsb2JhbCoqIGZpbHRlciBmb3IgdGhpcyBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNlbmFibGVnbG9iYWxmaWx0ZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgZW5hYmxlR2xvYmFsRmlsdGVyPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdsb2JhbEZpbHRlckNvbHVtbiB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb2x1bW4gY2FuIGJlICoqZ2xvYmFsbHkqKiBmaWx0ZXJlZC4gU2V0IHRvIGBmYWxzZWAgdG8gZGlzYWJsZSBhIGNvbHVtbiBmcm9tIGJlaW5nIHNjYW5uZWQgZHVyaW5nIGdsb2JhbCBmaWx0ZXJpbmcuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNnZXRjYW5nbG9iYWxmaWx0ZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgZ2V0Q2FuR2xvYmFsRmlsdGVyOiAoKSA9PiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2xvYmFsRmlsdGVyT3B0aW9uczxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgKipnbG9iYWwqKiBmaWx0ZXJpbmcgZm9yIGFsbCBjb2x1bW5zLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1maWx0ZXJpbmcjZW5hYmxlZ2xvYmFsZmlsdGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ2xvYmFsLWZpbHRlcmluZylcbiAgICovXG4gIGVuYWJsZUdsb2JhbEZpbHRlcj86IGJvb2xlYW5cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGNvbHVtbiBhbmQgc2hvdWxkIHJldHVybiBgdHJ1ZWAgb3IgYGZhbHNlYCB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgY29sdW1uIHNob3VsZCBiZSB1c2VkIGZvciBnbG9iYWwgZmlsdGVyaW5nLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgY29sdW1uIGNhbiBjb250YWluIGRhdGEgdGhhdCBpcyBub3QgYHN0cmluZ2Agb3IgYG51bWJlcmAgKGkuZS4gYHVuZGVmaW5lZGApLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1maWx0ZXJpbmcjZ2V0Y29sdW1uY2FuZ2xvYmFsZmlsdGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZ2xvYmFsLWZpbHRlcmluZylcbiAgICovXG4gIGdldENvbHVtbkNhbkdsb2JhbEZpbHRlcj86IChjb2x1bW46IENvbHVtbjxURGF0YSwgdW5rbm93bj4pID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXIgZnVuY3Rpb24gdG8gdXNlIGZvciBnbG9iYWwgZmlsdGVyaW5nLlxuICAgKiAtIEEgYHN0cmluZ2AgcmVmZXJlbmNpbmcgYSBidWlsdC1pbiBmaWx0ZXIgZnVuY3Rpb25cbiAgICogLSBBIGBzdHJpbmdgIHRoYXQgcmVmZXJlbmNlcyBhIGN1c3RvbSBmaWx0ZXIgZnVuY3Rpb25zIHByb3ZpZGVkIHZpYSB0aGUgYHRhYmxlT3B0aW9ucy5maWx0ZXJGbnNgIG9wdGlvblxuICAgKiAtIEEgY3VzdG9tIGZpbHRlciBmdW5jdGlvblxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1maWx0ZXJpbmcjZ2xvYmFsZmlsdGVyZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgZ2xvYmFsRmlsdGVyRm4/OiBGaWx0ZXJGbk9wdGlvbjxURGF0YT5cbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYHVwZGF0ZXJGbmAgd2hlbiBgc3RhdGUuZ2xvYmFsRmlsdGVyYCBjaGFuZ2VzLiBUaGlzIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbnRlcm5hbCBzdGF0ZSBtYW5hZ2VtZW50LCBzbyB5b3Ugd2lsbCBuZWVkIHRvIHBlcnNpc3QgdGhlIHN0YXRlIGNoYW5nZSBlaXRoZXIgZnVsbHkgb3IgcGFydGlhbGx5IG91dHNpZGUgb2YgdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2dsb2JhbC1maWx0ZXJpbmcjb25nbG9iYWxmaWx0ZXJjaGFuZ2UpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U/OiBPbkNoYW5nZUZuPGFueT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBHbG9iYWxGaWx0ZXJJbnN0YW5jZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEN1cnJlbnRseSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBidWlsdC1pbiBgaW5jbHVkZXNTdHJpbmdgIGZpbHRlciBmdW5jdGlvbi4gSW4gZnV0dXJlIHJlbGVhc2VzLCBpdCBtYXkgcmV0dXJuIG1vcmUgZHluYW1pYyBmaWx0ZXIgZnVuY3Rpb25zIGJhc2VkIG9uIHRoZSBuYXR1cmUgb2YgdGhlIGRhdGEgcHJvdmlkZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNnZXRnbG9iYWxhdXRvZmlsdGVyZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgZ2V0R2xvYmFsQXV0b0ZpbHRlckZuOiAoKSA9PiBGaWx0ZXJGbjxURGF0YT4gfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbHRlciBmdW5jdGlvbiAoZWl0aGVyIHVzZXItZGVmaW5lZCBvciBhdXRvbWF0aWMsIGRlcGVuZGluZyBvbiBjb25maWd1cmF0aW9uKSBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNnZXRnbG9iYWxmaWx0ZXJmbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dsb2JhbC1maWx0ZXJpbmcpXG4gICAqL1xuICBnZXRHbG9iYWxGaWx0ZXJGbjogKCkgPT4gRmlsdGVyRm48VERhdGE+IHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlICoqZ2xvYmFsRmlsdGVyKiogc3RhdGUgdG8gYGluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXJgLCBvciBgdHJ1ZWAgY2FuIGJlIHBhc3NlZCB0byBmb3JjZSBhIGRlZmF1bHQgYmxhbmsgc3RhdGUgcmVzZXQgdG8gYHVuZGVmaW5lZGAuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNyZXNldGdsb2JhbGZpbHRlcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2dsb2JhbC1maWx0ZXJpbmcpXG4gICAqL1xuICByZXNldEdsb2JhbEZpbHRlcjogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgYHN0YXRlLmdsb2JhbEZpbHRlcmAgc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZ2xvYmFsLWZpbHRlcmluZyNzZXRnbG9iYWxmaWx0ZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9nbG9iYWwtZmlsdGVyaW5nKVxuICAgKi9cbiAgc2V0R2xvYmFsRmlsdGVyOiAodXBkYXRlcjogVXBkYXRlcjxhbnk+KSA9PiB2b2lkXG59XG5cbi8vXG5cbmV4cG9ydCBjb25zdCBHbG9iYWxGaWx0ZXJpbmc6IFRhYmxlRmVhdHVyZSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoc3RhdGUpOiBHbG9iYWxGaWx0ZXJUYWJsZVN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2xvYmFsRmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogR2xvYmFsRmlsdGVyT3B0aW9uczxURGF0YT4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkdsb2JhbEZpbHRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ2xvYmFsRmlsdGVyJywgdGFibGUpLFxuICAgICAgZ2xvYmFsRmlsdGVyRm46ICdhdXRvJyxcbiAgICAgIGdldENvbHVtbkNhbkdsb2JhbEZpbHRlcjogY29sdW1uID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0YWJsZVxuICAgICAgICAgIC5nZXRDb3JlUm93TW9kZWwoKVxuICAgICAgICAgIC5mbGF0Um93c1swXT8uX2dldEFsbENlbGxzQnlDb2x1bW5JZCgpXG4gICAgICAgICAgW2NvbHVtbi5pZF0/LmdldFZhbHVlKClcblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG4gICAgICB9LFxuICAgIH0gYXMgR2xvYmFsRmlsdGVyT3B0aW9uczxURGF0YT5cbiAgfSxcblxuICBjcmVhdGVDb2x1bW46IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIGNvbHVtbjogQ29sdW1uPFREYXRhLCB1bmtub3duPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHbG9iYWxGaWx0ZXIgPz8gdHJ1ZSkgJiZcbiAgICAgICAgKHRhYmxlLm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyID8/IHRydWUpICYmXG4gICAgICAgICh0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMgPz8gdHJ1ZSkgJiZcbiAgICAgICAgKHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyPy4oY29sdW1uKSA/PyB0cnVlKSAmJlxuICAgICAgICAhIWNvbHVtbi5hY2Nlc3NvckZuXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGZpbHRlckZucy5pbmNsdWRlc1N0cmluZ1xuICAgIH1cblxuICAgIHRhYmxlLmdldEdsb2JhbEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBnbG9iYWxGaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4gfSA9IHRhYmxlLm9wdGlvbnNcblxuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZ2xvYmFsRmlsdGVyRm4pXG4gICAgICAgID8gZ2xvYmFsRmlsdGVyRm5cbiAgICAgICAgOiBnbG9iYWxGaWx0ZXJGbiA9PT0gJ2F1dG8nXG4gICAgICAgICAgPyB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4oKVxuICAgICAgICAgIDogdGFibGUub3B0aW9ucy5maWx0ZXJGbnM/LltnbG9iYWxGaWx0ZXJGbiBhcyBzdHJpbmddID8/XG4gICAgICAgICAgICBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm4gYXMgQnVpbHRJbkZpbHRlckZuXVxuICAgIH1cblxuICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlciA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZT8uKHVwZGF0ZXIpXG4gICAgfVxuXG4gICAgdGFibGUucmVzZXRHbG9iYWxGaWx0ZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKFxuICAgICAgICBkZWZhdWx0U3RhdGUgPyB1bmRlZmluZWQgOiB0YWJsZS5pbml0aWFsU3RhdGUuZ2xvYmFsRmlsdGVyXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuIiwiaW1wb3J0IHsgUm93TW9kZWwgfSBmcm9tICcuLidcbmltcG9ydCB7XG4gIE9uQ2hhbmdlRm4sXG4gIFRhYmxlLFxuICBSb3csXG4gIFVwZGF0ZXIsXG4gIFJvd0RhdGEsXG4gIFRhYmxlRmVhdHVyZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBtYWtlU3RhdGVVcGRhdGVyIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCB0eXBlIEV4cGFuZGVkU3RhdGVMaXN0ID0gUmVjb3JkPHN0cmluZywgYm9vbGVhbj5cbmV4cG9ydCB0eXBlIEV4cGFuZGVkU3RhdGUgPSB0cnVlIHwgUmVjb3JkPHN0cmluZywgYm9vbGVhbj5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwYW5kZWRUYWJsZVN0YXRlIHtcbiAgZXhwYW5kZWQ6IEV4cGFuZGVkU3RhdGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBhbmRlZFJvdyB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJvdyBjYW4gYmUgZXhwYW5kZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2dldGNhbmV4cGFuZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIGdldENhbkV4cGFuZDogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGFsbCBwYXJlbnQgcm93cyBvZiB0aGUgcm93IGFyZSBleHBhbmRlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjZ2V0aXNhbGxwYXJlbnRzZXhwYW5kZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBnZXRJc0FsbFBhcmVudHNFeHBhbmRlZDogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb3cgaXMgZXhwYW5kZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2dldGlzZXhwYW5kZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBnZXRJc0V4cGFuZGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byB0b2dnbGUgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSByb3cuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gYmluZCB0byBhbiBldmVudCBoYW5kbGVyIHRvIGEgYnV0dG9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXR0b2dnbGVleHBhbmRlZGhhbmRsZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBnZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXI6ICgpID0+ICgpID0+IHZvaWRcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGV4cGFuZGVkIHN0YXRlIChvciBzZXRzIGl0IGlmIGBleHBhbmRlZGAgaXMgcHJvdmlkZWQpIGZvciB0aGUgcm93LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyN0b2dnbGVleHBhbmRlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIHRvZ2dsZUV4cGFuZGVkOiAoZXhwYW5kZWQ/OiBib29sZWFuKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwYW5kZWRPcHRpb25zPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogRW5hYmxlIHRoaXMgc2V0dGluZyB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgdGFibGUgd2hlbiBleHBhbmRpbmcgc3RhdGUgY2hhbmdlcy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjYXV0b3Jlc2V0ZXhwYW5kZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBhdXRvUmVzZXRFeHBhbmRlZD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIGV4cGFuZGluZyBmb3IgYWxsIHJvd3MuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2VuYWJsZWV4cGFuZGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIGVuYWJsZUV4cGFuZGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHJldHVybmluZyB0aGUgZXhwYW5kZWQgcm93IG1vZGVsLiBJZiB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlIHRhYmxlIHdpbGwgbm90IGV4cGFuZCByb3dzLiBZb3UgY2FuIHVzZSB0aGUgZGVmYXVsdCBleHBvcnRlZCBgZ2V0RXhwYW5kZWRSb3dNb2RlbGAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBleHBhbmRlZCByb3cgbW9kZWwgb3IgaW1wbGVtZW50IHlvdXIgb3duLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXRleHBhbmRlZHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgZ2V0RXhwYW5kZWRSb3dNb2RlbD86ICh0YWJsZTogVGFibGU8YW55PikgPT4gKCkgPT4gUm93TW9kZWw8YW55PlxuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHJvdyBpcyBjdXJyZW50bHkgZXhwYW5kZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2dldGlzcm93ZXhwYW5kZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBnZXRJc1Jvd0V4cGFuZGVkPzogKHJvdzogUm93PFREYXRhPikgPT4gYm9vbGVhblxuICAvKipcbiAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHJvdyBjYW4gYmUgZXhwYW5kZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2dldHJvd2NhbmV4cGFuZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIGdldFJvd0NhbkV4cGFuZD86IChyb3c6IFJvdzxURGF0YT4pID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIEVuYWJsZXMgbWFudWFsIHJvdyBleHBhbnNpb24uIElmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgYGdldEV4cGFuZGVkUm93TW9kZWxgIHdpbGwgbm90IGJlIHVzZWQgdG8gZXhwYW5kIHJvd3MgYW5kIHlvdSB3b3VsZCBiZSBleHBlY3RlZCB0byBwZXJmb3JtIHRoZSBleHBhbnNpb24gaW4geW91ciBvd24gZGF0YSBtb2RlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFyZSBkb2luZyBzZXJ2ZXItc2lkZSBleHBhbnNpb24uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI21hbnVhbGV4cGFuZGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIG1hbnVhbEV4cGFuZGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGBleHBhbmRlZGAgdGFibGUgc3RhdGUgY2hhbmdlcy4gSWYgYSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgeW91IHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHRoaXMgc3RhdGUgb24geW91ciBvd24uIFRvIHBhc3MgdGhlIG1hbmFnZWQgc3RhdGUgYmFjayB0byB0aGUgdGFibGUsIHVzZSB0aGUgYHRhYmxlT3B0aW9ucy5zdGF0ZS5leHBhbmRlZGAgb3B0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNvbmV4cGFuZGVkY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgb25FeHBhbmRlZENoYW5nZT86IE9uQ2hhbmdlRm48RXhwYW5kZWRTdGF0ZT5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCBleHBhbmRlZCByb3dzIHdpbGwgYmUgcGFnaW5hdGVkIGFsb25nIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHRhYmxlICh3aGljaCBtZWFucyBleHBhbmRlZCByb3dzIG1heSBzcGFuIG11bHRpcGxlIHBhZ2VzKS4gSWYgYGZhbHNlYCBleHBhbmRlZCByb3dzIHdpbGwgbm90IGJlIGNvbnNpZGVyZWQgZm9yIHBhZ2luYXRpb24gKHdoaWNoIG1lYW5zIGV4cGFuZGVkIHJvd3Mgd2lsbCBhbHdheXMgcmVuZGVyIG9uIHRoZWlyIHBhcmVudHMgcGFnZS4gVGhpcyBhbHNvIG1lYW5zIG1vcmUgcm93cyB3aWxsIGJlIHJlbmRlcmVkIHRoYW4gdGhlIHNldCBwYWdlIHNpemUpXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI3BhZ2luYXRlZXhwYW5kZWRyb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgcGFnaW5hdGVFeHBhbmRlZFJvd3M/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwYW5kZWRJbnN0YW5jZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgX2F1dG9SZXNldEV4cGFuZGVkOiAoKSA9PiB2b2lkXG4gIF9nZXRFeHBhbmRlZFJvd01vZGVsPzogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgYXJlIGFueSByb3dzIHRoYXQgY2FuIGJlIGV4cGFuZGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXRjYW5zb21lcm93c2V4cGFuZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIGdldENhblNvbWVSb3dzRXhwYW5kOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGRlcHRoIG9mIHRoZSBleHBhbmRlZCByb3dzLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXRleHBhbmRlZGRlcHRoKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgZ2V0RXhwYW5kZWREZXB0aDogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgYWZ0ZXIgZXhwYW5zaW9uIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvZXhwYW5kaW5nI2dldGV4cGFuZGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBnZXRFeHBhbmRlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbGwgcm93cyBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXRpc2FsbHJvd3NleHBhbmRlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIGdldElzQWxsUm93c0V4cGFuZGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgYXJlIGFueSByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBleHBhbmRlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjZ2V0aXNzb21lcm93c2V4cGFuZGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgZ2V0SXNTb21lUm93c0V4cGFuZGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgYmVmb3JlIGV4cGFuc2lvbiBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXRwcmVleHBhbmRlZHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFuZGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIHRvZ2dsZSB0aGUgZXhwYW5kZWQgc3RhdGUgb2YgYWxsIHJvd3MuIFRoaXMgaGFuZGxlciBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGggYW4gYGlucHV0W3R5cGU9Y2hlY2tib3hdYCBlbGVtZW50LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL2V4cGFuZGluZyNnZXR0b2dnbGVhbGxyb3dzZXhwYW5kZWRoYW5kbGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlcjogKCkgPT4gKGV2ZW50OiB1bmtub3duKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSB0YWJsZSB0byB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjcmVzZXRleHBhbmRlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL2V4cGFuZGluZylcbiAgICovXG4gIHJlc2V0RXhwYW5kZWQ6IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgdGFibGUgdmlhIGFuIHVwZGF0ZSBmdW5jdGlvbiBvciB2YWx1ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjc2V0ZXhwYW5kZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9leHBhbmRpbmcpXG4gICAqL1xuICBzZXRFeHBhbmRlZDogKHVwZGF0ZXI6IFVwZGF0ZXI8RXhwYW5kZWRTdGF0ZT4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGV4cGFuZGVkIHN0YXRlIGZvciBhbGwgcm93cy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9leHBhbmRpbmcjdG9nZ2xlYWxscm93c2V4cGFuZGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvZXhwYW5kaW5nKVxuICAgKi9cbiAgdG9nZ2xlQWxsUm93c0V4cGFuZGVkOiAoZXhwYW5kZWQ/OiBib29sZWFuKSA9PiB2b2lkXG59XG5cbi8vXG5cbmV4cG9ydCBjb25zdCBSb3dFeHBhbmRpbmc6IFRhYmxlRmVhdHVyZSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoc3RhdGUpOiBFeHBhbmRlZFRhYmxlU3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBleHBhbmRlZDoge30sXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogRXhwYW5kZWRPcHRpb25zPFREYXRhPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhwYW5kZWRDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2V4cGFuZGVkJywgdGFibGUpLFxuICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3M6IHRydWUsXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZVxuICAgIGxldCBxdWV1ZWQgPSBmYWxzZVxuXG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwgPz9cbiAgICAgICAgdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCA/P1xuICAgICAgICAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmdcbiAgICAgICkge1xuICAgICAgICBpZiAocXVldWVkKSByZXR1cm5cbiAgICAgICAgcXVldWVkID0gdHJ1ZVxuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKVxuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRhYmxlLnNldEV4cGFuZGVkID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2U/Lih1cGRhdGVyKVxuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIGlmIChleHBhbmRlZCA/PyAhdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQoKSkge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pXG4gICAgICB9XG4gICAgfVxuICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiB0YWJsZS5pbml0aWFsU3RhdGU/LmV4cGFuZGVkID8/IHt9KVxuICAgIH1cbiAgICB0YWJsZS5nZXRDYW5Tb21lUm93c0V4cGFuZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZVxuICAgICAgICAuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKClcbiAgICAgICAgLmZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5FeHBhbmQoKSlcbiAgICB9XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoZTogdW5rbm93bikgPT4ge1xuICAgICAgICA7KGUgYXMgYW55KS5wZXJzaXN0Py4oKVxuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKVxuICAgICAgfVxuICAgIH1cbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRcbiAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZSB8fCBPYmplY3QudmFsdWVzKGV4cGFuZGVkKS5zb21lKEJvb2xlYW4pXG4gICAgfVxuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkXG5cbiAgICAgIC8vIElmIGV4cGFuZGVkIGlzIHRydWUsIHNhdmUgc29tZSBjeWNsZXMgYW5kIHJldHVybiB0cnVlXG4gICAgICBpZiAodHlwZW9mIGV4cGFuZGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IHJvdyBpcyBub3QgZXhwYW5kZWQsIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHRhYmxlLmdldFJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gIXJvdy5nZXRJc0V4cGFuZGVkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBUaGV5IG11c3QgYWxsIGJlIGV4cGFuZGVkIDpzaHJ1ZzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHRhYmxlLmdldEV4cGFuZGVkRGVwdGggPSAoKSA9PiB7XG4gICAgICBsZXQgbWF4RGVwdGggPSAwXG5cbiAgICAgIGNvbnN0IHJvd0lkcyA9XG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWVcbiAgICAgICAgICA/IE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpXG4gICAgICAgICAgOiBPYmplY3Qua2V5cyh0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkKVxuXG4gICAgICByb3dJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIGNvbnN0IHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpXG4gICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIHNwbGl0SWQubGVuZ3RoKVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIG1heERlcHRoXG4gICAgfVxuICAgIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCgpXG4gICAgdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKHRhYmxlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcgfHwgIXRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKClcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlUm93OiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgICByb3c6IFJvdzxURGF0YT4sXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICByb3cudG9nZ2xlRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChvbGQgPT4ge1xuICAgICAgICBjb25zdCBleGlzdHMgPSBvbGQgPT09IHRydWUgPyB0cnVlIDogISFvbGQ/Lltyb3cuaWRdXG5cbiAgICAgICAgbGV0IG9sZEV4cGFuZGVkOiBFeHBhbmRlZFN0YXRlTGlzdCA9IHt9XG5cbiAgICAgICAgaWYgKG9sZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpLmZvckVhY2gocm93SWQgPT4ge1xuICAgICAgICAgICAgb2xkRXhwYW5kZWRbcm93SWRdID0gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkRXhwYW5kZWQgPSBvbGRcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGFuZGVkID0gZXhwYW5kZWQgPz8gIWV4aXN0c1xuXG4gICAgICAgIGlmICghZXhpc3RzICYmIGV4cGFuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9sZEV4cGFuZGVkLFxuICAgICAgICAgICAgW3Jvdy5pZF06IHRydWUsXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7IFtyb3cuaWRdOiBfLCAuLi5yZXN0IH0gPSBvbGRFeHBhbmRlZFxuICAgICAgICAgIHJldHVybiByZXN0XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2xkXG4gICAgICB9KVxuICAgIH1cbiAgICByb3cuZ2V0SXNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZFxuXG4gICAgICByZXR1cm4gISEoXG4gICAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZD8uKHJvdykgPz9cbiAgICAgICAgKGV4cGFuZGVkID09PSB0cnVlIHx8IGV4cGFuZGVkPy5bcm93LmlkXSlcbiAgICAgIClcbiAgICB9XG4gICAgcm93LmdldENhbkV4cGFuZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kPy4ocm93KSA/P1xuICAgICAgICAoKHRhYmxlLm9wdGlvbnMuZW5hYmxlRXhwYW5kaW5nID8/IHRydWUpICYmICEhcm93LnN1YlJvd3M/Lmxlbmd0aClcbiAgICAgIClcbiAgICB9XG4gICAgcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgbGV0IGlzRnVsbHlFeHBhbmRlZCA9IHRydWVcbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93XG5cbiAgICAgIHdoaWxlIChpc0Z1bGx5RXhwYW5kZWQgJiYgY3VycmVudFJvdy5wYXJlbnRJZCkge1xuICAgICAgICBjdXJyZW50Um93ID0gdGFibGUuZ2V0Um93KGN1cnJlbnRSb3cucGFyZW50SWQsIHRydWUpXG4gICAgICAgIGlzRnVsbHlFeHBhbmRlZCA9IGN1cnJlbnRSb3cuZ2V0SXNFeHBhbmRlZCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0Z1bGx5RXhwYW5kZWRcbiAgICB9XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkV4cGFuZCkgcmV0dXJuXG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuIiwiaW1wb3J0IHtcbiAgT25DaGFuZ2VGbixcbiAgVGFibGUsXG4gIFJvd01vZGVsLFxuICBVcGRhdGVyLFxuICBSb3dEYXRhLFxuICBUYWJsZUZlYXR1cmUsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHtcbiAgZnVuY3Rpb25hbFVwZGF0ZSxcbiAgZ2V0TWVtb09wdGlvbnMsXG4gIG1ha2VTdGF0ZVVwZGF0ZXIsXG4gIG1lbW8sXG59IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRpb25TdGF0ZSB7XG4gIHBhZ2VJbmRleDogbnVtYmVyXG4gIHBhZ2VTaXplOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uVGFibGVTdGF0ZSB7XG4gIHBhZ2luYXRpb246IFBhZ2luYXRpb25TdGF0ZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRpb25Jbml0aWFsVGFibGVTdGF0ZSB7XG4gIHBhZ2luYXRpb24/OiBQYXJ0aWFsPFBhZ2luYXRpb25TdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gYHRydWVgLCBwYWdpbmF0aW9uIHdpbGwgYmUgcmVzZXQgdG8gdGhlIGZpcnN0IHBhZ2Ugd2hlbiBwYWdlLWFsdGVyaW5nIHN0YXRlIGNoYW5nZXMgZWcuIGBkYXRhYCBpcyB1cGRhdGVkLCBmaWx0ZXJzIGNoYW5nZSwgZ3JvdXBpbmcgY2hhbmdlcywgZXRjLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jYXV0b3Jlc2V0cGFnZWluZGV4KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIGF1dG9SZXNldFBhZ2VJbmRleD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBhZnRlciBwYWdpbmF0aW9uIGhhcyB0YWtlbiBwbGFjZSwgYnV0IG5vIGZ1cnRoZXIuXG4gICAqXG4gICAqIFBhZ2luYXRpb24gY29sdW1ucyBhcmUgYXV0b21hdGljYWxseSByZW9yZGVyZWQgYnkgZGVmYXVsdCB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbHVtbnMgbGlzdC4gSWYgeW91IHdvdWxkIHJhdGhlciByZW1vdmUgdGhlbSBvciBsZWF2ZSB0aGVtIGFzLWlzLCBzZXQgdGhlIGFwcHJvcHJpYXRlIG1vZGUgaGVyZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2dldHBhZ2luYXRpb25yb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBnZXRQYWdpbmF0aW9uUm93TW9kZWw/OiAodGFibGU6IFRhYmxlPGFueT4pID0+ICgpID0+IFJvd01vZGVsPGFueT5cbiAgLyoqXG4gICAqIEVuYWJsZXMgbWFudWFsIHBhZ2luYXRpb24uIElmIHRoaXMgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAsIHRoZSB0YWJsZSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHBhZ2luYXRlIHJvd3MgdXNpbmcgYGdldFBhZ2luYXRpb25Sb3dNb2RlbCgpYCBhbmQgaW5zdGVhZCB3aWxsIGV4cGVjdCB5b3UgdG8gbWFudWFsbHkgcGFnaW5hdGUgdGhlIHJvd3MgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byB0aGUgdGFibGUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhcmUgZG9pbmcgc2VydmVyLXNpZGUgcGFnaW5hdGlvbiBhbmQgYWdncmVnYXRpb24uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNtYW51YWxwYWdpbmF0aW9uKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIG1hbnVhbFBhZ2luYXRpb24/OiBib29sZWFuXG4gIC8qKlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwYWdpbmF0aW9uIHN0YXRlIGNoYW5nZXMgYW5kIHlvdSB3aWxsIGJlIGV4cGVjdGVkIHRvIG1hbmFnZSB0aGUgc3RhdGUgeW91cnNlbGYuIFlvdSBjYW4gcGFzcyB0aGUgbWFuYWdlZCBzdGF0ZSBiYWNrIHRvIHRoZSB0YWJsZSB2aWEgdGhlIGB0YWJsZU9wdGlvbnMuc3RhdGUucGFnaW5hdGlvbmAgb3B0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jb25wYWdpbmF0aW9uY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIG9uUGFnaW5hdGlvbkNoYW5nZT86IE9uQ2hhbmdlRm48UGFnaW5hdGlvblN0YXRlPlxuICAvKipcbiAgICogV2hlbiBtYW51YWxseSBjb250cm9sbGluZyBwYWdpbmF0aW9uLCB5b3UgY2FuIHN1cHBseSBhIHRvdGFsIGBwYWdlQ291bnRgIHZhbHVlIHRvIHRoZSB0YWJsZSBpZiB5b3Uga25vdyBpdCAoT3Igc3VwcGx5IGEgYHJvd0NvdW50YCBhbmQgYHBhZ2VDb3VudGAgd2lsbCBiZSBjYWxjdWxhdGVkKS4gSWYgeW91IGRvIG5vdCBrbm93IGhvdyBtYW55IHBhZ2VzIHRoZXJlIGFyZSwgeW91IGNhbiBzZXQgdGhpcyB0byBgLTFgLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jcGFnZWNvdW50KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIHBhZ2VDb3VudD86IG51bWJlclxuICAvKipcbiAgICogV2hlbiBtYW51YWxseSBjb250cm9sbGluZyBwYWdpbmF0aW9uLCB5b3UgY2FuIHN1cHBseSBhIHRvdGFsIGByb3dDb3VudGAgdmFsdWUgdG8gdGhlIHRhYmxlIGlmIHlvdSBrbm93IGl0LiBUaGUgYHBhZ2VDb3VudGAgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGlzIHZhbHVlIGFuZCB0aGUgYHBhZ2VTaXplYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI3Jvd2NvdW50KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIHJvd0NvdW50PzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGlvbkRlZmF1bHRPcHRpb25zIHtcbiAgb25QYWdpbmF0aW9uQ2hhbmdlOiBPbkNoYW5nZUZuPFBhZ2luYXRpb25TdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0aW9uSW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIF9hdXRvUmVzZXRQYWdlSW5kZXg6ICgpID0+IHZvaWRcbiAgX2dldFBhZ2luYXRpb25Sb3dNb2RlbD86ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0YWJsZSBjYW4gZ28gdG8gdGhlIG5leHQgcGFnZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2dldGNhbm5leHRwYWdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIGdldENhbk5leHRQYWdlOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHRhYmxlIGNhbiBnbyB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2dldGNhbnByZXZpb3VzcGFnZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBnZXRDYW5QcmV2aW91c1BhZ2U6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhZ2UgY291bnQuIElmIG1hbnVhbGx5IHBhZ2luYXRpbmcgb3IgY29udHJvbGxpbmcgdGhlIHBhZ2luYXRpb24gc3RhdGUsIHRoaXMgd2lsbCBjb21lIGRpcmVjdGx5IGZyb20gdGhlIGBvcHRpb25zLnBhZ2VDb3VudGAgdGFibGUgb3B0aW9uLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHRhYmxlIGRhdGEgdXNpbmcgdGhlIHRvdGFsIHJvdyBjb3VudCBhbmQgY3VycmVudCBwYWdlIHNpemUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNnZXRwYWdlY291bnQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgZ2V0UGFnZUNvdW50OiAoKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBjb3VudC4gSWYgbWFudWFsbHkgcGFnaW5hdGluZyBvciBjb250cm9sbGluZyB0aGUgcGFnaW5hdGlvbiBzdGF0ZSwgdGhpcyB3aWxsIGNvbWUgZGlyZWN0bHkgZnJvbSB0aGUgYG9wdGlvbnMucm93Q291bnRgIHRhYmxlIG9wdGlvbiwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB0YWJsZSBkYXRhLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jZ2V0cm93Y291bnQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgZ2V0Um93Q291bnQ6ICgpID0+IG51bWJlclxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwYWdlIG9wdGlvbnMgKHplcm8taW5kZXgtYmFzZWQpIGZvciB0aGUgY3VycmVudCBwYWdlIHNpemUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNnZXRwYWdlb3B0aW9ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBnZXRQYWdlT3B0aW9uczogKCkgPT4gbnVtYmVyW11cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBmb3IgdGhlIHRhYmxlIGFmdGVyIHBhZ2luYXRpb24gaGFzIGJlZW4gYXBwbGllZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2dldHBhZ2luYXRpb25yb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBnZXRQYWdpbmF0aW9uUm93TW9kZWw6ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93IG1vZGVsIGZvciB0aGUgdGFibGUgYmVmb3JlIGFueSBwYWdpbmF0aW9uIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNnZXRwcmVwYWdpbmF0aW9ucm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIHBhZ2UgaW5kZXggYnkgb25lLCBpZiBwb3NzaWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI25leHRwYWdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIG5leHRQYWdlOiAoKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBEZWNyZW1lbnRzIHRoZSBwYWdlIGluZGV4IGJ5IG9uZSwgaWYgcG9zc2libGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNwcmV2aW91c3BhZ2UpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgcHJldmlvdXNQYWdlOiAoKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYWdlIGluZGV4IHRvIGAwYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2ZpcnN0cGFnZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBmaXJzdFBhZ2U6ICgpID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhZ2UgaW5kZXggdG8gdGhlIGxhc3QgcGFnZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI2xhc3RwYWdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIGxhc3RQYWdlOiAoKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBhZ2UgaW5kZXggdG8gaXRzIGluaXRpYWwgc3RhdGUuIElmIGBkZWZhdWx0U3RhdGVgIGlzIGB0cnVlYCwgdGhlIHBhZ2UgaW5kZXggd2lsbCBiZSByZXNldCB0byBgMGAgcmVnYXJkbGVzcyBvZiBpbml0aWFsIHN0YXRlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jcmVzZXRwYWdlaW5kZXgpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgcmVzZXRQYWdlSW5kZXg6IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBhZ2Ugc2l6ZSB0byBpdHMgaW5pdGlhbCBzdGF0ZS4gSWYgYGRlZmF1bHRTdGF0ZWAgaXMgYHRydWVgLCB0aGUgcGFnZSBzaXplIHdpbGwgYmUgcmVzZXQgdG8gYDEwYCByZWdhcmRsZXNzIG9mIGluaXRpYWwgc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcGFnaW5hdGlvbiNyZXNldHBhZ2VzaXplKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIHJlc2V0UGFnZVNpemU6IChkZWZhdWx0U3RhdGU/OiBib29sZWFuKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlICoqcGFnaW5hdGlvbioqIHN0YXRlIHRvIGBpbml0aWFsU3RhdGUucGFnaW5hdGlvbmAsIG9yIGB0cnVlYCBjYW4gYmUgcGFzc2VkIHRvIGZvcmNlIGEgZGVmYXVsdCBibGFuayBzdGF0ZSByZXNldCB0byBgW11gLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3BhZ2luYXRpb24jcmVzZXRwYWdpbmF0aW9uKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIHJlc2V0UGFnaW5hdGlvbjogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBwYWdlIGNvdW50IG5vIGxvbmdlciBleGlzdHMgaW4gdGhlIHBhZ2luYXRpb24gc3RhdGUuIEp1c3QgcGFzcyBhcyBhIHRhYmxlIG9wdGlvbiBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0UGFnZUNvdW50OiAodXBkYXRlcjogVXBkYXRlcjxudW1iZXI+KSA9PiB2b2lkXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBwYWdlIGluZGV4IHVzaW5nIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBvciB2YWx1ZSBpbiB0aGUgYHN0YXRlLnBhZ2luYXRpb24ucGFnZUluZGV4YCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI3NldHBhZ2VpbmRleClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3BhZ2luYXRpb24pXG4gICAqL1xuICBzZXRQYWdlSW5kZXg6ICh1cGRhdGVyOiBVcGRhdGVyPG51bWJlcj4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHBhZ2Ugc2l6ZSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb3IgdmFsdWUgaW4gdGhlIGBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2VTaXplYCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI3NldHBhZ2VzaXplKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcGFnaW5hdGlvbilcbiAgICovXG4gIHNldFBhZ2VTaXplOiAodXBkYXRlcjogVXBkYXRlcjxudW1iZXI+KSA9PiB2b2lkXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgdGhlIGBzdGF0ZS5wYWdpbmF0aW9uYCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9wYWdpbmF0aW9uI3NldHBhZ2luYXRpb24pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9wYWdpbmF0aW9uKVxuICAgKi9cbiAgc2V0UGFnaW5hdGlvbjogKHVwZGF0ZXI6IFVwZGF0ZXI8UGFnaW5hdGlvblN0YXRlPikgPT4gdm9pZFxufVxuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMFxuY29uc3QgZGVmYXVsdFBhZ2VTaXplID0gMTBcblxuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpOiBQYWdpbmF0aW9uU3RhdGUgPT4gKHtcbiAgcGFnZUluZGV4OiBkZWZhdWx0UGFnZUluZGV4LFxuICBwYWdlU2l6ZTogZGVmYXVsdFBhZ2VTaXplLFxufSlcblxuZXhwb3J0IGNvbnN0IFJvd1BhZ2luYXRpb246IFRhYmxlRmVhdHVyZSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoc3RhdGUpOiBQYWdpbmF0aW9uVGFibGVTdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAuLi5nZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCksXG4gICAgICAgIC4uLnN0YXRlPy5wYWdpbmF0aW9uLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogUGFnaW5hdGlvbkRlZmF1bHRPcHRpb25zID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25QYWdpbmF0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdwYWdpbmF0aW9uJywgdGFibGUpLFxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVUYWJsZTogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4odGFibGU6IFRhYmxlPFREYXRhPik6IHZvaWQgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2VcbiAgICBsZXQgcXVldWVkID0gZmFsc2VcblxuICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXggPSAoKSA9PiB7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCA/P1xuICAgICAgICB0YWJsZS5vcHRpb25zLmF1dG9SZXNldFBhZ2VJbmRleCA/P1xuICAgICAgICAhdGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuXG4gICAgICAgIHF1ZXVlZCA9IHRydWVcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCgpXG4gICAgICAgICAgcXVldWVkID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXI6IFVwZGF0ZXI8UGFnaW5hdGlvblN0YXRlPiA9IG9sZCA9PiB7XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKVxuXG4gICAgICAgIHJldHVybiBuZXdTdGF0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2U/LihzYWZlVXBkYXRlcilcbiAgICB9XG4gICAgdGFibGUucmVzZXRQYWdpbmF0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24oXG4gICAgICAgIGRlZmF1bHRTdGF0ZVxuICAgICAgICAgID8gZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpXG4gICAgICAgICAgOiB0YWJsZS5pbml0aWFsU3RhdGUucGFnaW5hdGlvbiA/PyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKClcbiAgICAgIClcbiAgICB9XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpXG5cbiAgICAgICAgY29uc3QgbWF4UGFnZUluZGV4ID1cbiAgICAgICAgICB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09IC0xXG4gICAgICAgICAgICA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICA6IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50IC0gMVxuXG4gICAgICAgIHBhZ2VJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VJbmRleCwgbWF4UGFnZUluZGV4KSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXgsXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2VJbmRleChcbiAgICAgICAgZGVmYXVsdFN0YXRlXG4gICAgICAgICAgPyBkZWZhdWx0UGFnZUluZGV4XG4gICAgICAgICAgOiB0YWJsZS5pbml0aWFsU3RhdGU/LnBhZ2luYXRpb24/LnBhZ2VJbmRleCA/PyBkZWZhdWx0UGFnZUluZGV4XG4gICAgICApXG4gICAgfVxuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoXG4gICAgICAgIGRlZmF1bHRTdGF0ZVxuICAgICAgICAgID8gZGVmYXVsdFBhZ2VTaXplXG4gICAgICAgICAgOiB0YWJsZS5pbml0aWFsU3RhdGU/LnBhZ2luYXRpb24/LnBhZ2VTaXplID8/IGRlZmF1bHRQYWdlU2l6ZVxuICAgICAgKVxuICAgIH1cbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSlcbiAgICAgICAgY29uc3QgdG9wUm93SW5kZXggPSBvbGQucGFnZVNpemUgKiBvbGQucGFnZUluZGV4IVxuICAgICAgICBjb25zdCBwYWdlSW5kZXggPSBNYXRoLmZsb29yKHRvcFJvd0luZGV4IC8gcGFnZVNpemUpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICAvL2RlcHJlY2F0ZWRcbiAgICB0YWJsZS5zZXRQYWdlQ291bnQgPSB1cGRhdGVyID0+XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKFxuICAgICAgICAgIHVwZGF0ZXIsXG4gICAgICAgICAgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPz8gLTFcbiAgICAgICAgKVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG5ld1BhZ2VDb3VudCA9IE1hdGgubWF4KC0xLCBuZXdQYWdlQ291bnQpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlQ291bnQ6IG5ld1BhZ2VDb3VudCxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIHRhYmxlLmdldFBhZ2VPcHRpb25zID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sXG4gICAgICBwYWdlQ291bnQgPT4ge1xuICAgICAgICBsZXQgcGFnZU9wdGlvbnM6IG51bWJlcltdID0gW11cbiAgICAgICAgaWYgKHBhZ2VDb3VudCAmJiBwYWdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgcGFnZU9wdGlvbnMgPSBbLi4ubmV3IEFycmF5KHBhZ2VDb3VudCldLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiBpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWdlT3B0aW9uc1xuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFBhZ2VPcHRpb25zJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRDYW5QcmV2aW91c1BhZ2UgPSAoKSA9PiB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMFxuXG4gICAgdGFibGUuZ2V0Q2FuTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHBhZ2VJbmRleCB9ID0gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uXG5cbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpXG5cbiAgICAgIGlmIChwYWdlQ291bnQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxXG4gICAgfVxuXG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4gb2xkIC0gMSlcbiAgICB9XG5cbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IHtcbiAgICAgICAgcmV0dXJuIG9sZCArIDFcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGFibGUuZmlyc3RQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleCgwKVxuICAgIH1cblxuICAgIHRhYmxlLmxhc3RQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleCh0YWJsZS5nZXRQYWdlQ291bnQoKSAtIDEpXG4gICAgfVxuXG4gICAgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCgpXG4gICAgdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJlxuICAgICAgICB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbFxuICAgICAgKSB7XG4gICAgICAgIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPVxuICAgICAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKHRhYmxlKVxuICAgICAgfVxuXG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uIHx8ICF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCgpXG4gICAgfVxuXG4gICAgdGFibGUuZ2V0UGFnZUNvdW50ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPz9cbiAgICAgICAgTWF0aC5jZWlsKHRhYmxlLmdldFJvd0NvdW50KCkgLyB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZVNpemUpXG4gICAgICApXG4gICAgfVxuXG4gICAgdGFibGUuZ2V0Um93Q291bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0YWJsZS5vcHRpb25zLnJvd0NvdW50ID8/IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuIiwiaW1wb3J0IHtcbiAgT25DaGFuZ2VGbixcbiAgVXBkYXRlcixcbiAgVGFibGUsXG4gIFJvdyxcbiAgUm93RGF0YSxcbiAgVGFibGVGZWF0dXJlLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCB0eXBlIFJvd1Bpbm5pbmdQb3NpdGlvbiA9IGZhbHNlIHwgJ3RvcCcgfCAnYm90dG9tJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvd1Bpbm5pbmdTdGF0ZSB7XG4gIGJvdHRvbT86IHN0cmluZ1tdXG4gIHRvcD86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm93UGlubmluZ1RhYmxlU3RhdGUge1xuICByb3dQaW5uaW5nOiBSb3dQaW5uaW5nU3RhdGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3dQaW5uaW5nT3B0aW9uczxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvZGlzYWJsZXMgcm93IHBpbm5pbmcgZm9yIHRoZSB0YWJsZS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1waW5uaW5nI2VuYWJsZXJvd3Bpbm5pbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctcGlubmluZylcbiAgICovXG4gIGVuYWJsZVJvd1Bpbm5pbmc/OiBib29sZWFuIHwgKChyb3c6IFJvdzxURGF0YT4pID0+IGJvb2xlYW4pXG4gIC8qKlxuICAgKiBXaGVuIGBmYWxzZWAsIHBpbm5lZCByb3dzIHdpbGwgbm90IGJlIHZpc2libGUgaWYgdGhleSBhcmUgZmlsdGVyZWQgb3IgcGFnaW5hdGVkIG91dCBvZiB0aGUgdGFibGUuIFdoZW4gYHRydWVgLCBwaW5uZWQgcm93cyB3aWxsIGFsd2F5cyBiZSB2aXNpYmxlIHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nIG9yIHBhZ2luYXRpb24uIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctcGlubmluZyNrZWVwcGlubmVkcm93cylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1waW5uaW5nKVxuICAgKi9cbiAga2VlcFBpbm5lZFJvd3M/OiBib29sZWFuXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVyRm5gIHdoZW4gYHN0YXRlLnJvd1Bpbm5pbmdgIGNoYW5nZXMuIFRoaXMgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGludGVybmFsIHN0YXRlIG1hbmFnZW1lbnQsIHNvIHlvdSB3aWxsIGFsc28gbmVlZCB0byBzdXBwbHkgYHN0YXRlLnJvd1Bpbm5pbmdgIGZyb20geW91ciBvd24gbWFuYWdlZCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctcGlubmluZyNvbnJvd3Bpbm5pbmdjaGFuZ2UpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9vbnJvd3Bpbm5pbmdjaGFuZ2UpXG4gICAqL1xuICBvblJvd1Bpbm5pbmdDaGFuZ2U/OiBPbkNoYW5nZUZuPFJvd1Bpbm5pbmdTdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3dQaW5uaW5nRGVmYXVsdE9wdGlvbnMge1xuICBvblJvd1Bpbm5pbmdDaGFuZ2U6IE9uQ2hhbmdlRm48Um93UGlubmluZ1N0YXRlPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvd1Bpbm5pbmdSb3cge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcm93IGNhbiBiZSBwaW5uZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXBpbm5pbmcjZ2V0Y2FucGluLTEpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctcGlubmluZylcbiAgICovXG4gIGdldENhblBpbjogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlubmVkIHBvc2l0aW9uIG9mIHRoZSByb3cuIChgJ3RvcCdgLCBgJ2JvdHRvbSdgIG9yIGBmYWxzZWApXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXBpbm5pbmcjZ2V0aXNwaW5uZWQtMSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1waW5uaW5nKVxuICAgKi9cbiAgZ2V0SXNQaW5uZWQ6ICgpID0+IFJvd1Bpbm5pbmdQb3NpdGlvblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtZXJpYyBwaW5uZWQgaW5kZXggb2YgdGhlIHJvdyB3aXRoaW4gYSBwaW5uZWQgcm93IGdyb3VwLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1waW5uaW5nI2dldHBpbm5lZGluZGV4LTEpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctcGlubmluZylcbiAgICovXG4gIGdldFBpbm5lZEluZGV4OiAoKSA9PiBudW1iZXJcbiAgLyoqXG4gICAqIFBpbnMgYSByb3cgdG8gdGhlIGAndG9wJ2Agb3IgYCdib3R0b20nYCwgb3IgdW5waW5zIHRoZSByb3cgdG8gdGhlIGNlbnRlciBpZiBgZmFsc2VgIGlzIHBhc3NlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctcGlubmluZyNwaW4tMSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1waW5uaW5nKVxuICAgKi9cbiAgcGluOiAoXG4gICAgcG9zaXRpb246IFJvd1Bpbm5pbmdQb3NpdGlvbixcbiAgICBpbmNsdWRlTGVhZlJvd3M/OiBib29sZWFuLFxuICAgIGluY2x1ZGVQYXJlbnRSb3dzPzogYm9vbGVhblxuICApID0+IHZvaWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3dQaW5uaW5nSW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIF9nZXRQaW5uZWRSb3dzOiAoXG4gICAgdmlzaWJsZVBpbm5lZFJvd3M6IEFycmF5PFJvdzxURGF0YT4+LFxuICAgIHBpbm5lZFJvd0lkczogQXJyYXk8c3RyaW5nPiB8IHVuZGVmaW5lZCxcbiAgICBwb3NpdGlvbjogJ3RvcCcgfCAnYm90dG9tJ1xuICApID0+IFJvdzxURGF0YT5bXVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYm90dG9tIHBpbm5lZCByb3dzLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1waW5uaW5nI2dldGJvdHRvbXJvd3MpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctcGlubmluZylcbiAgICovXG4gIGdldEJvdHRvbVJvd3M6ICgpID0+IFJvdzxURGF0YT5bXVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcm93cyB0aGF0IGFyZSBub3QgcGlubmVkIHRvIHRoZSB0b3Agb3IgYm90dG9tLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1waW5uaW5nI2dldGNlbnRlcnJvd3MpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctcGlubmluZylcbiAgICovXG4gIGdldENlbnRlclJvd3M6ICgpID0+IFJvdzxURGF0YT5bXVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbnkgcm93cyBhcmUgcGlubmVkLiBPcHRpb25hbGx5IHNwZWNpZnkgdG8gb25seSBjaGVjayBmb3IgcGlubmVkIHJvd3MgaW4gZWl0aGVyIHRoZSBgdG9wYCBvciBgYm90dG9tYCBwb3NpdGlvbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctcGlubmluZyNnZXRpc3NvbWVyb3dzcGlubmVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXBpbm5pbmcpXG4gICAqL1xuICBnZXRJc1NvbWVSb3dzUGlubmVkOiAocG9zaXRpb24/OiBSb3dQaW5uaW5nUG9zaXRpb24pID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRvcCBwaW5uZWQgcm93cy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctcGlubmluZyNnZXR0b3Byb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXBpbm5pbmcpXG4gICAqL1xuICBnZXRUb3BSb3dzOiAoKSA9PiBSb3c8VERhdGE+W11cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgKipyb3dQaW5uaW5nKiogc3RhdGUgdG8gYGluaXRpYWxTdGF0ZS5yb3dQaW5uaW5nYCwgb3IgYHRydWVgIGNhbiBiZSBwYXNzZWQgdG8gZm9yY2UgYSBkZWZhdWx0IGJsYW5rIHN0YXRlIHJlc2V0IHRvIGB7IHRvcDogW10sIGJvdHRvbTogW10sIH1gLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1waW5uaW5nI3Jlc2V0cm93cGlubmluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1waW5uaW5nKVxuICAgKi9cbiAgcmVzZXRSb3dQaW5uaW5nOiAoZGVmYXVsdFN0YXRlPzogYm9vbGVhbikgPT4gdm9pZFxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBgc3RhdGUucm93UGlubmluZ2Agc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXBpbm5pbmcjc2V0cm93cGlubmluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1waW5uaW5nKVxuICAgKi9cbiAgc2V0Um93UGlubmluZzogKHVwZGF0ZXI6IFVwZGF0ZXI8Um93UGlubmluZ1N0YXRlPikgPT4gdm9pZFxufVxuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlID0gKCk6IFJvd1Bpbm5pbmdTdGF0ZSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdLFxufSlcblxuZXhwb3J0IGNvbnN0IFJvd1Bpbm5pbmc6IFRhYmxlRmVhdHVyZSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiAoc3RhdGUpOiBSb3dQaW5uaW5nVGFibGVTdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1Bpbm5pbmc6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSxcbiAgICAgIC4uLnN0YXRlLFxuICAgIH1cbiAgfSxcblxuICBnZXREZWZhdWx0T3B0aW9uczogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiBSb3dQaW5uaW5nRGVmYXVsdE9wdGlvbnMgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblJvd1Bpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1Bpbm5pbmcnLCB0YWJsZSksXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVJvdzogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gICAgcm93OiBSb3c8VERhdGE+LFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogdm9pZCA9PiB7XG4gICAgcm93LnBpbiA9IChwb3NpdGlvbiwgaW5jbHVkZUxlYWZSb3dzLCBpbmNsdWRlUGFyZW50Um93cykgPT4ge1xuICAgICAgY29uc3QgbGVhZlJvd0lkcyA9IGluY2x1ZGVMZWFmUm93c1xuICAgICAgICA/IHJvdy5nZXRMZWFmUm93cygpLm1hcCgoeyBpZCB9KSA9PiBpZClcbiAgICAgICAgOiBbXVxuICAgICAgY29uc3QgcGFyZW50Um93SWRzID0gaW5jbHVkZVBhcmVudFJvd3NcbiAgICAgICAgPyByb3cuZ2V0UGFyZW50Um93cygpLm1hcCgoeyBpZCB9KSA9PiBpZClcbiAgICAgICAgOiBbXVxuICAgICAgY29uc3Qgcm93SWRzID0gbmV3IFNldChbLi4ucGFyZW50Um93SWRzLCByb3cuaWQsIC4uLmxlYWZSb3dJZHNdKVxuXG4gICAgICB0YWJsZS5zZXRSb3dQaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiAob2xkPy50b3AgPz8gW10pLmZpbHRlcihkID0+ICFyb3dJZHM/LmhhcyhkKSksXG4gICAgICAgICAgICBib3R0b206IFtcbiAgICAgICAgICAgICAgLi4uKG9sZD8uYm90dG9tID8/IFtdKS5maWx0ZXIoZCA9PiAhcm93SWRzPy5oYXMoZCkpLFxuICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKHJvd0lkcyksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBbXG4gICAgICAgICAgICAgIC4uLihvbGQ/LnRvcCA/PyBbXSkuZmlsdGVyKGQgPT4gIXJvd0lkcz8uaGFzKGQpKSxcbiAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShyb3dJZHMpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGJvdHRvbTogKG9sZD8uYm90dG9tID8/IFtdKS5maWx0ZXIoZCA9PiAhcm93SWRzPy5oYXMoZCkpLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiAob2xkPy50b3AgPz8gW10pLmZpbHRlcihkID0+ICFyb3dJZHM/LmhhcyhkKSksXG4gICAgICAgICAgYm90dG9tOiAob2xkPy5ib3R0b20gPz8gW10pLmZpbHRlcihkID0+ICFyb3dJZHM/LmhhcyhkKSksXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHJvdy5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IGVuYWJsZVJvd1Bpbm5pbmcsIGVuYWJsZVBpbm5pbmcgfSA9IHRhYmxlLm9wdGlvbnNcbiAgICAgIGlmICh0eXBlb2YgZW5hYmxlUm93UGlubmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyhyb3cpXG4gICAgICB9XG4gICAgICByZXR1cm4gZW5hYmxlUm93UGlubmluZyA/PyBlbmFibGVQaW5uaW5nID8/IHRydWVcbiAgICB9XG4gICAgcm93LmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qgcm93SWRzID0gW3Jvdy5pZF1cblxuICAgICAgY29uc3QgeyB0b3AsIGJvdHRvbSB9ID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nXG5cbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3A/LmluY2x1ZGVzKGQpKVxuICAgICAgY29uc3QgaXNCb3R0b20gPSByb3dJZHMuc29tZShkID0+IGJvdHRvbT8uaW5jbHVkZXMoZCkpXG5cbiAgICAgIHJldHVybiBpc1RvcCA/ICd0b3AnIDogaXNCb3R0b20gPyAnYm90dG9tJyA6IGZhbHNlXG4gICAgfVxuICAgIHJvdy5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcm93LmdldElzUGlubmVkKClcbiAgICAgIGlmICghcG9zaXRpb24pIHJldHVybiAtMVxuXG4gICAgICBjb25zdCB2aXNpYmxlUGlubmVkUm93SWRzID0gKFxuICAgICAgICBwb3NpdGlvbiA9PT0gJ3RvcCcgPyB0YWJsZS5nZXRUb3BSb3dzKCkgOiB0YWJsZS5nZXRCb3R0b21Sb3dzKClcbiAgICAgICk/Lm1hcCgoeyBpZCB9KSA9PiBpZClcblxuICAgICAgcmV0dXJuIHZpc2libGVQaW5uZWRSb3dJZHM/LmluZGV4T2Yocm93LmlkKSA/PyAtMVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVUYWJsZTogPFREYXRhIGV4dGVuZHMgUm93RGF0YT4odGFibGU6IFRhYmxlPFREYXRhPik6IHZvaWQgPT4ge1xuICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlPy4odXBkYXRlcilcblxuICAgIHRhYmxlLnJlc2V0Um93UGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PlxuICAgICAgdGFibGUuc2V0Um93UGlubmluZyhcbiAgICAgICAgZGVmYXVsdFN0YXRlXG4gICAgICAgICAgPyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKClcbiAgICAgICAgICA6IHRhYmxlLmluaXRpYWxTdGF0ZT8ucm93UGlubmluZyA/PyBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKClcbiAgICAgIClcblxuICAgIHRhYmxlLmdldElzU29tZVJvd3NQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmdcblxuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwaW5uaW5nU3RhdGUudG9wPy5sZW5ndGggfHwgcGlubmluZ1N0YXRlLmJvdHRvbT8ubGVuZ3RoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4ocGlubmluZ1N0YXRlW3Bvc2l0aW9uXT8ubGVuZ3RoKVxuICAgIH1cblxuICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzID0gKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMsIHBvc2l0aW9uKSA9PiB7XG4gICAgICBjb25zdCByb3dzID1cbiAgICAgICAgdGFibGUub3B0aW9ucy5rZWVwUGlubmVkUm93cyA/PyB0cnVlXG4gICAgICAgICAgPyAvL2dldCBhbGwgcm93cyB0aGF0IGFyZSBwaW5uZWQgZXZlbiBpZiB0aGV5IHdvdWxkIG5vdCBiZSBvdGhlcndpc2UgdmlzaWJsZVxuICAgICAgICAgICAgLy9hY2NvdW50IGZvciBleHBhbmRlZCBwYXJlbnQgcm93cywgYnV0IG5vdCBwYWdpbmF0aW9uIG9yIGZpbHRlcmluZ1xuICAgICAgICAgICAgKHBpbm5lZFJvd0lkcyA/PyBbXSkubWFwKHJvd0lkID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkLCB0cnVlKVxuICAgICAgICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgICAgICAgIChwaW5uZWRSb3dJZHMgPz8gW10pLm1hcChcbiAgICAgICAgICAgICAgcm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkhXG4gICAgICAgICAgICApXG5cbiAgICAgIHJldHVybiByb3dzLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoeyAuLi5kLCBwb3NpdGlvbiB9KSkgYXMgUm93PFREYXRhPltdXG4gICAgfVxuXG4gICAgdGFibGUuZ2V0VG9wUm93cyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcudG9wXSxcbiAgICAgIChhbGxSb3dzLCB0b3BQaW5uZWRSb3dJZHMpID0+XG4gICAgICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzKGFsbFJvd3MsIHRvcFBpbm5lZFJvd0lkcywgJ3RvcCcpLFxuICAgICAgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRUb3BSb3dzJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRCb3R0b21Sb3dzID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLFxuICAgICAgKGFsbFJvd3MsIGJvdHRvbVBpbm5lZFJvd0lkcykgPT5cbiAgICAgICAgdGFibGUuX2dldFBpbm5lZFJvd3MoYWxsUm93cywgYm90dG9tUGlubmVkUm93SWRzLCAnYm90dG9tJyksXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEJvdHRvbVJvd3MnKVxuICAgIClcblxuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b20sXG4gICAgICBdLFxuICAgICAgKGFsbFJvd3MsIHRvcCwgYm90dG9tKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvcEFuZEJvdHRvbSA9IG5ldyBTZXQoWy4uLih0b3AgPz8gW10pLCAuLi4oYm90dG9tID8/IFtdKV0pXG4gICAgICAgIHJldHVybiBhbGxSb3dzLmZpbHRlcihkID0+ICF0b3BBbmRCb3R0b20uaGFzKGQuaWQpKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyUm93cycpXG4gICAgKVxuICB9LFxufVxuIiwiaW1wb3J0IHtcbiAgT25DaGFuZ2VGbixcbiAgVGFibGUsXG4gIFJvdyxcbiAgUm93TW9kZWwsXG4gIFVwZGF0ZXIsXG4gIFJvd0RhdGEsXG4gIFRhYmxlRmVhdHVyZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBnZXRNZW1vT3B0aW9ucywgbWFrZVN0YXRlVXBkYXRlciwgbWVtbyB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgdHlwZSBSb3dTZWxlY3Rpb25TdGF0ZSA9IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm93U2VsZWN0aW9uVGFibGVTdGF0ZSB7XG4gIHJvd1NlbGVjdGlvbjogUm93U2VsZWN0aW9uU3RhdGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3dTZWxlY3Rpb25PcHRpb25zPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAvKipcbiAgICogLSBFbmFibGVzL2Rpc2FibGVzIG11bHRpcGxlIHJvdyBzZWxlY3Rpb24gZm9yIGFsbCByb3dzIGluIHRoZSB0YWJsZSBPUlxuICAgKiAtIEEgZnVuY3Rpb24gdGhhdCBnaXZlbiBhIHJvdywgcmV0dXJucyB3aGV0aGVyIHRvIGVuYWJsZS9kaXNhYmxlIG11bHRpcGxlIHJvdyBzZWxlY3Rpb24gZm9yIHRoYXQgcm93J3MgY2hpbGRyZW4vZ3JhbmRjaGlsZHJlblxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZW5hYmxlbXVsdGlyb3dzZWxlY3Rpb24pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24/OiBib29sZWFuIHwgKChyb3c6IFJvdzxURGF0YT4pID0+IGJvb2xlYW4pXG4gIC8qKlxuICAgKiAtIEVuYWJsZXMvZGlzYWJsZXMgcm93IHNlbGVjdGlvbiBmb3IgYWxsIHJvd3MgaW4gdGhlIHRhYmxlIE9SXG4gICAqIC0gQSBmdW5jdGlvbiB0aGF0IGdpdmVuIGEgcm93LCByZXR1cm5zIHdoZXRoZXIgdG8gZW5hYmxlL2Rpc2FibGUgcm93IHNlbGVjdGlvbiBmb3IgdGhhdCByb3dcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2VuYWJsZXJvd3NlbGVjdGlvbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBlbmFibGVSb3dTZWxlY3Rpb24/OiBib29sZWFuIHwgKChyb3c6IFJvdzxURGF0YT4pID0+IGJvb2xlYW4pXG4gIC8qKlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIGF1dG9tYXRpYyBzdWItcm93IHNlbGVjdGlvbiB3aGVuIGEgcGFyZW50IHJvdyBpcyBzZWxlY3RlZCwgb3IgYSBmdW5jdGlvbiB0aGF0IGVuYWJsZXMvZGlzYWJsZXMgYXV0b21hdGljIHN1Yi1yb3cgc2VsZWN0aW9uIGZvciBlYWNoIHJvdy5cbiAgICogKFVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIGV4cGFuZGluZyBvciBncm91cGluZyBmZWF0dXJlcylcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2VuYWJsZXN1YnJvd3NlbGVjdGlvbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBlbmFibGVTdWJSb3dTZWxlY3Rpb24/OiBib29sZWFuIHwgKChyb3c6IFJvdzxURGF0YT4pID0+IGJvb2xlYW4pXG4gIC8qKlxuICAgKiBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGB1cGRhdGVyRm5gIHdoZW4gYHN0YXRlLnJvd1NlbGVjdGlvbmAgY2hhbmdlcy4gVGhpcyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW50ZXJuYWwgc3RhdGUgbWFuYWdlbWVudCwgc28geW91IHdpbGwgbmVlZCB0byBwZXJzaXN0IHRoZSBzdGF0ZSBjaGFuZ2UgZWl0aGVyIGZ1bGx5IG9yIHBhcnRpYWxseSBvdXRzaWRlIG9mIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI29ucm93c2VsZWN0aW9uY2hhbmdlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIG9uUm93U2VsZWN0aW9uQ2hhbmdlPzogT25DaGFuZ2VGbjxSb3dTZWxlY3Rpb25TdGF0ZT5cbiAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24/OlxuICAvLyAgIHwgYm9vbGVhblxuICAvLyAgIHwgKChcbiAgLy8gICAgICAgcm93OiBSb3c8VERhdGE+XG4gIC8vICAgICApID0+IGJvb2xlYW4pXG4gIC8vIGlzQWRkaXRpdmVTZWxlY3RFdmVudD86IChlOiB1bmtub3duKSA9PiBib29sZWFuXG4gIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ/OiAoZTogdW5rbm93bikgPT4gYm9vbGVhblxuICAvLyBzZWxlY3RSb3dzRm4/OiAoXG4gIC8vICAgdGFibGU6IFRhYmxlPFREYXRhPixcbiAgLy8gICByb3dNb2RlbDogUm93TW9kZWw8VERhdGE+XG4gIC8vICkgPT4gUm93TW9kZWw8VERhdGE+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm93U2VsZWN0aW9uUm93IHtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJvdyBjYW4gbXVsdGktc2VsZWN0LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0Y2FubXVsdGlzZWxlY3QpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0Q2FuTXVsdGlTZWxlY3Q6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHJvdyBjYW4gYmUgc2VsZWN0ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXNlbGVjdGlvbiNnZXRjYW5zZWxlY3QpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0Q2FuU2VsZWN0OiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByb3cgY2FuIHNlbGVjdCBzdWIgcm93cyBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHBhcmVudCByb3cgaXMgc2VsZWN0ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXNlbGVjdGlvbiNnZXRjYW5zZWxlY3RzdWJyb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIGdldENhblNlbGVjdFN1YlJvd3M6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYWxsIG9mIHRoZSByb3cncyBzdWIgcm93cyBhcmUgc2VsZWN0ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXNlbGVjdGlvbiNnZXRpc2FsbHN1YnJvd3NzZWxlY3RlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRJc0FsbFN1YlJvd3NTZWxlY3RlZDogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcm93IGlzIHNlbGVjdGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0aXNzZWxlY3RlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRJc1NlbGVjdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHNvbWUgb2YgdGhlIHJvdydzIHN1YiByb3dzIGFyZSBzZWxlY3RlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2dldGlzc29tZXNlbGVjdGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIGdldElzU29tZVNlbGVjdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFuZGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIHRvZ2dsZSB0aGUgcm93LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0dG9nZ2xlc2VsZWN0ZWRoYW5kbGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIGdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlcjogKCkgPT4gKGV2ZW50OiB1bmtub3duKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBTZWxlY3RzL2Rlc2VsZWN0cyB0aGUgcm93LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jdG9nZ2xlc2VsZWN0ZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgdG9nZ2xlU2VsZWN0ZWQ6ICh2YWx1ZT86IGJvb2xlYW4sIG9wdHM/OiB7IHNlbGVjdENoaWxkcmVuPzogYm9vbGVhbiB9KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm93U2VsZWN0aW9uSW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgb2YgYWxsIHJvd3MgdGhhdCBhcmUgc2VsZWN0ZWQgYWZ0ZXIgZmlsdGVyaW5nIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXNlbGVjdGlvbiNnZXRmaWx0ZXJlZHNlbGVjdGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBvZiBhbGwgcm93cyB0aGF0IGFyZSBzZWxlY3RlZCBhZnRlciBncm91cGluZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0Z3JvdXBlZHNlbGVjdGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWw6ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbGwgcm93cyBvbiB0aGUgY3VycmVudCBwYWdlIGFyZSBzZWxlY3RlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2dldGlzYWxscGFnZXJvd3NzZWxlY3RlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYWxsIHJvd3MgaW4gdGhlIHRhYmxlIGFyZSBzZWxlY3RlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2dldGlzYWxscm93c3NlbGVjdGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIGdldElzQWxsUm93c1NlbGVjdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSByb3dzIG9uIHRoZSBjdXJyZW50IHBhZ2UgYXJlIHNlbGVjdGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0aXNzb21lcGFnZXJvd3NzZWxlY3RlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSByb3dzIGluIHRoZSB0YWJsZSBhcmUgc2VsZWN0ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvcm93LXNlbGVjdGlvbiNnZXRpc3NvbWVyb3dzc2VsZWN0ZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0SXNTb21lUm93c1NlbGVjdGVkOiAoKSA9PiBib29sZWFuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3JlIHJvdyBtb2RlbCBvZiBhbGwgcm93cyBiZWZvcmUgcm93IHNlbGVjdGlvbiBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0cHJlc2VsZWN0ZWRyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRQcmVTZWxlY3RlZFJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyBtb2RlbCBvZiBhbGwgcm93cyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI2dldHNlbGVjdGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0U2VsZWN0ZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFuZGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIHRvZ2dsZSBhbGwgcm93cyBvbiB0aGUgY3VycmVudCBwYWdlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0dG9nZ2xlYWxscGFnZXJvd3NzZWxlY3RlZGhhbmRsZXIpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXI6ICgpID0+IChldmVudDogdW5rbm93bikgPT4gdm9pZFxuICAvKipcbiAgICogUmV0dXJucyBhIGhhbmRsZXIgdGhhdCBjYW4gYmUgdXNlZCB0byB0b2dnbGUgYWxsIHJvd3MgaW4gdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jZ2V0dG9nZ2xlYWxscm93c3NlbGVjdGVkaGFuZGxlcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyOiAoKSA9PiAoZXZlbnQ6IHVua25vd24pID0+IHZvaWRcbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgKipyb3dTZWxlY3Rpb24qKiBzdGF0ZSB0byB0aGUgYGluaXRpYWxTdGF0ZS5yb3dTZWxlY3Rpb25gLCBvciBgdHJ1ZWAgY2FuIGJlIHBhc3NlZCB0byBmb3JjZSBhIGRlZmF1bHQgYmxhbmsgc3RhdGUgcmVzZXQgdG8gYHt9YC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI3Jlc2V0cm93c2VsZWN0aW9uKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIHJlc2V0Um93U2VsZWN0aW9uOiAoZGVmYXVsdFN0YXRlPzogYm9vbGVhbikgPT4gdm9pZFxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBgc3RhdGUucm93U2VsZWN0aW9uYCBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI3NldHJvd3NlbGVjdGlvbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3Jvdy1zZWxlY3Rpb24pXG4gICAqL1xuICBzZXRSb3dTZWxlY3Rpb246ICh1cGRhdGVyOiBVcGRhdGVyPFJvd1NlbGVjdGlvblN0YXRlPikgPT4gdm9pZFxuICAvKipcbiAgICogU2VsZWN0cy9kZXNlbGVjdHMgYWxsIHJvd3Mgb24gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9yb3ctc2VsZWN0aW9uI3RvZ2dsZWFsbHBhZ2Vyb3dzc2VsZWN0ZWQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9yb3ctc2VsZWN0aW9uKVxuICAgKi9cbiAgdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZDogKHZhbHVlPzogYm9vbGVhbikgPT4gdm9pZFxuICAvKipcbiAgICogU2VsZWN0cy9kZXNlbGVjdHMgYWxsIHJvd3MgaW4gdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3Jvdy1zZWxlY3Rpb24jdG9nZ2xlYWxscm93c3NlbGVjdGVkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvcm93LXNlbGVjdGlvbilcbiAgICovXG4gIHRvZ2dsZUFsbFJvd3NTZWxlY3RlZDogKHZhbHVlPzogYm9vbGVhbikgPT4gdm9pZFxufVxuXG4vL1xuXG5leHBvcnQgY29uc3QgUm93U2VsZWN0aW9uOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogUm93U2VsZWN0aW9uVGFibGVTdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogUm93U2VsZWN0aW9uT3B0aW9uczxURGF0YT4gPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93U2VsZWN0aW9uJywgdGFibGUpLFxuICAgICAgZW5hYmxlUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVTdWJSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICAvLyBlbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcbiAgICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVRhYmxlOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPih0YWJsZTogVGFibGU8VERhdGE+KTogdm9pZCA9PiB7XG4gICAgdGFibGUuc2V0Um93U2VsZWN0aW9uID0gdXBkYXRlciA9PlxuICAgICAgdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZT8uKHVwZGF0ZXIpXG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT5cbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihcbiAgICAgICAgZGVmYXVsdFN0YXRlID8ge30gOiB0YWJsZS5pbml0aWFsU3RhdGUucm93U2VsZWN0aW9uID8/IHt9XG4gICAgICApXG4gICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhbHVlID1cbiAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKVxuXG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHsgLi4ub2xkIH1cblxuICAgICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKS5mbGF0Um93c1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgLy8gQWxsIG9mIHRoZSByb3dzIGFyZSBmbGF0IGFscmVhZHksIHNvIGl0IHdvdWxkbid0IGJlIHdvcnRoIGl0XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbltyb3cuaWRdID0gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dTZWxlY3Rpb25bcm93LmlkXVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uXG4gICAgICB9KVxuICAgIH1cbiAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gdmFsdWUgPT5cbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlID1cbiAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICA6ICF0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKVxuXG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbjogUm93U2VsZWN0aW9uU3RhdGUgPSB7IC4uLm9sZCB9XG5cbiAgICAgICAgdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHJvd1NlbGVjdGlvbiwgcm93LmlkLCByZXNvbHZlZFZhbHVlLCB0cnVlLCB0YWJsZSlcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uXG4gICAgICB9KVxuXG4gICAgLy8gYWRkUm93U2VsZWN0aW9uUmFuZ2U6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHtcbiAgICAvLyAgICAgcm93cyxcbiAgICAvLyAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgIG9wdGlvbnM6IHsgc2VsZWN0R3JvdXBpbmdSb3dzLCBzZWxlY3RTdWJSb3dzIH0sXG4gICAgLy8gICB9ID0gdGFibGVcblxuICAgIC8vICAgY29uc3QgZmluZFNlbGVjdGVkUm93ID0gKHJvd3M6IFJvd1tdKSA9PiB7XG4gICAgLy8gICAgIGxldCBmb3VuZFxuICAgIC8vICAgICByb3dzLmZpbmQoZCA9PiB7XG4gICAgLy8gICAgICAgaWYgKGQuZ2V0SXNTZWxlY3RlZCgpKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IGRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIGNvbnN0IHN1YkZvdW5kID0gZmluZFNlbGVjdGVkUm93KGQuc3ViUm93cyB8fCBbXSlcbiAgICAvLyAgICAgICBpZiAoc3ViRm91bmQpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gc3ViRm91bmRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9KVxuICAgIC8vICAgICByZXR1cm4gZm91bmRcbiAgICAvLyAgIH1cblxuICAgIC8vICAgY29uc3QgZmlyc3RSb3cgPSBmaW5kU2VsZWN0ZWRSb3cocm93cykgfHwgcm93c1swXVxuICAgIC8vICAgY29uc3QgbGFzdFJvdyA9IHJvd3NCeUlkW3Jvd0lkXVxuXG4gICAgLy8gICBsZXQgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHt9XG5cbiAgICAvLyAgIGNvbnN0IGFkZFJvdyA9IChyb3c6IFJvdykgPT4ge1xuICAgIC8vICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHRydWUsIHtcbiAgICAvLyAgICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgICBzZWxlY3RHcm91cGluZ1Jvd3M6IHNlbGVjdEdyb3VwaW5nUm93cyEsXG4gICAgLy8gICAgICAgc2VsZWN0U3ViUm93czogc2VsZWN0U3ViUm93cyEsXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHRhYmxlLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIC8vICAgICBjb25zdCBpc0ZpcnN0Um93ID0gcm93LmlkID09PSBmaXJzdFJvdy5pZFxuICAgIC8vICAgICBjb25zdCBpc0xhc3RSb3cgPSByb3cuaWQgPT09IGxhc3RSb3cuaWRcblxuICAgIC8vICAgICBpZiAoaXNGaXJzdFJvdyB8fCBpc0xhc3RSb3cpIHtcbiAgICAvLyAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSB0cnVlXG4gICAgLy8gICAgICAgfSBlbHNlIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG5cbiAgICAvLyAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9KVxuXG4gICAgLy8gICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dJZHMpXG4gICAgLy8gfSxcbiAgICB0YWJsZS5nZXRQcmVTZWxlY3RlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKClcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0Q29yZVJvd01vZGVsKCldLFxuICAgICAgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICAgIHJvd3NCeUlkOiB7fSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTZWxlY3RlZFJvd01vZGVsJylcbiAgICApXG5cbiAgICB0YWJsZS5nZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLFxuICAgICAgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICAgIHJvd3NCeUlkOiB7fSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwnKVxuICAgIClcblxuICAgIHRhYmxlLmdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKV0sXG4gICAgICAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgICAgcm93c0J5SWQ6IHt9LFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsJylcbiAgICApXG5cbiAgICAvLy9cblxuICAgIC8vIGdldEdyb3VwaW5nUm93Q2FuU2VsZWN0OiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQpXG5cbiAgICAvLyAgIGlmICghcm93KSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcigpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbihyb3cpXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID8/IGZhbHNlXG4gICAgLy8gfSxcblxuICAgIHRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzXG4gICAgICBjb25zdCB7IHJvd1NlbGVjdGlvbiB9ID0gdGFibGUuZ2V0U3RhdGUoKVxuXG4gICAgICBsZXQgaXNBbGxSb3dzU2VsZWN0ZWQgPSBCb29sZWFuKFxuICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MubGVuZ3RoICYmIE9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoXG4gICAgICApXG5cbiAgICAgIGlmIChpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLnNvbWUoXG4gICAgICAgICAgICByb3cgPT4gcm93LmdldENhblNlbGVjdCgpICYmICFyb3dTZWxlY3Rpb25bcm93LmlkXVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc0FsbFJvd3NTZWxlY3RlZFxuICAgIH1cblxuICAgIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlXG4gICAgICAgIC5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKVxuICAgICAgICAuZmxhdFJvd3MuZmlsdGVyKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkpXG4gICAgICBjb25zdCB7IHJvd1NlbGVjdGlvbiB9ID0gdGFibGUuZ2V0U3RhdGUoKVxuXG4gICAgICBsZXQgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gISFwYWdpbmF0aW9uRmxhdFJvd3MubGVuZ3RoXG5cbiAgICAgIGlmIChcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkICYmXG4gICAgICAgIHBhZ2luYXRpb25GbGF0Um93cy5zb21lKHJvdyA9PiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pXG4gICAgICApIHtcbiAgICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzQWxsUGFnZVJvd3NTZWxlY3RlZFxuICAgIH1cblxuICAgIHRhYmxlLmdldElzU29tZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRvdGFsU2VsZWN0ZWQgPSBPYmplY3Qua2V5cyhcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24gPz8ge31cbiAgICAgICkubGVuZ3RoXG4gICAgICByZXR1cm4gKFxuICAgICAgICB0b3RhbFNlbGVjdGVkID4gMCAmJlxuICAgICAgICB0b3RhbFNlbGVjdGVkIDwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLmxlbmd0aFxuICAgICAgKVxuICAgIH1cblxuICAgIHRhYmxlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93c1xuICAgICAgcmV0dXJuIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiBwYWdpbmF0aW9uRmxhdFJvd3NcbiAgICAgICAgICAgIC5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSlcbiAgICAgICAgICAgIC5zb21lKGQgPT4gZC5nZXRJc1NlbGVjdGVkKCkgfHwgZC5nZXRJc1NvbWVTZWxlY3RlZCgpKVxuICAgIH1cblxuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKGU6IHVua25vd24pID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkKFxuICAgICAgICAgICgoZSBhcyBNb3VzZUV2ZW50KS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKGU6IHVua25vd24pID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChcbiAgICAgICAgICAoKGUgYXMgTW91c2VFdmVudCkudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVSb3c6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHJvdzogUm93PFREYXRhPixcbiAgICB0YWJsZTogVGFibGU8VERhdGE+XG4gICk6IHZvaWQgPT4ge1xuICAgIHJvdy50b2dnbGVTZWxlY3RlZCA9ICh2YWx1ZSwgb3B0cykgPT4ge1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHJvdy5nZXRJc1NlbGVjdGVkKClcblxuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIWlzU2VsZWN0ZWRcblxuICAgICAgICBpZiAocm93LmdldENhblNlbGVjdCgpICYmIGlzU2VsZWN0ZWQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7IC4uLm9sZCB9XG5cbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChcbiAgICAgICAgICBzZWxlY3RlZFJvd0lkcyxcbiAgICAgICAgICByb3cuaWQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgb3B0cz8uc2VsZWN0Q2hpbGRyZW4gPz8gdHJ1ZSxcbiAgICAgICAgICB0YWJsZVxuICAgICAgICApXG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93SWRzXG4gICAgICB9KVxuICAgIH1cbiAgICByb3cuZ2V0SXNTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcm93U2VsZWN0aW9uIH0gPSB0YWJsZS5nZXRTdGF0ZSgpXG4gICAgICByZXR1cm4gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbilcbiAgICB9XG5cbiAgICByb3cuZ2V0SXNTb21lU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJvd1NlbGVjdGlvbiB9ID0gdGFibGUuZ2V0U3RhdGUoKVxuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24sIHRhYmxlKSA9PT0gJ3NvbWUnXG4gICAgfVxuXG4gICAgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyByb3dTZWxlY3Rpb24gfSA9IHRhYmxlLmdldFN0YXRlKClcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uLCB0YWJsZSkgPT09ICdhbGwnXG4gICAgfVxuXG4gICAgcm93LmdldENhblNlbGVjdCA9ICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uKHJvdylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID8/IHRydWVcbiAgICB9XG5cbiAgICByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cyA9ICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKHJvdylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uID8/IHRydWVcbiAgICB9XG5cbiAgICByb3cuZ2V0Q2FuTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24ocm93KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA/PyB0cnVlXG4gICAgfVxuICAgIHJvdy5nZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5TZWxlY3QgPSByb3cuZ2V0Q2FuU2VsZWN0KClcblxuICAgICAgcmV0dXJuIChlOiB1bmtub3duKSA9PiB7XG4gICAgICAgIGlmICghY2FuU2VsZWN0KSByZXR1cm5cbiAgICAgICAgcm93LnRvZ2dsZVNlbGVjdGVkKFxuICAgICAgICAgICgoZSBhcyBNb3VzZUV2ZW50KS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCk/LmNoZWNrZWRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuY29uc3QgbXV0YXRlUm93SXNTZWxlY3RlZCA9IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICBzZWxlY3RlZFJvd0lkczogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4sXG4gIGlkOiBzdHJpbmcsXG4gIHZhbHVlOiBib29sZWFuLFxuICBpbmNsdWRlQ2hpbGRyZW46IGJvb2xlYW4sXG4gIHRhYmxlOiBUYWJsZTxURGF0YT5cbikgPT4ge1xuICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3coaWQsIHRydWUpXG5cbiAgLy8gY29uc3QgaXNHcm91cGVkID0gcm93LmdldElzR3JvdXBlZCgpXG5cbiAgLy8gaWYgKCAvLyBUT0RPOiBlbmZvcmNlIGdyb3VwaW5nIHJvdyBzZWxlY3Rpb24gcnVsZXNcbiAgLy8gICAhaXNHcm91cGVkIHx8XG4gIC8vICAgKGlzR3JvdXBlZCAmJiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKVxuICAvLyApIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFyb3cuZ2V0Q2FuTXVsdGlTZWxlY3QoKSkge1xuICAgICAgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1trZXldKVxuICAgIH1cbiAgICBpZiAocm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBzZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tpZF1cbiAgfVxuICAvLyB9XG5cbiAgaWYgKGluY2x1ZGVDaGlsZHJlbiAmJiByb3cuc3ViUm93cz8ubGVuZ3RoICYmIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkpIHtcbiAgICByb3cuc3ViUm93cy5mb3JFYWNoKHJvdyA9PlxuICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSlcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFJvd3NGbjxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICByb3dNb2RlbDogUm93TW9kZWw8VERhdGE+XG4pOiBSb3dNb2RlbDxURGF0YT4ge1xuICBjb25zdCByb3dTZWxlY3Rpb24gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvblxuXG4gIGNvbnN0IG5ld1NlbGVjdGVkRmxhdFJvd3M6IFJvdzxURGF0YT5bXSA9IFtdXG4gIGNvbnN0IG5ld1NlbGVjdGVkUm93c0J5SWQ6IFJlY29yZDxzdHJpbmcsIFJvdzxURGF0YT4+ID0ge31cblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZVJvd3MgPSAocm93czogUm93PFREYXRhPltdLCBkZXB0aCA9IDApOiBSb3c8VERhdGE+W10gPT4ge1xuICAgIHJldHVybiByb3dzXG4gICAgICAubWFwKHJvdyA9PiB7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKVxuXG4gICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgbmV3U2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdylcbiAgICAgICAgICBuZXdTZWxlY3RlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3dcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3cuc3ViUm93cz8ubGVuZ3RoKSB7XG4gICAgICAgICAgcm93ID0ge1xuICAgICAgICAgICAgLi4ucm93LFxuICAgICAgICAgICAgc3ViUm93czogcmVjdXJzZVJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSksXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcm93XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pIGFzIFJvdzxURGF0YT5bXVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlUm93cyhyb3dNb2RlbC5yb3dzKSxcbiAgICBmbGF0Um93czogbmV3U2VsZWN0ZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3U2VsZWN0ZWRSb3dzQnlJZCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSb3dTZWxlY3RlZDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICByb3c6IFJvdzxURGF0YT4sXG4gIHNlbGVjdGlvbjogUmVjb3JkPHN0cmluZywgYm9vbGVhbj5cbik6IGJvb2xlYW4ge1xuICByZXR1cm4gc2VsZWN0aW9uW3Jvdy5pZF0gPz8gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3ViUm93U2VsZWN0ZWQ8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihcbiAgcm93OiBSb3c8VERhdGE+LFxuICBzZWxlY3Rpb246IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+LFxuICB0YWJsZTogVGFibGU8VERhdGE+XG4pOiBib29sZWFuIHwgJ3NvbWUnIHwgJ2FsbCcge1xuICBpZiAoIXJvdy5zdWJSb3dzPy5sZW5ndGgpIHJldHVybiBmYWxzZVxuXG4gIGxldCBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZVxuICBsZXQgc29tZVNlbGVjdGVkID0gZmFsc2VcblxuICByb3cuc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgLy8gQmFpbCBvdXQgZWFybHkgaWYgd2Uga25vdyBib3RoIG9mIHRoZXNlXG4gICAgaWYgKHNvbWVTZWxlY3RlZCAmJiAhYWxsQ2hpbGRyZW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHN1YlJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgaWYgKGlzUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHJvdyBzZWxlY3Rpb24gb2YgbmVzdGVkIHN1YnJvd3NcbiAgICBpZiAoc3ViUm93LnN1YlJvd3MgJiYgc3ViUm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJSb3dDaGlsZHJlblNlbGVjdGVkID0gaXNTdWJSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbiwgdGFibGUpXG4gICAgICBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnc29tZScpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZVxuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/ICdhbGwnIDogc29tZVNlbGVjdGVkID8gJ3NvbWUnIDogZmFsc2Vcbn1cbiIsImltcG9ydCB7IFNvcnRpbmdGbiB9IGZyb20gJy4vZmVhdHVyZXMvUm93U29ydGluZydcblxuZXhwb3J0IGNvbnN0IHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ21cblxuY29uc3QgYWxwaGFudW1lcmljOiBTb3J0aW5nRm48YW55PiA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyhcbiAgICB0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSxcbiAgICB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKVxuICApXG59XG5cbmNvbnN0IGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmU6IFNvcnRpbmdGbjxhbnk+ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKFxuICAgIHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSxcbiAgICB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSlcbiAgKVxufVxuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHQ6IFNvcnRpbmdGbjxhbnk+ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWMoXG4gICAgdG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksXG4gICAgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKClcbiAgKVxufVxuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHRDYXNlU2Vuc2l0aXZlOiBTb3J0aW5nRm48YW55PiA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKFxuICAgIHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSxcbiAgICB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSlcbiAgKVxufVxuXG5jb25zdCBkYXRldGltZTogU29ydGluZ0ZuPGFueT4gPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgY29uc3QgYSA9IHJvd0EuZ2V0VmFsdWU8RGF0ZT4oY29sdW1uSWQpXG4gIGNvbnN0IGIgPSByb3dCLmdldFZhbHVlPERhdGU+KGNvbHVtbklkKVxuXG4gIC8vIENhbiBoYW5kbGUgbnVsbGlzaCB2YWx1ZXNcbiAgLy8gVXNlID4gYW5kIDwgYmVjYXVzZSA9PSAoYW5kID09PSkgZG9lc24ndCB3b3JrIHdpdGhcbiAgLy8gRGF0ZSBvYmplY3RzICh3b3VsZCByZXF1aXJlIGNhbGxpbmcgZ2V0VGltZSgpKS5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG59XG5cbmNvbnN0IGJhc2ljOiBTb3J0aW5nRm48YW55PiA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpLCByb3dCLmdldFZhbHVlKGNvbHVtbklkKSlcbn1cblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gY29tcGFyZUJhc2ljKGE6IGFueSwgYjogYW55KSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xXG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGE6IGFueSkge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSlcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGFcbiAgfVxuICByZXR1cm4gJydcbn1cblxuLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuLy8gbnVsbCwgdW5kZWZpbmVkLCBhbmQgSW5maW5pdHlcbmZ1bmN0aW9uIGNvbXBhcmVBbHBoYW51bWVyaWMoYVN0cjogc3RyaW5nLCBiU3RyOiBzdHJpbmcpIHtcbiAgLy8gU3BsaXQgb24gbnVtYmVyIGdyb3VwcywgYnV0IGtlZXAgdGhlIGRlbGltaXRlclxuICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG4gIGNvbnN0IGEgPSBhU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKVxuICBjb25zdCBiID0gYlN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbilcblxuICAvLyBXaGlsZVxuICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICBjb25zdCBhYSA9IGEuc2hpZnQoKSFcbiAgICBjb25zdCBiYiA9IGIuc2hpZnQoKSFcblxuICAgIGNvbnN0IGFuID0gcGFyc2VJbnQoYWEsIDEwKVxuICAgIGNvbnN0IGJuID0gcGFyc2VJbnQoYmIsIDEwKVxuXG4gICAgY29uc3QgY29tYm8gPSBbYW4sIGJuXS5zb3J0KClcblxuICAgIC8vIEJvdGggYXJlIHN0cmluZ1xuICAgIGlmIChpc05hTihjb21ib1swXSEpKSB7XG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG4gICAgaWYgKGlzTmFOKGNvbWJvWzFdISkpIHtcbiAgICAgIHJldHVybiBpc05hTihhbikgPyAtMSA6IDFcbiAgICB9XG5cbiAgICAvLyBCb3RoIGFyZSBudW1iZXJzXG4gICAgaWYgKGFuID4gYm4pIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIGlmIChibiA+IGFuKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aFxufVxuXG4vLyBFeHBvcnRzXG5cbmV4cG9ydCBjb25zdCBzb3J0aW5nRm5zID0ge1xuICBhbHBoYW51bWVyaWMsXG4gIGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUsXG4gIHRleHQsXG4gIHRleHRDYXNlU2Vuc2l0aXZlLFxuICBkYXRldGltZSxcbiAgYmFzaWMsXG59XG5cbmV4cG9ydCB0eXBlIEJ1aWx0SW5Tb3J0aW5nRm4gPSBrZXlvZiB0eXBlb2Ygc29ydGluZ0Zuc1xuIiwiaW1wb3J0IHsgUm93TW9kZWwgfSBmcm9tICcuLidcbmltcG9ydCB7XG4gIEJ1aWx0SW5Tb3J0aW5nRm4sXG4gIHJlU3BsaXRBbHBoYU51bWVyaWMsXG4gIHNvcnRpbmdGbnMsXG59IGZyb20gJy4uL3NvcnRpbmdGbnMnXG5cbmltcG9ydCB7XG4gIENvbHVtbixcbiAgT25DaGFuZ2VGbixcbiAgVGFibGUsXG4gIFJvdyxcbiAgVXBkYXRlcixcbiAgUm93RGF0YSxcbiAgU29ydGluZ0ZucyxcbiAgVGFibGVGZWF0dXJlLFxufSBmcm9tICcuLi90eXBlcydcblxuaW1wb3J0IHsgaXNGdW5jdGlvbiwgbWFrZVN0YXRlVXBkYXRlciB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgdHlwZSBTb3J0RGlyZWN0aW9uID0gJ2FzYycgfCAnZGVzYydcblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5Tb3J0IHtcbiAgZGVzYzogYm9vbGVhblxuICBpZDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIFNvcnRpbmdTdGF0ZSA9IENvbHVtblNvcnRbXVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRpbmdUYWJsZVN0YXRlIHtcbiAgc29ydGluZzogU29ydGluZ1N0YXRlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydGluZ0ZuPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICAocm93QTogUm93PFREYXRhPiwgcm93QjogUm93PFREYXRhPiwgY29sdW1uSWQ6IHN0cmluZyk6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBDdXN0b21Tb3J0aW5nRm5zPFREYXRhIGV4dGVuZHMgUm93RGF0YT4gPSBSZWNvcmQ8XG4gIHN0cmluZyxcbiAgU29ydGluZ0ZuPFREYXRhPlxuPlxuXG5leHBvcnQgdHlwZSBTb3J0aW5nRm5PcHRpb248VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiA9XG4gIHwgJ2F1dG8nXG4gIHwga2V5b2YgU29ydGluZ0Zuc1xuICB8IEJ1aWx0SW5Tb3J0aW5nRm5cbiAgfCBTb3J0aW5nRm48VERhdGE+XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydGluZ0NvbHVtbkRlZjxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEVuYWJsZXMvRGlzYWJsZXMgbXVsdGktc29ydGluZyBmb3IgdGhpcyBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNlbmFibGVtdWx0aXNvcnQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZW5hYmxlTXVsdGlTb3J0PzogYm9vbGVhblxuICAvKipcbiAgICogRW5hYmxlcy9EaXNhYmxlcyBzb3J0aW5nIGZvciB0aGlzIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI2VuYWJsZXNvcnRpbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZW5hYmxlU29ydGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEludmVydHMgdGhlIG9yZGVyIG9mIHRoZSBzb3J0aW5nIGZvciB0aGlzIGNvbHVtbi4gVGhpcyBpcyB1c2VmdWwgZm9yIHZhbHVlcyB0aGF0IGhhdmUgYW4gaW52ZXJ0ZWQgYmVzdC93b3JzdCBzY2FsZSB3aGVyZSBsb3dlciBudW1iZXJzIGFyZSBiZXR0ZXIsIGVnLiBhIHJhbmtpbmcgKDFzdCwgMm5kLCAzcmQpIG9yIGdvbGYtbGlrZSBzY29yaW5nXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNpbnZlcnRzb3J0aW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGludmVydFNvcnRpbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBTZXQgdG8gYHRydWVgIGZvciBzb3J0aW5nIHRvZ2dsZXMgb24gdGhpcyBjb2x1bW4gdG8gc3RhcnQgaW4gdGhlIGRlc2NlbmRpbmcgZGlyZWN0aW9uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjc29ydGRlc2NmaXJzdClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBzb3J0RGVzY0ZpcnN0PzogYm9vbGVhblxuICAvKipcbiAgICogVGhlIHNvcnRpbmcgZnVuY3Rpb24gdG8gdXNlIHdpdGggdGhpcyBjb2x1bW4uXG4gICAqIC0gQSBgc3RyaW5nYCByZWZlcmVuY2luZyBhIGJ1aWx0LWluIHNvcnRpbmcgZnVuY3Rpb25cbiAgICogLSBBIGN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNzb3J0aW5nZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgc29ydGluZ0ZuPzogU29ydGluZ0ZuT3B0aW9uPFREYXRhPlxuICAvKipcbiAgICogVGhlIHByaW9yaXR5IG9mIHVuZGVmaW5lZCB2YWx1ZXMgd2hlbiBzb3J0aW5nIHRoaXMgY29sdW1uLlxuICAgKiAtIGBmYWxzZWBcbiAgICogICAtIFVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIHRpZWQgYW5kIG5lZWQgdG8gYmUgc29ydGVkIGJ5IHRoZSBuZXh0IGNvbHVtbiBmaWx0ZXIgb3Igb3JpZ2luYWwgaW5kZXggKHdoaWNoZXZlciBhcHBsaWVzKVxuICAgKiAtIGAtMWBcbiAgICogICAtIFVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBiZSBzb3J0ZWQgd2l0aCBoaWdoZXIgcHJpb3JpdHkgKGFzY2VuZGluZykgKGlmIGFzY2VuZGluZywgdW5kZWZpbmVkIHdpbGwgYXBwZWFyIG9uIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QpXG4gICAqIC0gYDFgXG4gICAqICAgLSBVbmRlZmluZWQgdmFsdWVzIHdpbGwgYmUgc29ydGVkIHdpdGggbG93ZXIgcHJpb3JpdHkgKGRlc2NlbmRpbmcpIChpZiBhc2NlbmRpbmcsIHVuZGVmaW5lZCB3aWxsIGFwcGVhciBvbiB0aGUgZW5kIG9mIHRoZSBsaXN0KVxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjc29ydHVuZGVmaW5lZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBzb3J0VW5kZWZpbmVkPzogZmFsc2UgfCAtMSB8IDEgfCAnZmlyc3QnIHwgJ2xhc3QnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydGluZ0NvbHVtbjxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBjb2x1bW4gZnJvbSB0aGUgdGFibGUncyBzb3J0aW5nIHN0YXRlXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNjbGVhcnNvcnRpbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgY2xlYXJTb3J0aW5nOiAoKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc29ydCBkaXJlY3Rpb24gYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvbiB0aGUgY29sdW1ucyB2YWx1ZXMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRhdXRvc29ydGRpcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBnZXRBdXRvU29ydERpcjogKCkgPT4gU29ydERpcmVjdGlvblxuICAvKipcbiAgICogUmV0dXJucyBhIHNvcnRpbmcgZnVuY3Rpb24gYXV0b21hdGljYWxseSBpbmZlcnJlZCBiYXNlZCBvbiB0aGUgY29sdW1ucyB2YWx1ZXMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRhdXRvc29ydGluZ2ZuKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldEF1dG9Tb3J0aW5nRm46ICgpID0+IFNvcnRpbmdGbjxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIGNvbHVtbiBjYW4gYmUgbXVsdGktc29ydGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjZ2V0Y2FubXVsdGlzb3J0KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldENhbk11bHRpU29ydDogKCkgPT4gYm9vbGVhblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgY29sdW1uIGNhbiBiZSBzb3J0ZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRjYW5zb3J0KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldENhblNvcnQ6ICgpID0+IGJvb2xlYW5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGRpcmVjdGlvbiB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gc29ydGluZyB0aGlzIGNvbHVtbi5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI2dldGZpcnN0c29ydGRpcilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBnZXRGaXJzdFNvcnREaXI6ICgpID0+IFNvcnREaXJlY3Rpb25cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc29ydCBkaXJlY3Rpb24gb2YgdGhpcyBjb2x1bW4uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRpc3NvcnRlZClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBnZXRJc1NvcnRlZDogKCkgPT4gZmFsc2UgfCBTb3J0RGlyZWN0aW9uXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IHNvcnRpbmcgb3JkZXIuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRuZXh0c29ydGluZ29yZGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldE5leHRTb3J0aW5nT3JkZXI6ICgpID0+IFNvcnREaXJlY3Rpb24gfCBmYWxzZVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgdGhpcyBjb2x1bW4ncyBzb3J0aW5nIHdpdGhpbiB0aGUgc29ydGluZyBzdGF0ZVxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjZ2V0c29ydGluZGV4KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldFNvcnRJbmRleDogKCkgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCBzb3J0aW5nIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgY29sdW1uXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRzb3J0aW5nZm4pXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZ2V0U29ydGluZ0ZuOiAoKSA9PiBTb3J0aW5nRm48VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byB0b2dnbGUgdGhpcyBjb2x1bW4ncyBzb3J0aW5nIHN0YXRlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXR0YWNoaW5nIGEgY2xpY2sgaGFuZGxlciB0byB0aGUgY29sdW1uIGhlYWRlci5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI2dldHRvZ2dsZXNvcnRpbmdoYW5kbGVyKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyOiAoKSA9PiB1bmRlZmluZWQgfCAoKGV2ZW50OiB1bmtub3duKSA9PiB2b2lkKVxuICAvKipcbiAgICogVG9nZ2xlcyB0aGlzIGNvbHVtbnMgc29ydGluZyBzdGF0ZS4gSWYgYGRlc2NgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGZvcmNlIHRoZSBzb3J0IGRpcmVjdGlvbiB0byB0aGF0IHZhbHVlLiBJZiBgaXNNdWx0aWAgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYWRkaXRpdml0eSBtdWx0aS1zb3J0IHRoZSBjb2x1bW4gKG9yIHRvZ2dsZSBpdCBpZiBpdCBpcyBhbHJlYWR5IHNvcnRlZCkuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyN0b2dnbGVzb3J0aW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIHRvZ2dsZVNvcnRpbmc6IChkZXNjPzogYm9vbGVhbiwgaXNNdWx0aT86IGJvb2xlYW4pID0+IHZvaWRcbn1cblxuaW50ZXJmYWNlIFNvcnRpbmdPcHRpb25zQmFzZSB7XG4gIC8qKlxuICAgKiBFbmFibGVzL2Rpc2FibGVzIHRoZSBhYmlsaXR5IHRvIHJlbW92ZSBtdWx0aS1zb3J0c1xuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjZW5hYmxlbXVsdGlyZW1vdmUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZW5hYmxlTXVsdGlSZW1vdmU/OiBib29sZWFuXG4gIC8qKlxuICAgKiBFbmFibGVzL0Rpc2FibGVzIG11bHRpLXNvcnRpbmcgZm9yIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI2VuYWJsZW11bHRpc29ydClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBlbmFibGVNdWx0aVNvcnQ/OiBib29sZWFuXG4gIC8qKlxuICAgKiBFbmFibGVzL0Rpc2FibGVzIHNvcnRpbmcgZm9yIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI2VuYWJsZXNvcnRpbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZW5hYmxlU29ydGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIEVuYWJsZXMvRGlzYWJsZXMgdGhlIGFiaWxpdHkgdG8gcmVtb3ZlIHNvcnRpbmcgZm9yIHRoZSB0YWJsZS5cbiAgICogLSBJZiBgdHJ1ZWAgdGhlbiBjaGFuZ2luZyBzb3J0IG9yZGVyIHdpbGwgY2lyY2xlIGxpa2U6ICdub25lJyAtPiAnZGVzYycgLT4gJ2FzYycgLT4gJ25vbmUnIC0+IC4uLlxuICAgKiAtIElmIGBmYWxzZWAgdGhlbiBjaGFuZ2luZyBzb3J0IG9yZGVyIHdpbGwgY2lyY2xlIGxpa2U6ICdub25lJyAtPiAnZGVzYycgLT4gJ2FzYycgLT4gJ2Rlc2MnIC0+ICdhc2MnIC0+IC4uLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjZW5hYmxlc29ydGluZ3JlbW92YWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZW5hYmxlU29ydGluZ1JlbW92YWw/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIHNvcnRlZCByb3cgbW9kZWwuIElmIHVzaW5nIHNlcnZlci1zaWRlIHNvcnRpbmcsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHJlcXVpcmVkLiBUbyB1c2UgY2xpZW50LXNpZGUgc29ydGluZywgcGFzcyB0aGUgZXhwb3J0ZWQgYGdldFNvcnRlZFJvd01vZGVsKClgIGZyb20geW91ciBhZGFwdGVyIHRvIHlvdXIgdGFibGUgb3IgaW1wbGVtZW50IHlvdXIgb3duLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjZ2V0c29ydGVkcm93bW9kZWwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgZ2V0U29ydGVkUm93TW9kZWw/OiAodGFibGU6IFRhYmxlPGFueT4pID0+ICgpID0+IFJvd01vZGVsPGFueT5cbiAgLyoqXG4gICAqIFBhc3MgYSBjdXN0b20gZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbXVsdGktc29ydCBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkLiBJdCBpcyBwYXNzZWQgdGhlIGV2ZW50IGZyb20gdGhlIHNvcnQgdG9nZ2xlIGhhbmRsZXIgYW5kIHNob3VsZCByZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBzaG91bGQgdHJpZ2dlciBhIG11bHRpLXNvcnQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNpc211bHRpc29ydGV2ZW50KVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIGlzTXVsdGlTb3J0RXZlbnQ/OiAoZTogdW5rbm93bikgPT4gYm9vbGVhblxuICAvKipcbiAgICogRW5hYmxlcyBtYW51YWwgc29ydGluZyBmb3IgdGhlIHRhYmxlLiBJZiB0aGlzIGlzIGB0cnVlYCwgeW91IHdpbGwgYmUgZXhwZWN0ZWQgdG8gc29ydCB5b3VyIGRhdGEgYmVmb3JlIGl0IGlzIHBhc3NlZCB0byB0aGUgdGFibGUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhcmUgZG9pbmcgc2VydmVyLXNpZGUgc29ydGluZy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI21hbnVhbHNvcnRpbmcpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgbWFudWFsU29ydGluZz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCBjYW4gYmUgbXVsdGktc29ydGVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjbWF4bXVsdGlzb3J0Y29sY291bnQpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgbWF4TXVsdGlTb3J0Q29sQ291bnQ/OiBudW1iZXJcbiAgLyoqXG4gICAqIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gYHVwZGF0ZXJGbmAgd2hlbiBgc3RhdGUuc29ydGluZ2AgY2hhbmdlcy4gVGhpcyBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW50ZXJuYWwgc3RhdGUgbWFuYWdlbWVudCwgc28geW91IHdpbGwgbmVlZCB0byBwZXJzaXN0IHRoZSBzdGF0ZSBjaGFuZ2UgZWl0aGVyIGZ1bGx5IG9yIHBhcnRpYWxseSBvdXRzaWRlIG9mIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI29uc29ydGluZ2NoYW5nZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBvblNvcnRpbmdDaGFuZ2U/OiBPbkNoYW5nZUZuPFNvcnRpbmdTdGF0ZT5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYWxsIHNvcnRzIHdpbGwgZGVmYXVsdCB0byBkZXNjZW5kaW5nIGFzIHRoZWlyIGZpcnN0IHRvZ2dsZSBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9mZWF0dXJlcy9zb3J0aW5nI3NvcnRkZXNjZmlyc3QpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS9zb3J0aW5nKVxuICAgKi9cbiAgc29ydERlc2NGaXJzdD86IGJvb2xlYW5cbn1cblxudHlwZSBSZXNvbHZlZFNvcnRpbmdGbnMgPSBrZXlvZiBTb3J0aW5nRm5zIGV4dGVuZHMgbmV2ZXJcbiAgPyB7XG4gICAgICBzb3J0aW5nRm5zPzogUmVjb3JkPHN0cmluZywgU29ydGluZ0ZuPGFueT4+XG4gICAgfVxuICA6IHtcbiAgICAgIHNvcnRpbmdGbnM6IFJlY29yZDxrZXlvZiBTb3J0aW5nRm5zLCBTb3J0aW5nRm48YW55Pj5cbiAgICB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29ydGluZ09wdGlvbnM8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPlxuICBleHRlbmRzIFNvcnRpbmdPcHRpb25zQmFzZSxcbiAgICBSZXNvbHZlZFNvcnRpbmdGbnMge31cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0aW5nSW5zdGFuY2U8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPiB7XG4gIF9nZXRTb3J0ZWRSb3dNb2RlbD86ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm93IG1vZGVsIGZvciB0aGUgdGFibGUgYmVmb3JlIGFueSBzb3J0aW5nIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRwcmVzb3J0ZWRyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBnZXRQcmVTb3J0ZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZSBhZnRlciBzb3J0aW5nIGhhcyBiZWVuIGFwcGxpZWQuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvZmVhdHVyZXMvc29ydGluZyNnZXRzb3J0ZWRyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBnZXRTb3J0ZWRSb3dNb2RlbDogKCkgPT4gUm93TW9kZWw8VERhdGE+XG4gIC8qKlxuICAgKiBSZXNldHMgdGhlICoqc29ydGluZyoqIHN0YXRlIHRvIGBpbml0aWFsU3RhdGUuc29ydGluZ2AsIG9yIGB0cnVlYCBjYW4gYmUgcGFzc2VkIHRvIGZvcmNlIGEgZGVmYXVsdCBibGFuayBzdGF0ZSByZXNldCB0byBgW11gLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjcmVzZXRzb3J0aW5nKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvc29ydGluZylcbiAgICovXG4gIHJlc2V0U29ydGluZzogKGRlZmF1bHRTdGF0ZT86IGJvb2xlYW4pID0+IHZvaWRcbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgYHN0YXRlLnNvcnRpbmdgIHN0YXRlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2ZlYXR1cmVzL3NvcnRpbmcjc2V0c29ydGluZylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3NvcnRpbmcpXG4gICAqL1xuICBzZXRTb3J0aW5nOiAodXBkYXRlcjogVXBkYXRlcjxTb3J0aW5nU3RhdGU+KSA9PiB2b2lkXG59XG5cbi8vXG5cbmV4cG9ydCBjb25zdCBSb3dTb3J0aW5nOiBUYWJsZUZlYXR1cmUgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogKHN0YXRlKTogU29ydGluZ1RhYmxlU3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlLFxuICAgIH1cbiAgfSxcblxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiA8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPigpOiBTb3J0aW5nQ29sdW1uRGVmPFREYXRhPiA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmdGbjogJ2F1dG8nLFxuICAgICAgc29ydFVuZGVmaW5lZDogMSxcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICAgIHRhYmxlOiBUYWJsZTxURGF0YT5cbiAgKTogU29ydGluZ09wdGlvbnM8VERhdGE+ID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Tb3J0aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdzb3J0aW5nJywgdGFibGUpLFxuICAgICAgaXNNdWx0aVNvcnRFdmVudDogKGU6IHVua25vd24pID0+IHtcbiAgICAgICAgcmV0dXJuIChlIGFzIE1vdXNlRXZlbnQpLnNoaWZ0S2V5XG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVDb2x1bW46IDxURGF0YSBleHRlbmRzIFJvd0RhdGEsIFRWYWx1ZT4oXG4gICAgY29sdW1uOiBDb2x1bW48VERhdGEsIFRWYWx1ZT4sXG4gICAgdGFibGU6IFRhYmxlPFREYXRhPlxuICApOiB2b2lkID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5zbGljZSgxMClcblxuICAgICAgbGV0IGlzU3RyaW5nID0gZmFsc2VcblxuICAgICAgZm9yIChjb25zdCByb3cgb2YgZmlyc3RSb3dzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm93Py5nZXRWYWx1ZShjb2x1bW4uaWQpXG5cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmRhdGV0aW1lXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlzU3RyaW5nID0gdHJ1ZVxuXG4gICAgICAgICAgaWYgKHZhbHVlLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmFscGhhbnVtZXJpY1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMudGV4dFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc29ydGluZ0Zucy5iYXNpY1xuICAgIH1cbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93c1swXVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93Py5nZXRWYWx1ZShjb2x1bW4uaWQpXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnYXNjJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ2Rlc2MnXG4gICAgfVxuICAgIGNvbHVtbi5nZXRTb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbilcbiAgICAgICAgPyBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGblxuICAgICAgICA6IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuID09PSAnYXV0bydcbiAgICAgICAgICA/IGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuKClcbiAgICAgICAgICA6IHRhYmxlLm9wdGlvbnMuc29ydGluZ0Zucz8uW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuIGFzIHN0cmluZ10gPz9cbiAgICAgICAgICAgIHNvcnRpbmdGbnNbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gYXMgQnVpbHRJblNvcnRpbmdGbl1cbiAgICB9XG4gICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPSAoZGVzYywgbXVsdGkpID0+IHtcbiAgICAgIC8vIGlmIChjb2x1bW4uY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29sdW1uLmNvbHVtbnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgLy8gICAgIGlmIChjLmlkKSB7XG4gICAgICAvLyAgICAgICB0YWJsZS50b2dnbGVDb2x1bW5Tb3J0aW5nKGMuaWQsIHVuZGVmaW5lZCwgbXVsdGkgfHwgISFpKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSlcbiAgICAgIC8vICAgcmV0dXJuXG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgb3V0c2lkZSBvZiB0YWJsZS5zZXRTb3J0aW5nIHRvIGJlIGluIHN5bmMgd2l0aCByZXJlbmRlclxuICAgICAgY29uc3QgbmV4dFNvcnRpbmdPcmRlciA9IGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyKClcbiAgICAgIGNvbnN0IGhhc01hbnVhbFZhbHVlID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGxcblxuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0aW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBjb25zdCBleGlzdGluZ1NvcnRpbmcgPSBvbGQ/LmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBvbGQ/LmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZClcblxuICAgICAgICBsZXQgbmV3U29ydGluZzogU29ydGluZ1N0YXRlID0gW11cblxuICAgICAgICAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG4gICAgICAgIGxldCBzb3J0QWN0aW9uOiAnYWRkJyB8ICdyZW1vdmUnIHwgJ3RvZ2dsZScgfCAncmVwbGFjZSdcbiAgICAgICAgbGV0IG5leHREZXNjID0gaGFzTWFudWFsVmFsdWUgPyBkZXNjIDogbmV4dFNvcnRpbmdPcmRlciA9PT0gJ2Rlc2MnXG5cbiAgICAgICAgLy8gTXVsdGktbW9kZVxuICAgICAgICBpZiAob2xkPy5sZW5ndGggJiYgY29sdW1uLmdldENhbk11bHRpU29ydCgpICYmIG11bHRpKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICAgIGlmIChvbGQ/Lmxlbmd0aCAmJiBleGlzdGluZ0luZGV4ICE9PSBvbGQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRpbmdcbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gSWYgd2UgYXJlIFwiYWN0dWFsbHlcIiB0b2dnbGluZyAobm90IGEgbWFudWFsIHNldCB2YWx1ZSksIHNob3VsZCB3ZSByZW1vdmUgdGhlIHNvcnRpbmc/XG4gICAgICAgICAgaWYgKCFoYXNNYW51YWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSXMgb3VyIGludGVudGlvbiB0byByZW1vdmU/XG4gICAgICAgICAgICBpZiAoIW5leHRTb3J0aW5nT3JkZXIpIHtcbiAgICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFtcbiAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF1cbiAgICAgICAgICAvLyBUYWtlIGxhdGVzdCBuIGNvbHVtbnNcbiAgICAgICAgICBuZXdTb3J0aW5nLnNwbGljZShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBuZXdTb3J0aW5nLmxlbmd0aCAtXG4gICAgICAgICAgICAgICh0YWJsZS5vcHRpb25zLm1heE11bHRpU29ydENvbENvdW50ID8/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2MsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAncmVtb3ZlJykge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICAgIGRlc2M6IG5leHREZXNjLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3U29ydGluZ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0Rmlyc3RTb3J0RGlyID0gKCkgPT4ge1xuICAgICAgY29uc3Qgc29ydERlc2NGaXJzdCA9XG4gICAgICAgIGNvbHVtbi5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCA/P1xuICAgICAgICB0YWJsZS5vcHRpb25zLnNvcnREZXNjRmlyc3QgPz9cbiAgICAgICAgY29sdW1uLmdldEF1dG9Tb3J0RGlyKCkgPT09ICdkZXNjJ1xuICAgICAgcmV0dXJuIHNvcnREZXNjRmlyc3QgPyAnZGVzYycgOiAnYXNjJ1xuICAgIH1cblxuICAgIGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyID0gKG11bHRpPzogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgZmlyc3RTb3J0RGlyZWN0aW9uID0gY29sdW1uLmdldEZpcnN0U29ydERpcigpXG4gICAgICBjb25zdCBpc1NvcnRlZCA9IGNvbHVtbi5nZXRJc1NvcnRlZCgpXG5cbiAgICAgIGlmICghaXNTb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0U29ydERpcmVjdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGlzU29ydGVkICE9PSBmaXJzdFNvcnREaXJlY3Rpb24gJiZcbiAgICAgICAgKHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZ1JlbW92YWwgPz8gdHJ1ZSkgJiYgLy8gSWYgZW5hYmxlU29ydFJlbW92ZSwgZW5hYmxlIGluIGdlbmVyYWxcbiAgICAgICAgKG11bHRpID8gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJlbW92ZSA/PyB0cnVlIDogdHJ1ZSkgLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGVuYWJsZU11bHRpUmVtb3ZlKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1NvcnRlZCA9PT0gJ2Rlc2MnID8gJ2FzYycgOiAnZGVzYydcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0Q2FuU29ydCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVNvcnRpbmcgPz8gdHJ1ZSkgJiZcbiAgICAgICAgKHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZyA/PyB0cnVlKSAmJlxuICAgICAgICAhIWNvbHVtbi5hY2Nlc3NvckZuXG4gICAgICApXG4gICAgfVxuXG4gICAgY29sdW1uLmdldENhbk11bHRpU29ydCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlTXVsdGlTb3J0ID8/XG4gICAgICAgIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0ID8/XG4gICAgICAgICEhY29sdW1uLmFjY2Vzc29yRm5cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb2x1bW4uZ2V0SXNTb3J0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5Tb3J0ID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nPy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKVxuXG4gICAgICByZXR1cm4gIWNvbHVtblNvcnQgPyBmYWxzZSA6IGNvbHVtblNvcnQuZGVzYyA/ICdkZXNjJyA6ICdhc2MnXG4gICAgfVxuXG4gICAgY29sdW1uLmdldFNvcnRJbmRleCA9ICgpID0+XG4gICAgICB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmc/LmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkgPz8gLTFcblxuICAgIGNvbHVtbi5jbGVhclNvcnRpbmcgPSAoKSA9PiB7XG4gICAgICAvL2NsZWFyIHNvcnRpbmcgZm9yIGp1c3QgMSBjb2x1bW5cbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+XG4gICAgICAgIG9sZD8ubGVuZ3RoID8gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkgOiBbXVxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbHVtbi5nZXRUb2dnbGVTb3J0aW5nSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNvcnQgPSBjb2x1bW4uZ2V0Q2FuU29ydCgpXG5cbiAgICAgIHJldHVybiAoZTogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAoIWNhblNvcnQpIHJldHVyblxuICAgICAgICA7KGUgYXMgYW55KS5wZXJzaXN0Py4oKVxuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZz8uKFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0KCkgPyB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQ/LihlKSA6IGZhbHNlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlVGFibGU6IDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KHRhYmxlOiBUYWJsZTxURGF0YT4pOiB2b2lkID0+IHtcbiAgICB0YWJsZS5zZXRTb3J0aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZT8uKHVwZGF0ZXIpXG4gICAgdGFibGUucmVzZXRTb3J0aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcoZGVmYXVsdFN0YXRlID8gW10gOiB0YWJsZS5pbml0aWFsU3RhdGU/LnNvcnRpbmcgPz8gW10pXG4gICAgfVxuICAgIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsKClcbiAgICB0YWJsZS5nZXRTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFNvcnRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFNvcnRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCh0YWJsZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsU29ydGluZyB8fCAhdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwoKVxuICAgIH1cbiAgfSxcbn1cbiIsImltcG9ydCB7IGZ1bmN0aW9uYWxVcGRhdGUsIGdldE1lbW9PcHRpb25zLCBtZW1vLCBSZXF1aXJlZEtleXMgfSBmcm9tICcuLi91dGlscydcblxuaW1wb3J0IHtcbiAgVXBkYXRlcixcbiAgVGFibGVPcHRpb25zUmVzb2x2ZWQsXG4gIFRhYmxlU3RhdGUsXG4gIFRhYmxlLFxuICBJbml0aWFsVGFibGVTdGF0ZSxcbiAgUm93LFxuICBDb2x1bW4sXG4gIFJvd01vZGVsLFxuICBDb2x1bW5EZWYsXG4gIFRhYmxlT3B0aW9ucyxcbiAgUm93RGF0YSxcbiAgVGFibGVNZXRhLFxuICBDb2x1bW5EZWZSZXNvbHZlZCxcbiAgR3JvdXBDb2x1bW5EZWYsXG4gIFRhYmxlRmVhdHVyZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5cbi8vXG5pbXBvcnQgeyBjcmVhdGVDb2x1bW4gfSBmcm9tICcuL2NvbHVtbidcbmltcG9ydCB7IEhlYWRlcnMgfSBmcm9tICcuL2hlYWRlcnMnXG4vL1xuXG5pbXBvcnQgeyBDb2x1bW5GYWNldGluZyB9IGZyb20gJy4uL2ZlYXR1cmVzL0NvbHVtbkZhY2V0aW5nJ1xuaW1wb3J0IHsgQ29sdW1uRmlsdGVyaW5nIH0gZnJvbSAnLi4vZmVhdHVyZXMvQ29sdW1uRmlsdGVyaW5nJ1xuaW1wb3J0IHsgQ29sdW1uR3JvdXBpbmcgfSBmcm9tICcuLi9mZWF0dXJlcy9Db2x1bW5Hcm91cGluZydcbmltcG9ydCB7IENvbHVtbk9yZGVyaW5nIH0gZnJvbSAnLi4vZmVhdHVyZXMvQ29sdW1uT3JkZXJpbmcnXG5pbXBvcnQgeyBDb2x1bW5QaW5uaW5nIH0gZnJvbSAnLi4vZmVhdHVyZXMvQ29sdW1uUGlubmluZydcbmltcG9ydCB7IENvbHVtblNpemluZyB9IGZyb20gJy4uL2ZlYXR1cmVzL0NvbHVtblNpemluZydcbmltcG9ydCB7IENvbHVtblZpc2liaWxpdHkgfSBmcm9tICcuLi9mZWF0dXJlcy9Db2x1bW5WaXNpYmlsaXR5J1xuaW1wb3J0IHsgR2xvYmFsRmFjZXRpbmcgfSBmcm9tICcuLi9mZWF0dXJlcy9HbG9iYWxGYWNldGluZydcbmltcG9ydCB7IEdsb2JhbEZpbHRlcmluZyB9IGZyb20gJy4uL2ZlYXR1cmVzL0dsb2JhbEZpbHRlcmluZydcbmltcG9ydCB7IFJvd0V4cGFuZGluZyB9IGZyb20gJy4uL2ZlYXR1cmVzL1Jvd0V4cGFuZGluZydcbmltcG9ydCB7IFJvd1BhZ2luYXRpb24gfSBmcm9tICcuLi9mZWF0dXJlcy9Sb3dQYWdpbmF0aW9uJ1xuaW1wb3J0IHsgUm93UGlubmluZyB9IGZyb20gJy4uL2ZlYXR1cmVzL1Jvd1Bpbm5pbmcnXG5pbXBvcnQgeyBSb3dTZWxlY3Rpb24gfSBmcm9tICcuLi9mZWF0dXJlcy9Sb3dTZWxlY3Rpb24nXG5pbXBvcnQgeyBSb3dTb3J0aW5nIH0gZnJvbSAnLi4vZmVhdHVyZXMvUm93U29ydGluZydcblxuY29uc3QgYnVpbHRJbkZlYXR1cmVzID0gW1xuICBIZWFkZXJzLFxuICBDb2x1bW5WaXNpYmlsaXR5LFxuICBDb2x1bW5PcmRlcmluZyxcbiAgQ29sdW1uUGlubmluZyxcbiAgQ29sdW1uRmFjZXRpbmcsXG4gIENvbHVtbkZpbHRlcmluZyxcbiAgR2xvYmFsRmFjZXRpbmcsIC8vZGVwZW5kcyBvbiBDb2x1bW5GYWNldGluZ1xuICBHbG9iYWxGaWx0ZXJpbmcsIC8vZGVwZW5kcyBvbiBDb2x1bW5GaWx0ZXJpbmdcbiAgUm93U29ydGluZyxcbiAgQ29sdW1uR3JvdXBpbmcsIC8vZGVwZW5kcyBvbiBSb3dTb3J0aW5nXG4gIFJvd0V4cGFuZGluZyxcbiAgUm93UGFnaW5hdGlvbixcbiAgUm93UGlubmluZyxcbiAgUm93U2VsZWN0aW9uLFxuICBDb2x1bW5TaXppbmcsXG5dIGFzIGNvbnN0XG5cbi8vXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29yZVRhYmxlU3RhdGUge31cblxuZXhwb3J0IGludGVyZmFjZSBDb3JlT3B0aW9uczxURGF0YSBleHRlbmRzIFJvd0RhdGE+IHtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGV4dHJhIGZlYXR1cmVzIHRoYXQgeW91IGNhbiBhZGQgdG8gdGhlIHRhYmxlIGluc3RhbmNlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjX2ZlYXR1cmVzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgX2ZlYXR1cmVzPzogVGFibGVGZWF0dXJlW11cbiAgLyoqXG4gICAqIFNldCB0aGlzIG9wdGlvbiB0byBvdmVycmlkZSBhbnkgb2YgdGhlIGBhdXRvUmVzZXQuLi5gIGZlYXR1cmUgb3B0aW9ucy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2F1dG9yZXNldGFsbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGF1dG9SZXNldEFsbD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBhcnJheSBvZiBjb2x1bW4gZGVmcyB0byB1c2UgZm9yIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2NvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBjb2x1bW5zOiBDb2x1bW5EZWY8VERhdGEsIGFueT5bXVxuICAvKipcbiAgICogVGhlIGRhdGEgZm9yIHRoZSB0YWJsZSB0byBkaXNwbGF5LiBUaGlzIGFycmF5IHNob3VsZCBtYXRjaCB0aGUgdHlwZSB5b3UgcHJvdmlkZWQgdG8gYHRhYmxlLnNldFJvd1R5cGU8Li4uPmAuIENvbHVtbnMgY2FuIGFjY2VzcyB0aGlzIGRhdGEgdmlhIHN0cmluZy9pbmRleCBvciBhIGZ1bmN0aW9uYWwgYWNjZXNzb3IuIFdoZW4gdGhlIGBkYXRhYCBvcHRpb24gY2hhbmdlcyByZWZlcmVuY2UsIHRoZSB0YWJsZSB3aWxsIHJlcHJvY2VzcyB0aGUgZGF0YS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2RhdGEpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBkYXRhOiBURGF0YVtdXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIHRvIG91dHB1dCBhbGwgZGVidWdnaW5nIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZGVidWdhbGwpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBkZWJ1Z0FsbD86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgdG8gb3V0cHV0IGNlbGwgZGVidWdnaW5nIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZGVidWdjZWxsc11cbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGRlYnVnQ2VsbHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIHRvIG91dHB1dCBjb2x1bW4gZGVidWdnaW5nIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZGVidWdjb2x1bW5zKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZGVidWdDb2x1bW5zPzogYm9vbGVhblxuICAvKipcbiAgICogU2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCB0byBvdXRwdXQgaGVhZGVyIGRlYnVnZ2luZyBpbmZvcm1hdGlvbiB0byB0aGUgY29uc29sZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2RlYnVnaGVhZGVycylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGRlYnVnSGVhZGVycz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgdG8gb3V0cHV0IHJvdyBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNkZWJ1Z3Jvd3MpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBkZWJ1Z1Jvd3M/OiBib29sZWFuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIHRvIG91dHB1dCB0YWJsZSBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNkZWJ1Z3RhYmxlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZGVidWdUYWJsZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIERlZmF1bHQgY29sdW1uIG9wdGlvbnMgdG8gdXNlIGZvciBhbGwgY29sdW1uIGRlZnMgc3VwcGxpZWQgdG8gdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZGVmYXVsdGNvbHVtbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGRlZmF1bHRDb2x1bW4/OiBQYXJ0aWFsPENvbHVtbkRlZjxURGF0YSwgdW5rbm93bj4+XG4gIC8qKlxuICAgKiBUaGlzIHJlcXVpcmVkIG9wdGlvbiBpcyBhIGZhY3RvcnkgZm9yIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgY29yZSByb3cgbW9kZWwgZm9yIHRoZSB0YWJsZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2dldGNvcmVyb3dtb2RlbClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGdldENvcmVSb3dNb2RlbDogKHRhYmxlOiBUYWJsZTxhbnk+KSA9PiAoKSA9PiBSb3dNb2RlbDxhbnk+XG4gIC8qKlxuICAgKiBUaGlzIG9wdGlvbmFsIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGVyaXZlIGEgdW5pcXVlIElEIGZvciBhbnkgZ2l2ZW4gcm93LiBJZiBub3QgcHJvdmlkZWQgdGhlIHJvd3MgaW5kZXggaXMgdXNlZCAobmVzdGVkIHJvd3Mgam9pbiB0b2dldGhlciB3aXRoIGAuYCB1c2luZyB0aGVpciBncmFuZHBhcmVudHMnIGluZGV4IGVnLiBgaW5kZXguaW5kZXguaW5kZXhgKS4gSWYgeW91IG5lZWQgdG8gaWRlbnRpZnkgaW5kaXZpZHVhbCByb3dzIHRoYXQgYXJlIG9yaWdpbmF0aW5nIGZyb20gYW55IHNlcnZlci1zaWRlIG9wZXJhdGlvbnMsIGl0J3Mgc3VnZ2VzdGVkIHlvdSB1c2UgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gYW4gSUQgdGhhdCBtYWtlcyBzZW5zZSByZWdhcmRsZXNzIG9mIG5ldHdvcmsgSU8vYW1iaWd1aXR5IGVnLiBhIHVzZXJJZCwgdGFza0lkLCBkYXRhYmFzZSBJRCBmaWVsZCwgZXRjLlxuICAgKiBAZXhhbXBsZSBnZXRSb3dJZDogcm93ID0+IHJvdy51c2VySWRcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2dldHJvd2lkKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZ2V0Um93SWQ/OiAob3JpZ2luYWxSb3c6IFREYXRhLCBpbmRleDogbnVtYmVyLCBwYXJlbnQ/OiBSb3c8VERhdGE+KSA9PiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoaXMgb3B0aW9uYWwgZnVuY3Rpb24gaXMgdXNlZCB0byBhY2Nlc3MgdGhlIHN1YiByb3dzIGZvciBhbnkgZ2l2ZW4gcm93LiBJZiB5b3UgYXJlIHVzaW5nIG5lc3RlZCByb3dzLCB5b3Ugd2lsbCBuZWVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgc3ViIHJvd3Mgb2JqZWN0IChvciB1bmRlZmluZWQpIGZyb20gdGhlIHJvdy5cbiAgICogQGV4YW1wbGUgZ2V0U3ViUm93czogcm93ID0+IHJvdy5zdWJSb3dzXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNnZXRzdWJyb3dzKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZ2V0U3ViUm93cz86IChvcmlnaW5hbFJvdzogVERhdGEsIGluZGV4OiBudW1iZXIpID0+IHVuZGVmaW5lZCB8IFREYXRhW11cbiAgLyoqXG4gICAqIFVzZSB0aGlzIG9wdGlvbiB0byBvcHRpb25hbGx5IHBhc3MgaW5pdGlhbCBzdGF0ZSB0byB0aGUgdGFibGUuIFRoaXMgc3RhdGUgd2lsbCBiZSB1c2VkIHdoZW4gcmVzZXR0aW5nIHZhcmlvdXMgdGFibGUgc3RhdGVzIGVpdGhlciBhdXRvbWF0aWNhbGx5IGJ5IHRoZSB0YWJsZSAoZWcuIGBvcHRpb25zLmF1dG9SZXNldFBhZ2VJbmRleGApIG9yIHZpYSBmdW5jdGlvbnMgbGlrZSBgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24oKWAuIE1vc3QgcmVzZXQgZnVuY3Rpb24gYWxsb3cgeW91IG9wdGlvbmFsbHkgcGFzcyBhIGZsYWcgdG8gcmVzZXQgdG8gYSBibGFuay9kZWZhdWx0IHN0YXRlIGluc3RlYWQgb2YgdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIFRhYmxlIHN0YXRlIHdpbGwgbm90IGJlIHJlc2V0IHdoZW4gdGhpcyBvYmplY3QgY2hhbmdlcywgd2hpY2ggYWxzbyBtZWFucyB0aGF0IHRoZSBpbml0aWFsIHN0YXRlIG9iamVjdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICpcbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2luaXRpYWxzdGF0ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGluaXRpYWxTdGF0ZT86IEluaXRpYWxUYWJsZVN0YXRlXG4gIC8qKlxuICAgKiBUaGlzIG9wdGlvbiBpcyB1c2VkIHRvIG9wdGlvbmFsbHkgaW1wbGVtZW50IHRoZSBtZXJnaW5nIG9mIHRhYmxlIG9wdGlvbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNtZXJnZW9wdGlvbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBtZXJnZU9wdGlvbnM/OiAoXG4gICAgZGVmYXVsdE9wdGlvbnM6IFRhYmxlT3B0aW9uczxURGF0YT4sXG4gICAgb3B0aW9uczogUGFydGlhbDxUYWJsZU9wdGlvbnM8VERhdGE+PlxuICApID0+IFRhYmxlT3B0aW9uczxURGF0YT5cbiAgLyoqXG4gICAqIFlvdSBjYW4gcGFzcyBhbnkgb2JqZWN0IHRvIGBvcHRpb25zLm1ldGFgIGFuZCBhY2Nlc3MgaXQgYW55d2hlcmUgdGhlIGB0YWJsZWAgaXMgYXZhaWxhYmxlIHZpYSBgdGFibGUub3B0aW9ucy5tZXRhYC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI21ldGEpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBtZXRhPzogVGFibGVNZXRhPFREYXRhPlxuICAvKipcbiAgICogVGhlIGBvblN0YXRlQ2hhbmdlYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gb3B0aW9uYWxseSBsaXN0ZW4gdG8gc3RhdGUgY2hhbmdlcyB3aXRoaW4gdGhlIHRhYmxlLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjb25zdGF0ZWNoYW5nZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIG9uU3RhdGVDaGFuZ2U6ICh1cGRhdGVyOiBVcGRhdGVyPFRhYmxlU3RhdGU+KSA9PiB2b2lkXG4gIC8qKlxuICAgKiBWYWx1ZSB1c2VkIHdoZW4gdGhlIGRlc2lyZWQgdmFsdWUgaXMgbm90IGZvdW5kIGluIHRoZSBkYXRhLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjcmVuZGVyZmFsbGJhY2t2YWx1ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIHJlbmRlckZhbGxiYWNrVmFsdWU6IGFueVxuICAvKipcbiAgICogVGhlIGBzdGF0ZWAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIG9wdGlvbmFsbHkgX2NvbnRyb2xfIHBhcnQgb3IgYWxsIG9mIHRoZSB0YWJsZSBzdGF0ZS4gVGhlIHN0YXRlIHlvdSBwYXNzIGhlcmUgd2lsbCBtZXJnZSB3aXRoIGFuZCBvdmVyd3JpdGUgdGhlIGludGVybmFsIGF1dG9tYXRpY2FsbHktbWFuYWdlZCBzdGF0ZSB0byBwcm9kdWNlIHRoZSBmaW5hbCBzdGF0ZSBmb3IgdGhlIHRhYmxlLiBZb3UgY2FuIGFsc28gbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgdmlhIHRoZSBgb25TdGF0ZUNoYW5nZWAgb3B0aW9uLlxuICAgKiA+IE5vdGU6IEFueSBzdGF0ZSBwYXNzZWQgaW4gaGVyZSB3aWxsIG92ZXJyaWRlIGJvdGggdGhlIGludGVybmFsIHN0YXRlIGFuZCBhbnkgb3RoZXIgYGluaXRpYWxTdGF0ZWAgeW91IHByb3ZpZGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNzdGF0ZSlcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIHN0YXRlOiBQYXJ0aWFsPFRhYmxlU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29yZUluc3RhbmNlPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ge1xuICBfZmVhdHVyZXM6IHJlYWRvbmx5IFRhYmxlRmVhdHVyZVtdXG4gIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6ICgpID0+IFJlY29yZDxzdHJpbmcsIENvbHVtbjxURGF0YSwgdW5rbm93bj4+XG4gIF9nZXRDb2x1bW5EZWZzOiAoKSA9PiBDb2x1bW5EZWY8VERhdGEsIHVua25vd24+W11cbiAgX2dldENvcmVSb3dNb2RlbD86ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICBfZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4gUGFydGlhbDxDb2x1bW5EZWY8VERhdGEsIHVua25vd24+PlxuICBfZ2V0Um93SWQ6IChfOiBURGF0YSwgaW5kZXg6IG51bWJlciwgcGFyZW50PzogUm93PFREYXRhPikgPT4gc3RyaW5nXG4gIF9xdWV1ZTogKGNiOiAoKSA9PiB2b2lkKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBjb2x1bW5zIGluIHRoZSB0YWJsZSBpbiB0aGVpciBub3JtYWxpemVkIGFuZCBuZXN0ZWQgaGllcmFyY2h5LlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZ2V0YWxsY29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGdldEFsbENvbHVtbnM6ICgpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgY29sdW1ucyBpbiB0aGUgdGFibGUgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZ2V0YWxsZmxhdGNvbHVtbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBnZXRBbGxGbGF0Q29sdW1uczogKCkgPT4gQ29sdW1uPFREYXRhLCB1bmtub3duPltdXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBsZWFmLW5vZGUgY29sdW1ucyBpbiB0aGUgdGFibGUgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGxldmVsLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgcGFyZW50IGNvbHVtbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNnZXRhbGxsZWFmY29sdW1ucylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGdldEFsbExlYWZDb2x1bW5zOiAoKSA9PiBDb2x1bW48VERhdGEsIHVua25vd24+W11cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUgY29sdW1uIGJ5IGl0cyBJRC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2dldGNvbHVtbilcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGdldENvbHVtbjogKGNvbHVtbklkOiBzdHJpbmcpID0+IENvbHVtbjxURGF0YSwgdW5rbm93bj4gfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvcmUgcm93IG1vZGVsIGJlZm9yZSBhbnkgcHJvY2Vzc2luZyBoYXMgYmVlbiBhcHBsaWVkLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZ2V0Y29yZXJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZ2V0Q29yZVJvd01vZGVsOiAoKSA9PiBSb3dNb2RlbDxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdyB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2dldHJvdylcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIGdldFJvdzogKGlkOiBzdHJpbmcsIHNlYXJjaEFsbD86IGJvb2xlYW4pID0+IFJvdzxURGF0YT5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbmFsIG1vZGVsIGFmdGVyIGFsbCBwcm9jZXNzaW5nIGZyb20gb3RoZXIgdXNlZCBmZWF0dXJlcyBoYXMgYmVlbiBhcHBsaWVkLiBUaGlzIGlzIHRoZSByb3cgbW9kZWwgdGhhdCBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI2dldHJvd21vZGVsKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgZ2V0Um93TW9kZWw6ICgpID0+IFJvd01vZGVsPFREYXRhPlxuICAvKipcbiAgICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGdldCB0aGUgdGFibGUncyBjdXJyZW50IHN0YXRlLiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGFuZCBpdHMgc3RhdGUsIGVzcGVjaWFsbHkgd2hlbiBtYW5hZ2luZyB0aGUgdGFibGUgc3RhdGUgbWFudWFsbHkuIEl0IGlzIHRoZSBleGFjdCBzYW1lIHN0YXRlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgdGFibGUgZm9yIGV2ZXJ5IGZlYXR1cmUgYW5kIGZ1bmN0aW9uIGl0IHByb3ZpZGVzLlxuICAgKiBAbGluayBbQVBJIERvY3NdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvYXBpL2NvcmUvdGFibGUjZ2V0c3RhdGUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBnZXRTdGF0ZTogKCkgPT4gVGFibGVTdGF0ZVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcmVzb2x2ZWQgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgdGFibGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNpbml0aWFsc3RhdGUpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBpbml0aWFsU3RhdGU6IFRhYmxlU3RhdGVcbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IHJlZmVyZW5jZSB0byB0aGUgdGFibGUncyBjdXJyZW50IG9wdGlvbnMuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNvcHRpb25zKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgb3B0aW9uczogUmVxdWlyZWRLZXlzPFRhYmxlT3B0aW9uc1Jlc29sdmVkPFREYXRhPiwgJ3N0YXRlJz5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBmdW5jdGlvbiB0byByZXNldCB0aGUgdGFibGUgc3RhdGUgdG8gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqIEBsaW5rIFtBUEkgRG9jc10oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9hcGkvY29yZS90YWJsZSNyZXNldClcbiAgICogQGxpbmsgW0d1aWRlXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2d1aWRlL3RhYmxlcylcbiAgICovXG4gIHJlc2V0OiAoKSA9PiB2b2lkXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgdGFibGUgb3B0aW9ucy5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI3NldG9wdGlvbnMpXG4gICAqIEBsaW5rIFtHdWlkZV0oaHR0cHM6Ly90YW5zdGFjay5jb20vdGFibGUvdjgvZG9jcy9ndWlkZS90YWJsZXMpXG4gICAqL1xuICBzZXRPcHRpb25zOiAobmV3T3B0aW9uczogVXBkYXRlcjxUYWJsZU9wdGlvbnNSZXNvbHZlZDxURGF0YT4+KSA9PiB2b2lkXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB0YWJsZSBzdGF0ZS5cbiAgICogQGxpbmsgW0FQSSBEb2NzXShodHRwczovL3RhbnN0YWNrLmNvbS90YWJsZS92OC9kb2NzL2FwaS9jb3JlL3RhYmxlI3NldHN0YXRlKVxuICAgKiBAbGluayBbR3VpZGVdKGh0dHBzOi8vdGFuc3RhY2suY29tL3RhYmxlL3Y4L2RvY3MvZ3VpZGUvdGFibGVzKVxuICAgKi9cbiAgc2V0U3RhdGU6ICh1cGRhdGVyOiBVcGRhdGVyPFRhYmxlU3RhdGU+KSA9PiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJsZTxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICBvcHRpb25zOiBUYWJsZU9wdGlvbnNSZXNvbHZlZDxURGF0YT5cbik6IFRhYmxlPFREYXRhPiB7XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKG9wdGlvbnMuZGVidWdBbGwgfHwgb3B0aW9ucy5kZWJ1Z1RhYmxlKVxuICApIHtcbiAgICBjb25zb2xlLmluZm8oJ0NyZWF0aW5nIFRhYmxlIEluc3RhbmNlLi4uJylcbiAgfVxuXG4gIGNvbnN0IF9mZWF0dXJlcyA9IFsuLi5idWlsdEluRmVhdHVyZXMsIC4uLihvcHRpb25zLl9mZWF0dXJlcyA/PyBbXSldXG5cbiAgbGV0IHRhYmxlID0geyBfZmVhdHVyZXMgfSBhcyB1bmtub3duIGFzIFRhYmxlPFREYXRhPlxuXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zPy4odGFibGUpKVxuICB9LCB7fSkgYXMgVGFibGVPcHRpb25zUmVzb2x2ZWQ8VERhdGE+XG5cbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gKG9wdGlvbnM6IFRhYmxlT3B0aW9uc1Jlc29sdmVkPFREYXRhPikgPT4ge1xuICAgIGlmICh0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZTogQ29yZVRhYmxlU3RhdGUgPSB7fVxuXG4gIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgLi4uY29yZUluaXRpYWxTdGF0ZSxcbiAgICAuLi4ob3B0aW9ucy5pbml0aWFsU3RhdGUgPz8ge30pLFxuICB9IGFzIFRhYmxlU3RhdGVcblxuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBpbml0aWFsU3RhdGUgPSAoZmVhdHVyZS5nZXRJbml0aWFsU3RhdGU/Lihpbml0aWFsU3RhdGUpID8/XG4gICAgICBpbml0aWFsU3RhdGUpIGFzIFRhYmxlU3RhdGVcbiAgfSlcblxuICBjb25zdCBxdWV1ZWQ6ICgoKSA9PiB2b2lkKVtdID0gW11cbiAgbGV0IHF1ZXVlZFRpbWVvdXQgPSBmYWxzZVxuXG4gIGNvbnN0IGNvcmVJbnN0YW5jZTogQ29yZUluc3RhbmNlPFREYXRhPiA9IHtcbiAgICBfZmVhdHVyZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0sXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIF9xdWV1ZTogY2IgPT4ge1xuICAgICAgcXVldWVkLnB1c2goY2IpXG5cbiAgICAgIGlmICghcXVldWVkVGltZW91dCkge1xuICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gdHJ1ZVxuXG4gICAgICAgIC8vIFNjaGVkdWxlIGEgbWljcm90YXNrIHRvIHJ1biB0aGUgcXVldWVkIGNhbGxiYWNrcyBhZnRlclxuICAgICAgICAvLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIChyZW5kZXIsIGV0YykgaGFzIGZpbmlzaGVkLlxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHF1ZXVlZC5zaGlmdCgpISgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRTdGF0ZSh0YWJsZS5pbml0aWFsU3RhdGUpXG4gICAgfSxcbiAgICBzZXRPcHRpb25zOiB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIHRhYmxlLm9wdGlvbnMpXG4gICAgICB0YWJsZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG5ld09wdGlvbnMpIGFzIFJlcXVpcmVkS2V5czxcbiAgICAgICAgVGFibGVPcHRpb25zUmVzb2x2ZWQ8VERhdGE+LFxuICAgICAgICAnc3RhdGUnXG4gICAgICA+XG4gICAgfSxcblxuICAgIGdldFN0YXRlOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5zdGF0ZSBhcyBUYWJsZVN0YXRlXG4gICAgfSxcblxuICAgIHNldFN0YXRlOiAodXBkYXRlcjogVXBkYXRlcjxUYWJsZVN0YXRlPikgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlPy4odXBkYXRlcilcbiAgICB9LFxuXG4gICAgX2dldFJvd0lkOiAocm93OiBURGF0YSwgaW5kZXg6IG51bWJlciwgcGFyZW50PzogUm93PFREYXRhPikgPT5cbiAgICAgIHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQ/Lihyb3csIGluZGV4LCBwYXJlbnQpID8/XG4gICAgICBgJHtwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXh9YCxcblxuICAgIGdldENvcmVSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldENvcmVSb3dNb2RlbCh0YWJsZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwhKClcbiAgICB9LFxuXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxuICAgIC8vIGV4cGFuZGVkIHJvd3MsIHdoaWNoIHRoZW4gd29yayB0aGVpciB3YXkgdXBcblxuICAgIGdldFJvd01vZGVsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKClcbiAgICB9LFxuICAgIC8vaW4gbmV4dCB2ZXJzaW9uLCB3ZSBzaG91bGQganVzdCBwYXNzIGluIHRoZSByb3cgbW9kZWwgYXMgdGhlIG9wdGlvbmFsIDJuZCBhcmdcbiAgICBnZXRSb3c6IChpZDogc3RyaW5nLCBzZWFyY2hBbGw/OiBib29sZWFuKSA9PiB7XG4gICAgICBsZXQgcm93ID0gKFxuICAgICAgICBzZWFyY2hBbGwgPyB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSA6IHRhYmxlLmdldFJvd01vZGVsKClcbiAgICAgICkucm93c0J5SWRbaWRdXG5cbiAgICAgIGlmICghcm93KSB7XG4gICAgICAgIHJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLnJvd3NCeUlkW2lkXVxuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtpZH1gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3dcbiAgICB9LFxuICAgIF9nZXREZWZhdWx0Q29sdW1uRGVmOiBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGVmYXVsdENvbHVtbl0sXG4gICAgICBkZWZhdWx0Q29sdW1uID0+IHtcbiAgICAgICAgZGVmYXVsdENvbHVtbiA9IChkZWZhdWx0Q29sdW1uID8/IHt9KSBhcyBQYXJ0aWFsPFxuICAgICAgICAgIENvbHVtbkRlZjxURGF0YSwgdW5rbm93bj5cbiAgICAgICAgPlxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyOiBwcm9wcyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHByb3BzLmhlYWRlci5jb2x1bW5cbiAgICAgICAgICAgICAgLmNvbHVtbkRlZiBhcyBDb2x1bW5EZWZSZXNvbHZlZDxURGF0YT5cblxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb2x1bW5EZWYuaWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8vIGZvb3RlcjogcHJvcHMgPT4gcHJvcHMuaGVhZGVyLmNvbHVtbi5pZCxcbiAgICAgICAgICBjZWxsOiBwcm9wcyA9PiBwcm9wcy5yZW5kZXJWYWx1ZTxhbnk+KCk/LnRvU3RyaW5nPy4oKSA/PyBudWxsLFxuICAgICAgICAgIC4uLnRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWY/LigpKVxuICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgICAgICB9IGFzIFBhcnRpYWw8Q29sdW1uRGVmPFREYXRhLCB1bmtub3duPj5cbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ19nZXREZWZhdWx0Q29sdW1uRGVmJylcbiAgICApLFxuXG4gICAgX2dldENvbHVtbkRlZnM6ICgpID0+IHRhYmxlLm9wdGlvbnMuY29sdW1ucyxcblxuICAgIGdldEFsbENvbHVtbnM6IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuX2dldENvbHVtbkRlZnMoKV0sXG4gICAgICBjb2x1bW5EZWZzID0+IHtcbiAgICAgICAgY29uc3QgcmVjdXJzZUNvbHVtbnMgPSAoXG4gICAgICAgICAgY29sdW1uRGVmczogQ29sdW1uRGVmPFREYXRhLCB1bmtub3duPltdLFxuICAgICAgICAgIHBhcmVudD86IENvbHVtbjxURGF0YSwgdW5rbm93bj4sXG4gICAgICAgICAgZGVwdGggPSAwXG4gICAgICAgICk6IENvbHVtbjxURGF0YSwgdW5rbm93bj5bXSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudClcblxuICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdDb2x1bW5EZWYgPSBjb2x1bW5EZWYgYXMgR3JvdXBDb2x1bW5EZWY8XG4gICAgICAgICAgICAgIFREYXRhLFxuICAgICAgICAgICAgICB1bmtub3duXG4gICAgICAgICAgICA+XG5cbiAgICAgICAgICAgIGNvbHVtbi5jb2x1bW5zID0gZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1uc1xuICAgICAgICAgICAgICA/IHJlY3Vyc2VDb2x1bW5zKGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMsIGNvbHVtbiwgZGVwdGggKyAxKVxuICAgICAgICAgICAgICA6IFtdXG5cbiAgICAgICAgICAgIHJldHVybiBjb2x1bW5cbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2VDb2x1bW5zKGNvbHVtbkRlZnMpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxDb2x1bW5zJylcbiAgICApLFxuXG4gICAgZ2V0QWxsRmxhdENvbHVtbnM6IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpXSxcbiAgICAgIGFsbENvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbi5nZXRGbGF0Q29sdW1ucygpXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxGbGF0Q29sdW1ucycpXG4gICAgKSxcblxuICAgIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKV0sXG4gICAgICBmbGF0Q29sdW1ucyA9PiB7XG4gICAgICAgIHJldHVybiBmbGF0Q29sdW1ucy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY29sdW1uKSA9PiB7XG4gICAgICAgICAgICBhY2NbY29sdW1uLmlkXSA9IGNvbHVtblxuICAgICAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgICAgIH0sXG4gICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgQ29sdW1uPFREYXRhLCB1bmtub3duPj5cbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnNCeUlkJylcbiAgICApLFxuXG4gICAgZ2V0QWxsTGVhZkNvbHVtbnM6IG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sXG4gICAgICAoYWxsQ29sdW1ucywgb3JkZXJDb2x1bW5zKSA9PiB7XG4gICAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpXG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpXG4gICAgICB9LFxuICAgICAgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxMZWFmQ29sdW1ucycpXG4gICAgKSxcblxuICAgIGdldENvbHVtbjogY29sdW1uSWQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29sdW1uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUYWJsZV0gQ29sdW1uIHdpdGggaWQgJyR7Y29sdW1uSWR9JyBkb2VzIG5vdCBleGlzdC5gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sdW1uXG4gICAgfSxcbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24odGFibGUsIGNvcmVJbnN0YW5jZSlcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaW5kZXhdXG4gICAgZmVhdHVyZT8uY3JlYXRlVGFibGU/Lih0YWJsZSlcbiAgfVxuXG4gIHJldHVybiB0YWJsZVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlUm93IH0gZnJvbSAnLi4vY29yZS9yb3cnXG5pbXBvcnQgeyBUYWJsZSwgUm93LCBSb3dNb2RlbCwgUm93RGF0YSB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgZ2V0TWVtb09wdGlvbnMsIG1lbW8gfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvcmVSb3dNb2RlbDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KCk6IChcbiAgdGFibGU6IFRhYmxlPFREYXRhPlxuKSA9PiAoKSA9PiBSb3dNb2RlbDxURGF0YT4ge1xuICByZXR1cm4gdGFibGUgPT5cbiAgICBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGF0YV0sXG4gICAgICAoXG4gICAgICAgIGRhdGFcbiAgICAgICk6IHtcbiAgICAgICAgcm93czogUm93PFREYXRhPltdXG4gICAgICAgIGZsYXRSb3dzOiBSb3c8VERhdGE+W11cbiAgICAgICAgcm93c0J5SWQ6IFJlY29yZDxzdHJpbmcsIFJvdzxURGF0YT4+XG4gICAgICB9ID0+IHtcbiAgICAgICAgY29uc3Qgcm93TW9kZWw6IFJvd01vZGVsPFREYXRhPiA9IHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9LFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWNjZXNzUm93cyA9IChcbiAgICAgICAgICBvcmlnaW5hbFJvd3M6IFREYXRhW10sXG4gICAgICAgICAgZGVwdGggPSAwLFxuICAgICAgICAgIHBhcmVudFJvdz86IFJvdzxURGF0YT5cbiAgICAgICAgKTogUm93PFREYXRhPltdID0+IHtcbiAgICAgICAgICBjb25zdCByb3dzID0gW10gYXMgUm93PFREYXRhPltdXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBleHBlbnNpdmUgY2hlY2sgYXQgc2NhbGUsIHNvIHdlIHNob3VsZCBtb3ZlIGl0IHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmU/XG4gICAgICAgICAgICAvLyBpZiAoIWlkKSB7XG4gICAgICAgICAgICAvLyAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3dJZCBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApXG4gICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcm93XG4gICAgICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3coXG4gICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICB0YWJsZS5fZ2V0Um93SWQob3JpZ2luYWxSb3dzW2ldISwgaSwgcGFyZW50Um93KSxcbiAgICAgICAgICAgICAgb3JpZ2luYWxSb3dzW2ldISxcbiAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcGFyZW50Um93Py5pZFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcbiAgICAgICAgICAgIHJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KVxuICAgICAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBieSBpdHMgSURcbiAgICAgICAgICAgIHJvd01vZGVsLnJvd3NCeUlkW3Jvdy5pZF0gPSByb3dcbiAgICAgICAgICAgIC8vIFB1c2ggdGFibGUgcm93IGludG8gcGFyZW50XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcbiAgICAgICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cyhcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFJvd3NbaV0hLFxuICAgICAgICAgICAgICAgIGlcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIC8vIFRoZW4gcmVjdXJzaXZlbHkgYWNjZXNzIHRoZW1cbiAgICAgICAgICAgICAgaWYgKHJvdy5vcmlnaW5hbFN1YlJvd3M/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gYWNjZXNzUm93cyhyb3cub3JpZ2luYWxTdWJSb3dzLCBkZXB0aCArIDEsIHJvdylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByb3dzXG4gICAgICAgIH1cblxuICAgICAgICByb3dNb2RlbC5yb3dzID0gYWNjZXNzUm93cyhkYXRhKVxuXG4gICAgICAgIHJldHVybiByb3dNb2RlbFxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFJvd01vZGVsJywgKCkgPT5cbiAgICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpXG4gICAgICApXG4gICAgKVxufVxuIiwiaW1wb3J0IHsgVGFibGUsIFJvdywgUm93TW9kZWwsIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHBhbmRlZFJvd01vZGVsPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oKTogKFxuICB0YWJsZTogVGFibGU8VERhdGE+XG4pID0+ICgpID0+IFJvd01vZGVsPFREYXRhPiB7XG4gIHJldHVybiB0YWJsZSA9PlxuICAgIG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQsXG4gICAgICAgIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKSxcbiAgICAgICAgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyxcbiAgICAgIF0sXG4gICAgICAoZXhwYW5kZWQsIHJvd01vZGVsLCBwYWdpbmF0ZUV4cGFuZGVkUm93cykgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8XG4gICAgICAgICAgKGV4cGFuZGVkICE9PSB0cnVlICYmICFPYmplY3Qua2V5cyhleHBhbmRlZCA/PyB7fSkubGVuZ3RoKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gcm93TW9kZWxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgICAvLyBPbmx5IGV4cGFuZCByb3dzIGF0IHRoaXMgcG9pbnQgaWYgdGhleSBhcmUgYmVpbmcgcGFnaW5hdGVkXG4gICAgICAgICAgcmV0dXJuIHJvd01vZGVsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwYW5kUm93cyhyb3dNb2RlbClcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRFeHBhbmRlZFJvd01vZGVsJylcbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRSb3dzPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ocm93TW9kZWw6IFJvd01vZGVsPFREYXRhPikge1xuICBjb25zdCBleHBhbmRlZFJvd3M6IFJvdzxURGF0YT5bXSA9IFtdXG5cbiAgY29uc3QgaGFuZGxlUm93ID0gKHJvdzogUm93PFREYXRhPikgPT4ge1xuICAgIGV4cGFuZGVkUm93cy5wdXNoKHJvdylcblxuICAgIGlmIChyb3cuc3ViUm93cz8ubGVuZ3RoICYmIHJvdy5nZXRJc0V4cGFuZGVkKCkpIHtcbiAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KVxuICAgIH1cbiAgfVxuXG4gIHJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpXG5cbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZCxcbiAgfVxufVxuIiwiaW1wb3J0IHsgVGFibGUsIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oKTogKFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICBjb2x1bW5JZDogc3RyaW5nXG4pID0+ICgpID0+IHVuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT5cbiAgICBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldENvbHVtbihjb2x1bW5JZCk/LmdldEZhY2V0ZWRSb3dNb2RlbCgpXSxcbiAgICAgIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgICAgICAgY29uc3QgdW5pcXVlVmFsdWVzID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzXG4gICAgICAgICAgLmZsYXRNYXAoZmxhdFJvdyA9PiBmbGF0Um93LmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCkgPz8gW10pXG4gICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgLmZpbHRlcih2YWx1ZSA9PiAhTnVtYmVyLmlzTmFOKHZhbHVlKSlcblxuICAgICAgICBpZiAoIXVuaXF1ZVZhbHVlcy5sZW5ndGgpIHJldHVyblxuXG4gICAgICAgIGxldCBmYWNldGVkTWluVmFsdWUgPSB1bmlxdWVWYWx1ZXNbMF0hXG4gICAgICAgIGxldCBmYWNldGVkTWF4VmFsdWUgPSB1bmlxdWVWYWx1ZXNbdW5pcXVlVmFsdWVzLmxlbmd0aCAtIDFdIVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdW5pcXVlVmFsdWVzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlIDwgZmFjZXRlZE1pblZhbHVlKSBmYWNldGVkTWluVmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gZmFjZXRlZE1heFZhbHVlKSBmYWNldGVkTWF4VmFsdWUgPSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtmYWNldGVkTWluVmFsdWUsIGZhY2V0ZWRNYXhWYWx1ZV1cbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkTWluTWF4VmFsdWVzJylcbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVSb3cgfSBmcm9tICcuLi9jb3JlL3JvdydcbmltcG9ydCB7IFJvdywgUm93TW9kZWwsIFRhYmxlLCBSb3dEYXRhIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJSb3dzPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gIHJvd3M6IFJvdzxURGF0YT5bXSxcbiAgZmlsdGVyUm93SW1wbDogKHJvdzogUm93PFREYXRhPikgPT4gYW55LFxuICB0YWJsZTogVGFibGU8VERhdGE+XG4pIHtcbiAgaWYgKHRhYmxlLm9wdGlvbnMuZmlsdGVyRnJvbUxlYWZSb3dzKSB7XG4gICAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpXG59XG5cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oXG4gIHJvd3NUb0ZpbHRlcjogUm93PFREYXRhPltdLFxuICBmaWx0ZXJSb3c6IChyb3c6IFJvdzxURGF0YT4pID0+IFJvdzxURGF0YT5bXSxcbiAgdGFibGU6IFRhYmxlPFREYXRhPlxuKTogUm93TW9kZWw8VERhdGE+IHtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93czogUm93PFREYXRhPltdID0gW11cbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZDogUmVjb3JkPHN0cmluZywgUm93PFREYXRhPj4gPSB7fVxuICBjb25zdCBtYXhEZXB0aCA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoID8/IDEwMFxuXG4gIGNvbnN0IHJlY3Vyc2VGaWx0ZXJSb3dzID0gKHJvd3NUb0ZpbHRlcjogUm93PFREYXRhPltdLCBkZXB0aCA9IDApID0+IHtcbiAgICBjb25zdCByb3dzOiBSb3c8VERhdGE+W10gPSBbXVxuXG4gICAgLy8gRmlsdGVyIGZyb20gY2hpbGRyZW4gdXAgZmlyc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXSFcblxuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcm93LmlkLFxuICAgICAgICByb3cub3JpZ2luYWwsXG4gICAgICAgIHJvdy5pbmRleCxcbiAgICAgICAgcm93LmRlcHRoLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHJvdy5wYXJlbnRJZFxuICAgICAgKVxuICAgICAgbmV3Um93LmNvbHVtbkZpbHRlcnMgPSByb3cuY29sdW1uRmlsdGVyc1xuXG4gICAgICBpZiAocm93LnN1YlJvd3M/Lmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSlcbiAgICAgICAgcm93ID0gbmV3Um93XG5cbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpICYmICFuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KVxuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvd1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KVxuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvd1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93ID0gbmV3Um93XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpXG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb3dzXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWQsXG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tUm9vdDxURGF0YSBleHRlbmRzIFJvd0RhdGE+KFxuICByb3dzVG9GaWx0ZXI6IFJvdzxURGF0YT5bXSxcbiAgZmlsdGVyUm93OiAocm93OiBSb3c8VERhdGE+KSA9PiBhbnksXG4gIHRhYmxlOiBUYWJsZTxURGF0YT5cbik6IFJvd01vZGVsPFREYXRhPiB7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3M6IFJvdzxURGF0YT5bXSA9IFtdXG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQ6IFJlY29yZDxzdHJpbmcsIFJvdzxURGF0YT4+ID0ge31cbiAgY29uc3QgbWF4RGVwdGggPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCA/PyAxMDBcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSAocm93c1RvRmlsdGVyOiBSb3c8VERhdGE+W10sIGRlcHRoID0gMCkgPT4ge1xuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3M6IFJvdzxURGF0YT5bXSA9IFtdXG5cbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV0hXG5cbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KVxuXG4gICAgICBpZiAocGFzcykge1xuICAgICAgICBpZiAocm93LnN1YlJvd3M/Lmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICByb3cuaWQsXG4gICAgICAgICAgICByb3cub3JpZ2luYWwsXG4gICAgICAgICAgICByb3cuaW5kZXgsXG4gICAgICAgICAgICByb3cuZGVwdGgsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICByb3cucGFyZW50SWRcbiAgICAgICAgICApXG4gICAgICAgICAgbmV3Um93LnN1YlJvd3MgPSByZWN1cnNlRmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKVxuICAgICAgICAgIHJvdyA9IG5ld1Jvd1xuICAgICAgICB9XG5cbiAgICAgICAgcm93cy5wdXNoKHJvdylcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdylcbiAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3NcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZCxcbiAgfVxufVxuIiwiaW1wb3J0IHsgVGFibGUsIFJvd01vZGVsLCBSb3csIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBmaWx0ZXJSb3dzIH0gZnJvbSAnLi9maWx0ZXJSb3dzVXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWw8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPigpOiAoXG4gIHRhYmxlOiBUYWJsZTxURGF0YT4sXG4gIGNvbHVtbklkOiBzdHJpbmdcbikgPT4gKCkgPT4gUm93TW9kZWw8VERhdGE+IHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+XG4gICAgbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsXG4gICAgICAgIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyLFxuICAgICAgICB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCksXG4gICAgICBdLFxuICAgICAgKHByZVJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fFxuICAgICAgICAgICghY29sdW1uRmlsdGVycz8ubGVuZ3RoICYmICFnbG9iYWxGaWx0ZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBwcmVSb3dNb2RlbFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IFtcbiAgICAgICAgICAuLi5jb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbklkKSxcbiAgICAgICAgICBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWQsXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIHN0cmluZ1tdXG5cbiAgICAgICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSAocm93OiBSb3c8VERhdGE+KSA9PiB7XG4gICAgICAgICAgLy8gSG9yaXpvbnRhbGx5IGZpbHRlciByb3dzIHRocm91Z2ggZWFjaCBjb2x1bW5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldIV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRSb3dNb2RlbCcpXG4gICAgKVxufVxuIiwiaW1wb3J0IHsgVGFibGUsIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGYWNldGVkVW5pcXVlVmFsdWVzPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oKTogKFxuICB0YWJsZTogVGFibGU8VERhdGE+LFxuICBjb2x1bW5JZDogc3RyaW5nXG4pID0+ICgpID0+IE1hcDxhbnksIG51bWJlcj4ge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT5cbiAgICBtZW1vKFxuICAgICAgKCkgPT4gW3RhYmxlLmdldENvbHVtbihjb2x1bW5JZCk/LmdldEZhY2V0ZWRSb3dNb2RlbCgpXSxcbiAgICAgIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gbmV3IE1hcCgpXG5cbiAgICAgICAgbGV0IGZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBuZXcgTWFwPGFueSwgbnVtYmVyPigpXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZXMgPVxuICAgICAgICAgICAgZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzW2ldIS5nZXRVbmlxdWVWYWx1ZXM8bnVtYmVyPihjb2x1bW5JZClcblxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tqXSFcblxuICAgICAgICAgICAgaWYgKGZhY2V0ZWRVbmlxdWVWYWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldChcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAoZmFjZXRlZFVuaXF1ZVZhbHVlcy5nZXQodmFsdWUpID8/IDApICsgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFjZXRlZFVuaXF1ZVZhbHVlc1xuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKFxuICAgICAgICB0YWJsZS5vcHRpb25zLFxuICAgICAgICAnZGVidWdUYWJsZScsXG4gICAgICAgIGBnZXRGYWNldGVkVW5pcXVlVmFsdWVzXyR7Y29sdW1uSWR9YFxuICAgICAgKVxuICAgIClcbn1cbiIsImltcG9ydCB7IFJlc29sdmVkQ29sdW1uRmlsdGVyIH0gZnJvbSAnLi4vZmVhdHVyZXMvQ29sdW1uRmlsdGVyaW5nJ1xuaW1wb3J0IHsgVGFibGUsIFJvd01vZGVsLCBSb3csIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBmaWx0ZXJSb3dzIH0gZnJvbSAnLi9maWx0ZXJSb3dzVXRpbHMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWx0ZXJlZFJvd01vZGVsPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oKTogKFxuICB0YWJsZTogVGFibGU8VERhdGE+XG4pID0+ICgpID0+IFJvd01vZGVsPFREYXRhPiB7XG4gIHJldHVybiB0YWJsZSA9PlxuICAgIG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSxcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLFxuICAgICAgICB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlcixcbiAgICAgIF0sXG4gICAgICAocm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8XG4gICAgICAgICAgKCFjb2x1bW5GaWx0ZXJzPy5sZW5ndGggJiYgIWdsb2JhbEZpbHRlcilcbiAgICAgICAgKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0hLmNvbHVtbkZpbHRlcnMgPSB7fVxuICAgICAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0hLmNvbHVtbkZpbHRlcnNNZXRhID0ge31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvd01vZGVsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkZpbHRlcnM6IFJlc29sdmVkQ29sdW1uRmlsdGVyPFREYXRhPltdID0gW11cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzOiBSZXNvbHZlZENvbHVtbkZpbHRlcjxURGF0YT5bXSA9IFtdXG5cbiAgICAgICAgOyhjb2x1bW5GaWx0ZXJzID8/IFtdKS5mb3JFYWNoKGQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihkLmlkKVxuXG4gICAgICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKClcblxuICAgICAgICAgIGlmICghZmlsdGVyRm4pIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlZENvbHVtbkZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgICAgIGZpbHRlckZuLFxuICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZTogZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlPy4oZC52YWx1ZSkgPz8gZC52YWx1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSAoY29sdW1uRmlsdGVycyA/PyBbXSkubWFwKGQgPT4gZC5pZClcblxuICAgICAgICBjb25zdCBnbG9iYWxGaWx0ZXJGbiA9IHRhYmxlLmdldEdsb2JhbEZpbHRlckZuKClcblxuICAgICAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGVcbiAgICAgICAgICAuZ2V0QWxsTGVhZkNvbHVtbnMoKVxuICAgICAgICAgIC5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSlcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgZ2xvYmFsRmlsdGVyICYmXG4gICAgICAgICAgZ2xvYmFsRmlsdGVyRm4gJiZcbiAgICAgICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgICBmaWx0ZXJhYmxlSWRzLnB1c2goJ19fZ2xvYmFsX18nKVxuXG4gICAgICAgICAgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICByZXNvbHZlZEdsb2JhbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICAgIGZpbHRlckZuOiBnbG9iYWxGaWx0ZXJGbixcbiAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZTpcbiAgICAgICAgICAgICAgICBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWU/LihnbG9iYWxGaWx0ZXIpID8/XG4gICAgICAgICAgICAgICAgZ2xvYmFsRmlsdGVyLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRDb2x1bW5GaWx0ZXJcbiAgICAgICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXJcblxuICAgICAgICAvLyBGbGFnIHRoZSBwcmVmaWx0ZXJlZCByb3cgbW9kZWwgd2l0aCBlYWNoIGZpbHRlciBzdGF0ZVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgcm93ID0gcm93TW9kZWwuZmxhdFJvd3Nbal0hXG5cbiAgICAgICAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY3VycmVudENvbHVtbkZpbHRlciA9IHJlc29sdmVkQ29sdW1uRmlsdGVyc1tpXSFcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50Q29sdW1uRmlsdGVyLmlkXG5cbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxuICAgICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc1tpZF0gPSBjdXJyZW50Q29sdW1uRmlsdGVyLmZpbHRlckZuKFxuICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsXG4gICAgICAgICAgICAgICAgZmlsdGVyTWV0YSA9PiB7XG4gICAgICAgICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjdXJyZW50R2xvYmFsRmlsdGVyID0gcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzW2ldIVxuICAgICAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRHbG9iYWxGaWx0ZXIuaWRcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIuZmlsdGVyRm4oXG4gICAgICAgICAgICAgICAgICByb3csXG4gICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIucmVzb2x2ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IHRydWVcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gKHJvdzogUm93PFREYXRhPikgPT4ge1xuICAgICAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXSFdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciBmaW5hbCByb3dzIHVzaW5nIGFsbCBvZiB0aGUgYWN0aXZlIGZpbHRlcnNcbiAgICAgICAgcmV0dXJuIGZpbHRlclJvd3Mocm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkUm93TW9kZWwnLCAoKSA9PlxuICAgICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KClcbiAgICAgIClcbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVSb3cgfSBmcm9tICcuLi9jb3JlL3JvdydcbmltcG9ydCB7IFJvdywgUm93RGF0YSwgUm93TW9kZWwsIFRhYmxlIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBmbGF0dGVuQnksIGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi4vZmVhdHVyZXMvQ29sdW1uR3JvdXBpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cGVkUm93TW9kZWw8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPigpOiAoXG4gIHRhYmxlOiBUYWJsZTxURGF0YT5cbikgPT4gKCkgPT4gUm93TW9kZWw8VERhdGE+IHtcbiAgcmV0dXJuIHRhYmxlID0+XG4gICAgbWVtbyhcbiAgICAgICgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sXG4gICAgICAoZ3JvdXBpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgICAgIHJvd01vZGVsLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgcm93LmRlcHRoID0gMFxuICAgICAgICAgICAgcm93LnBhcmVudElkID0gdW5kZWZpbmVkXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gcm93TW9kZWxcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbHRlciB0aGUgZ3JvdXBpbmcgbGlzdCBkb3duIHRvIGNvbHVtbnMgdGhhdCBleGlzdFxuICAgICAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+XG4gICAgICAgICAgdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzOiBSb3c8VERhdGE+W10gPSBbXVxuICAgICAgICBjb25zdCBncm91cGVkUm93c0J5SWQ6IFJlY29yZDxzdHJpbmcsIFJvdzxURGF0YT4+ID0ge31cbiAgICAgICAgLy8gY29uc3Qgb25seUdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAgICAgLy8gY29uc3Qgb25seUdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG4gICAgICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAgICAgLy8gY29uc3Qgbm9uR3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcblxuICAgICAgICAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuICAgICAgICBjb25zdCBncm91cFVwUmVjdXJzaXZlbHkgPSAoXG4gICAgICAgICAgcm93czogUm93PFREYXRhPltdLFxuICAgICAgICAgIGRlcHRoID0gMCxcbiAgICAgICAgICBwYXJlbnRJZD86IHN0cmluZ1xuICAgICAgICApID0+IHtcbiAgICAgICAgICAvLyBHcm91cGluZyBkZXB0aCBoYXMgYmVlbiBiZWVuIG1ldFxuICAgICAgICAgIC8vIFN0b3AgZ3JvdXBpbmcgYW5kIHNpbXBseSByZXdyaXRlIHRoZCBkZXB0aCBhbmQgcm93IHJlbGF0aW9uc2hpcHNcbiAgICAgICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgICByb3cuZGVwdGggPSBkZXB0aFxuXG4gICAgICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHJvdylcbiAgICAgICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3dcblxuICAgICAgICAgICAgICBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgICAgICByb3cuc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3cuc3ViUm93cywgZGVwdGggKyAxLCByb3cuaWQpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcm93XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNvbHVtbklkOiBzdHJpbmcgPSBleGlzdGluZ0dyb3VwaW5nW2RlcHRoXSFcblxuICAgICAgICAgIC8vIEdyb3VwIHRoZSByb3dzIHRvZ2V0aGVyIGZvciB0aGlzIGxldmVsXG4gICAgICAgICAgY29uc3Qgcm93R3JvdXBzTWFwID0gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZClcblxuICAgICAgICAgIC8vIFBlcmZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG4gICAgICAgICAgY29uc3QgYWdncmVnYXRlZEdyb3VwZWRSb3dzID0gQXJyYXkuZnJvbShyb3dHcm91cHNNYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgICAgICAoW2dyb3VwaW5nVmFsdWUsIGdyb3VwZWRSb3dzXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgbGV0IGlkID0gYCR7Y29sdW1uSWR9OiR7Z3JvdXBpbmdWYWx1ZX1gXG4gICAgICAgICAgICAgIGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH0+JHtpZH1gIDogaWRcblxuICAgICAgICAgICAgICAvLyBGaXJzdCwgUmVjdXJzZSB0byBncm91cCBzdWIgcm93cyBiZWZvcmUgYWdncmVnYXRpb25cbiAgICAgICAgICAgICAgY29uc3Qgc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShncm91cGVkUm93cywgZGVwdGggKyAxLCBpZClcblxuICAgICAgICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICAgICAgICBzdWJSb3cucGFyZW50SWQgPSBpZFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG4gICAgICAgICAgICAgIGNvbnN0IGxlYWZSb3dzID0gZGVwdGhcbiAgICAgICAgICAgICAgICA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgcm93ID0+IHJvdy5zdWJSb3dzKVxuICAgICAgICAgICAgICAgIDogZ3JvdXBlZFJvd3NcblxuICAgICAgICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3coXG4gICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbGVhZlJvd3NbMF0hLm9yaWdpbmFsLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcbiAgICAgICAgICAgICAgICBncm91cGluZ0NvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgICAgICAgICBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgIHN1YlJvd3MsXG4gICAgICAgICAgICAgICAgbGVhZlJvd3MsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6IChjb2x1bW5JZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZ2dyZWdhdGUgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGUgZ3JvdXBpbmdcbiAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwaW5nLmluY2x1ZGVzKGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cGVkUm93c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRSb3dzWzBdLmdldFZhbHVlKGNvbHVtbklkKSA/PyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBBZ2dyZWdhdGUgdGhlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKVxuICAgICAgICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4/LmdldEFnZ3JlZ2F0aW9uRm4oKVxuXG4gICAgICAgICAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGFnZ3JlZ2F0ZUZuKFxuICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbklkLFxuICAgICAgICAgICAgICAgICAgICAgIGxlYWZSb3dzLFxuICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRSb3dzXG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KVxuICAgICAgICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93XG4gICAgICAgICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICByZXR1cm4gcm93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93c1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3JvdXBlZFJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93TW9kZWwucm93cywgMClcblxuICAgICAgICBncm91cGVkUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KVxuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93XG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgICAgIGZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZCxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRSb3dNb2RlbCcsICgpID0+IHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQoKVxuICAgICAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICApXG59XG5cbmZ1bmN0aW9uIGdyb3VwQnk8VERhdGEgZXh0ZW5kcyBSb3dEYXRhPihyb3dzOiBSb3c8VERhdGE+W10sIGNvbHVtbklkOiBzdHJpbmcpIHtcbiAgY29uc3QgZ3JvdXBNYXAgPSBuZXcgTWFwPGFueSwgUm93PFREYXRhPltdPigpXG5cbiAgcmV0dXJuIHJvd3MucmVkdWNlKChtYXAsIHJvdykgPT4ge1xuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gXG4gICAgY29uc3QgcHJldmlvdXMgPSBtYXAuZ2V0KHJlc0tleSlcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICBtYXAuc2V0KHJlc0tleSwgW3Jvd10pXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzLnB1c2gocm93KVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH0sIGdyb3VwTWFwKVxufVxuIiwiaW1wb3J0IHsgVGFibGUsIFJvd01vZGVsLCBSb3csIFJvd0RhdGEgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGdldE1lbW9PcHRpb25zLCBtZW1vIH0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBleHBhbmRSb3dzIH0gZnJvbSAnLi9nZXRFeHBhbmRlZFJvd01vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFnaW5hdGlvblJvd01vZGVsPFREYXRhIGV4dGVuZHMgUm93RGF0YT4ob3B0cz86IHtcbiAgaW5pdGlhbFN5bmM6IGJvb2xlYW5cbn0pOiAodGFibGU6IFRhYmxlPFREYXRhPikgPT4gKCkgPT4gUm93TW9kZWw8VERhdGE+IHtcbiAgcmV0dXJuIHRhYmxlID0+XG4gICAgbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLFxuICAgICAgICB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSxcbiAgICAgICAgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93c1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkLFxuICAgICAgXSxcbiAgICAgIChwYWdpbmF0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJvd01vZGVsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHBhZ2VTaXplLCBwYWdlSW5kZXggfSA9IHBhZ2luYXRpb25cbiAgICAgICAgbGV0IHsgcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkIH0gPSByb3dNb2RlbFxuICAgICAgICBjb25zdCBwYWdlU3RhcnQgPSBwYWdlU2l6ZSAqIHBhZ2VJbmRleFxuICAgICAgICBjb25zdCBwYWdlRW5kID0gcGFnZVN0YXJ0ICsgcGFnZVNpemVcblxuICAgICAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpXG5cbiAgICAgICAgbGV0IHBhZ2luYXRlZFJvd01vZGVsOiBSb3dNb2RlbDxURGF0YT5cblxuICAgICAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IGV4cGFuZFJvd3Moe1xuICAgICAgICAgICAgcm93cyxcbiAgICAgICAgICAgIGZsYXRSb3dzLFxuICAgICAgICAgICAgcm93c0J5SWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWdpbmF0ZWRSb3dNb2RlbCA9IHtcbiAgICAgICAgICAgIHJvd3MsXG4gICAgICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgICAgIHJvd3NCeUlkLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW11cblxuICAgICAgICBjb25zdCBoYW5kbGVSb3cgPSAocm93OiBSb3c8VERhdGE+KSA9PiB7XG4gICAgICAgICAgcGFnaW5hdGVkUm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpXG4gICAgICAgICAgaWYgKHJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdylcblxuICAgICAgICByZXR1cm4gcGFnaW5hdGVkUm93TW9kZWxcbiAgICAgIH0sXG4gICAgICBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnKVxuICAgIClcbn1cbiIsImltcG9ydCB7IFRhYmxlLCBSb3csIFJvd01vZGVsLCBSb3dEYXRhIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBTb3J0aW5nRm4gfSBmcm9tICcuLi9mZWF0dXJlcy9Sb3dTb3J0aW5nJ1xuaW1wb3J0IHsgZ2V0TWVtb09wdGlvbnMsIG1lbW8gfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsPFREYXRhIGV4dGVuZHMgUm93RGF0YT4oKTogKFxuICB0YWJsZTogVGFibGU8VERhdGE+XG4pID0+ICgpID0+IFJvd01vZGVsPFREYXRhPiB7XG4gIHJldHVybiB0YWJsZSA9PlxuICAgIG1lbW8oXG4gICAgICAoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSxcbiAgICAgIChzb3J0aW5nLCByb3dNb2RlbCkgPT4ge1xuICAgICAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICFzb3J0aW5nPy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcm93TW9kZWxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvcnRpbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuc29ydGluZ1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzOiBSb3c8VERhdGE+W10gPSBbXVxuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgc29ydGluZ3MgdGhhdCBjb3JyZXNwb25kIHRvIG5vbiBleGlzdGluZyBjb2x1bW5zXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT5cbiAgICAgICAgICB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCk/LmdldENhblNvcnQoKVxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgY29sdW1uSW5mb0J5SWQ6IFJlY29yZDxcbiAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc29ydFVuZGVmaW5lZD86IGZhbHNlIHwgLTEgfCAxIHwgJ2ZpcnN0JyB8ICdsYXN0J1xuICAgICAgICAgICAgaW52ZXJ0U29ydGluZz86IGJvb2xlYW5cbiAgICAgICAgICAgIHNvcnRpbmdGbjogU29ydGluZ0ZuPFREYXRhPlxuICAgICAgICAgIH1cbiAgICAgICAgPiA9IHt9XG5cbiAgICAgICAgYXZhaWxhYmxlU29ydGluZy5mb3JFYWNoKHNvcnRFbnRyeSA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZClcbiAgICAgICAgICBpZiAoIWNvbHVtbikgcmV0dXJuXG5cbiAgICAgICAgICBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdID0ge1xuICAgICAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICAgICAgaW52ZXJ0U29ydGluZzogY29sdW1uLmNvbHVtbkRlZi5pbnZlcnRTb3J0aW5nLFxuICAgICAgICAgICAgc29ydGluZ0ZuOiBjb2x1bW4uZ2V0U29ydGluZ0ZuKCksXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHNvcnREYXRhID0gKHJvd3M6IFJvdzxURGF0YT5bXSkgPT4ge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgICAgIGNvbnN0IHNvcnRlZERhdGEgPSByb3dzLm1hcChyb3cgPT4gKHsgLi4ucm93IH0pKVxuXG4gICAgICAgICAgc29ydGVkRGF0YS5zb3J0KChyb3dBLCByb3dCKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc29ydEVudHJ5ID0gYXZhaWxhYmxlU29ydGluZ1tpXSFcbiAgICAgICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF0hXG4gICAgICAgICAgICAgIGNvbnN0IHNvcnRVbmRlZmluZWQgPSBjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWRcbiAgICAgICAgICAgICAgY29uc3QgaXNEZXNjID0gc29ydEVudHJ5Py5kZXNjID8/IGZhbHNlXG5cbiAgICAgICAgICAgICAgbGV0IHNvcnRJbnQgPSAwXG5cbiAgICAgICAgICAgICAgLy8gQWxsIHNvcnRpbmcgaW50cyBzaG91bGQgYWx3YXlzIHJldHVybiBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICAgICAgaWYgKHNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhVmFsdWUgPSByb3dBLmdldFZhbHVlKHNvcnRFbnRyeS5pZClcbiAgICAgICAgICAgICAgICBjb25zdCBiVmFsdWUgPSByb3dCLmdldFZhbHVlKHNvcnRFbnRyeS5pZClcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgaWYgKGFVbmRlZmluZWQgfHwgYlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNvcnRVbmRlZmluZWQgPT09ICdmaXJzdCcpIHJldHVybiBhVW5kZWZpbmVkID8gLTEgOiAxXG4gICAgICAgICAgICAgICAgICBpZiAoc29ydFVuZGVmaW5lZCA9PT0gJ2xhc3QnKSByZXR1cm4gYVVuZGVmaW5lZCA/IDEgOiAtMVxuICAgICAgICAgICAgICAgICAgc29ydEludCA9XG4gICAgICAgICAgICAgICAgICAgIGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgICAgICAgIDogYVVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzb3J0VW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA6IC1zb3J0VW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzb3J0SW50ID0gY29sdW1uSW5mby5zb3J0aW5nRm4ocm93QSwgcm93Qiwgc29ydEVudHJ5LmlkKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSWYgc29ydGluZyBpcyBub24temVybywgdGFrZSBjYXJlIG9mIGRlc2MgYW5kIGludmVyc2lvblxuICAgICAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTFcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uSW5mby5pbnZlcnRTb3J0aW5nKSB7XG4gICAgICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcm93QS5pbmRleCAtIHJvd0IuaW5kZXhcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHN1Yi1yb3dzLCBzb3J0IHRoZW1cbiAgICAgICAgICBzb3J0ZWREYXRhLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KVxuICAgICAgICAgICAgaWYgKHJvdy5zdWJSb3dzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmV0dXJuIHNvcnRlZERhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxuICAgICAgICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZCxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFNvcnRlZFJvd01vZGVsJywgKCkgPT5cbiAgICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpXG4gICAgICApXG4gICAgKVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbHVtbkhlbHBlciIsImFjY2Vzc29yIiwiY29sdW1uIiwiYWNjZXNzb3JGbiIsImFjY2Vzc29yS2V5IiwiZGlzcGxheSIsImdyb3VwIiwiZnVuY3Rpb25hbFVwZGF0ZSIsInVwZGF0ZXIiLCJpbnB1dCIsIm5vb3AiLCJtYWtlU3RhdGVVcGRhdGVyIiwia2V5IiwiaW5zdGFuY2UiLCJzZXRTdGF0ZSIsIm9sZCIsImlzRnVuY3Rpb24iLCJkIiwiRnVuY3Rpb24iLCJpc051bWJlckFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJmbGF0dGVuQnkiLCJhcnIiLCJnZXRDaGlsZHJlbiIsImZsYXQiLCJyZWN1cnNlIiwic3ViQXJyIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJyZXN1bHQiLCJkZXBBcmdzIiwiZGVwVGltZSIsImRlYnVnIiwiRGF0ZSIsIm5vdyIsIm5ld0RlcHMiLCJkZXBzQ2hhbmdlZCIsInNvbWUiLCJkZXAiLCJpbmRleCIsInJlc3VsdFRpbWUiLCJvbkNoYW5nZSIsImRlcEVuZFRpbWUiLCJNYXRoIiwicm91bmQiLCJyZXN1bHRFbmRUaW1lIiwicmVzdWx0RnBzUGVyY2VudGFnZSIsInBhZCIsInN0ciIsIm51bSIsIlN0cmluZyIsImNvbnNvbGUiLCJpbmZvIiwibWF4IiwibWluIiwiZ2V0TWVtb09wdGlvbnMiLCJ0YWJsZU9wdGlvbnMiLCJkZWJ1Z0xldmVsIiwiX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsIiwiZGVidWdBbGwiLCJwcm9jZXNzIiwiY3JlYXRlQ2VsbCIsInRhYmxlIiwicm93IiwiY29sdW1uSWQiLCJnZXRSZW5kZXJWYWx1ZSIsIl9jZWxsJGdldFZhbHVlIiwiY2VsbCIsImdldFZhbHVlIiwib3B0aW9ucyIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJpZCIsInJlbmRlclZhbHVlIiwiZ2V0Q29udGV4dCIsIl9mZWF0dXJlcyIsImZlYXR1cmUiLCJjcmVhdGVDb2x1bW4iLCJjb2x1bW5EZWYiLCJkZXB0aCIsInBhcmVudCIsIl9yZWYiLCJfcmVzb2x2ZWRDb2x1bW5EZWYkaWQiLCJkZWZhdWx0Q29sdW1uIiwiX2dldERlZmF1bHRDb2x1bW5EZWYiLCJyZXNvbHZlZENvbHVtbkRlZiIsInByb3RvdHlwZSIsInJlcGxhY2VBbGwiLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaGVhZGVyIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFJvdyIsInNwbGl0IiwiX3Jlc3VsdCIsIndhcm4iLCJFcnJvciIsImNvbHVtbnMiLCJnZXRGbGF0Q29sdW1ucyIsIl9jb2x1bW4kY29sdW1ucyIsImZsYXRNYXAiLCJnZXRMZWFmQ29sdW1ucyIsIl9nZXRPcmRlckNvbHVtbnNGbiIsIm9yZGVyQ29sdW1ucyIsIl9jb2x1bW4kY29sdW1uczIiLCJsZWFmQ29sdW1ucyIsImNyZWF0ZUhlYWRlciIsIl9vcHRpb25zJGlkIiwiaXNQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVySWQiLCJzdWJIZWFkZXJzIiwiY29sU3BhbiIsInJvd1NwYW4iLCJoZWFkZXJHcm91cCIsImdldExlYWZIZWFkZXJzIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiaCIsIm1hcCIsIkhlYWRlcnMiLCJjcmVhdGVUYWJsZSIsImdldEhlYWRlckdyb3VwcyIsImdldEFsbENvbHVtbnMiLCJnZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRTdGF0ZSIsImNvbHVtblBpbm5pbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxDb2x1bW5zIiwiX2xlZnQkbWFwJGZpbHRlciIsIl9yaWdodCRtYXAkZmlsdGVyIiwibGVmdENvbHVtbnMiLCJmaW5kIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJpZ2h0Q29sdW1ucyIsImNlbnRlckNvbHVtbnMiLCJoZWFkZXJHcm91cHMiLCJidWlsZEhlYWRlckdyb3VwcyIsImdldENlbnRlckhlYWRlckdyb3VwcyIsImdldExlZnRIZWFkZXJHcm91cHMiLCJfbGVmdCRtYXAkZmlsdGVyMiIsIm9yZGVyZWRMZWFmQ29sdW1ucyIsImdldFJpZ2h0SGVhZGVyR3JvdXBzIiwiX3JpZ2h0JG1hcCRmaWx0ZXIyIiwiZ2V0Rm9vdGVyR3JvdXBzIiwicmV2ZXJzZSIsImdldExlZnRGb290ZXJHcm91cHMiLCJnZXRDZW50ZXJGb290ZXJHcm91cHMiLCJnZXRSaWdodEZvb3Rlckdyb3VwcyIsImdldEZsYXRIZWFkZXJzIiwiaGVhZGVycyIsImdldExlZnRGbGF0SGVhZGVycyIsImdldENlbnRlckZsYXRIZWFkZXJzIiwiZ2V0UmlnaHRGbGF0SGVhZGVycyIsImdldENlbnRlckxlYWZIZWFkZXJzIiwiZmxhdEhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMiLCJnZXRMZWZ0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMyIiwiZ2V0UmlnaHRMZWFmSGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVyczMiLCJjZW50ZXIiLCJfbGVmdCQwJGhlYWRlcnMiLCJfbGVmdCQiLCJfY2VudGVyJDAkaGVhZGVycyIsIl9jZW50ZXIkIiwiX3JpZ2h0JDAkaGVhZGVycyIsIl9yaWdodCQiLCJjb2x1bW5zVG9Hcm91cCIsImhlYWRlckZhbWlseSIsIl9oZWFkZXJHcm91cHMkMCRoZWFkZSIsIl9oZWFkZXJHcm91cHMkIiwibWF4RGVwdGgiLCJmaW5kTWF4RGVwdGgiLCJnZXRJc1Zpc2libGUiLCJjcmVhdGVIZWFkZXJHcm91cCIsImhlYWRlcnNUb0dyb3VwIiwiam9pbiIsInBlbmRpbmdQYXJlbnRIZWFkZXJzIiwiaGVhZGVyVG9Hcm91cCIsImxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIiLCJpc0xlYWZIZWFkZXIiLCJib3R0b21IZWFkZXJzIiwicmVjdXJzZUhlYWRlcnNGb3JTcGFucyIsImZpbHRlcmVkSGVhZGVycyIsImNoaWxkUm93U3BhbnMiLCJjaGlsZENvbFNwYW4iLCJjaGlsZFJvd1NwYW4iLCJtaW5DaGlsZFJvd1NwYW4iLCJjcmVhdGVSb3ciLCJvcmlnaW5hbCIsInJvd0luZGV4Iiwic3ViUm93cyIsInBhcmVudElkIiwiX3ZhbHVlc0NhY2hlIiwiX3VuaXF1ZVZhbHVlc0NhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJnZXRDb2x1bW4iLCJnZXRVbmlxdWVWYWx1ZXMiLCJfcm93JGdldFZhbHVlIiwiZ2V0TGVhZlJvd3MiLCJnZXRQYXJlbnRSb3ciLCJnZXRSb3ciLCJnZXRQYXJlbnRSb3dzIiwicGFyZW50Um93cyIsImN1cnJlbnRSb3ciLCJwYXJlbnRSb3ciLCJnZXRBbGxDZWxscyIsImdldEFsbExlYWZDb2x1bW5zIiwiX2dldEFsbENlbGxzQnlDb2x1bW5JZCIsImFsbENlbGxzIiwicmVkdWNlIiwiYWNjIiwiaSIsIkNvbHVtbkZhY2V0aW5nIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJpbmNsdWRlc1N0cmluZyIsImZpbHRlclZhbHVlIiwiX2ZpbHRlclZhbHVlJHRvU3RyaW5nIiwic2VhcmNoIiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImF1dG9SZW1vdmUiLCJ0ZXN0RmFsc2V5IiwiaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUiLCJfcm93JGdldFZhbHVlMiIsImVxdWFsc1N0cmluZyIsIl9yb3ckZ2V0VmFsdWUzIiwiYXJySW5jbHVkZXMiLCJfcm93JGdldFZhbHVlNCIsImFyckluY2x1ZGVzQWxsIiwiX3JvdyRnZXRWYWx1ZTUiLCJhcnJJbmNsdWRlc1NvbWUiLCJfcm93JGdldFZhbHVlNiIsImVxdWFscyIsIndlYWtFcXVhbHMiLCJpbk51bWJlclJhbmdlIiwicm93VmFsdWUiLCJyZXNvbHZlRmlsdGVyVmFsdWUiLCJ1bnNhZmVNaW4iLCJ1bnNhZmVNYXgiLCJwYXJzZWRNaW4iLCJwYXJzZUZsb2F0IiwicGFyc2VkTWF4IiwiTnVtYmVyIiwiaXNOYU4iLCJJbmZpbml0eSIsInRlbXAiLCJmaWx0ZXJGbnMiLCJDb2x1bW5GaWx0ZXJpbmciLCJnZXREZWZhdWx0Q29sdW1uRGVmIiwiZmlsdGVyRm4iLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbHVtbkZpbHRlcnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsImZpbHRlckZyb21MZWFmUm93cyIsIm1heExlYWZSb3dGaWx0ZXJEZXB0aCIsImdldEF1dG9GaWx0ZXJGbiIsImZpcnN0Um93IiwiZ2V0Q29yZVJvd01vZGVsIiwiZmxhdFJvd3MiLCJ2YWx1ZSIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJmaW5kSW5kZXgiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c0ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX3RhYmxlIiwiY29sdW1uRmlsdGVyc01ldGEiLCJ1cGRhdGVGbiIsIl9mdW5jdGlvbmFsVXBkYXRlIiwicmVzZXRDb2x1bW5GaWx0ZXJzIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsInN1bSIsIl9sZWFmUm93cyIsImNoaWxkUm93cyIsIm5leHQiLCJuZXh0VmFsdWUiLCJleHRlbnQiLCJtZWFuIiwibGVhZlJvd3MiLCJjb3VudCIsIm1lZGlhbiIsInZhbHVlcyIsIm1pZCIsImZsb29yIiwibnVtcyIsInNvcnQiLCJhIiwiYiIsInVuaXF1ZSIsImZyb20iLCJTZXQiLCJ1bmlxdWVDb3VudCIsInNpemUiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkNvbHVtbkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0R3JvdXBpbmdWYWx1ZSIsImdldElzR3JvdXBlZCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cCIsImdldEdyb3VwZWRJbmRleCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cDIiLCJpbmRleE9mIiwiZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyIiwiY2FuR3JvdXAiLCJnZXRBdXRvQWdncmVnYXRpb25GbiIsIk9iamVjdCIsImNhbGwiLCJnZXRBZ2dyZWdhdGlvbkZuIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnMiIsInJlc2V0R3JvdXBpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJGciLCJnZXRQcmVHcm91cGVkUm93TW9kZWwiLCJnZXRHcm91cGVkUm93TW9kZWwiLCJfZ2V0R3JvdXBlZFJvd01vZGVsIiwibWFudWFsR3JvdXBpbmciLCJncm91cGluZ0NvbHVtbklkIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwiX3JvdyRzdWJSb3dzIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIkNvbHVtbk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwiZ2V0SW5kZXgiLCJwb3NpdGlvbiIsIl9nZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRJc0ZpcnN0Q29sdW1uIiwiX2NvbHVtbnMkIiwiZ2V0SXNMYXN0Q29sdW1uIiwiX2NvbHVtbnMiLCJzZXRDb2x1bW5PcmRlciIsInJlc2V0Q29sdW1uT3JkZXIiLCJvcmRlcmVkQ29sdW1ucyIsImNvbHVtbk9yZGVyQ29weSIsImNvbHVtbnNDb3B5IiwidGFyZ2V0Q29sdW1uSWQiLCJzaGlmdCIsImZvdW5kSW5kZXgiLCJzcGxpY2UiLCJnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlIiwiQ29sdW1uUGlubmluZyIsIm9uQ29sdW1uUGlubmluZ0NoYW5nZSIsInBpbiIsImNvbHVtbklkcyIsInNldENvbHVtblBpbm5pbmciLCJfb2xkJGxlZnQzIiwiX29sZCRyaWdodDMiLCJfb2xkJGxlZnQiLCJfb2xkJHJpZ2h0IiwiX29sZCRsZWZ0MiIsIl9vbGQkcmlnaHQyIiwiZ2V0Q2FuUGluIiwiX2QkY29sdW1uRGVmJGVuYWJsZVBpIiwiZW5hYmxlUGlubmluZyIsImVuYWJsZUNvbHVtblBpbm5pbmciLCJnZXRJc1Bpbm5lZCIsImxlYWZDb2x1bW5JZHMiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiZ2V0UGlubmVkSW5kZXgiLCJnZXRDZW50ZXJWaXNpYmxlQ2VsbHMiLCJfZ2V0QWxsVmlzaWJsZUNlbGxzIiwibGVmdEFuZFJpZ2h0IiwiZ2V0TGVmdFZpc2libGVDZWxscyIsImNlbGxzIiwiZ2V0UmlnaHRWaXNpYmxlQ2VsbHMiLCJyZXNldENvbHVtblBpbm5pbmciLCJnZXRJc1NvbWVDb2x1bW5zUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvIiwicGlubmluZ1N0YXRlIiwiX3Bpbm5pbmdTdGF0ZSRsZWZ0IiwiX3Bpbm5pbmdTdGF0ZSRyaWdodCIsImdldExlZnRMZWFmQ29sdW1ucyIsImdldFJpZ2h0TGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJMZWFmQ29sdW1ucyIsInNhZmVseUFjY2Vzc0RvY3VtZW50IiwiX2RvY3VtZW50IiwiZG9jdW1lbnQiLCJkZWZhdWx0Q29sdW1uU2l6aW5nIiwibWluU2l6ZSIsIm1heFNpemUiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSIsInN0YXJ0T2Zmc2V0Iiwic3RhcnRTaXplIiwiZGVsdGFPZmZzZXQiLCJkZWx0YVBlcmNlbnRhZ2UiLCJpc1Jlc2l6aW5nQ29sdW1uIiwiY29sdW1uU2l6aW5nU3RhcnQiLCJDb2x1bW5TaXppbmciLCJjb2x1bW5TaXppbmciLCJjb2x1bW5TaXppbmdJbmZvIiwiY29sdW1uUmVzaXplTW9kZSIsImNvbHVtblJlc2l6ZURpcmVjdGlvbiIsIm9uQ29sdW1uU2l6aW5nQ2hhbmdlIiwib25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlIiwiZ2V0U2l6ZSIsIl9jb2x1bW4kY29sdW1uRGVmJG1pbiIsIl9jb2x1bW4kY29sdW1uRGVmJG1heCIsImNvbHVtblNpemUiLCJnZXRTdGFydCIsInNsaWNlIiwiZ2V0QWZ0ZXIiLCJyZXNldFNpemUiLCJzZXRDb2x1bW5TaXppbmciLCJfcmVmMiIsIl8iLCJyZXN0IiwiZ2V0Q2FuUmVzaXplIiwiZW5hYmxlUmVzaXppbmciLCJlbmFibGVDb2x1bW5SZXNpemluZyIsImdldElzUmVzaXppbmciLCJfaGVhZGVyJGNvbHVtbiRnZXRTaXoiLCJwcmV2U2libGluZ0hlYWRlciIsImdldFJlc2l6ZUhhbmRsZXIiLCJfY29udGV4dERvY3VtZW50IiwiY2FuUmVzaXplIiwiZSIsInBlcnNpc3QiLCJpc1RvdWNoU3RhcnRFdmVudCIsInRvdWNoZXMiLCJjbGllbnRYIiwibmV3Q29sdW1uU2l6aW5nIiwidXBkYXRlT2Zmc2V0IiwiZXZlbnRUeXBlIiwiY2xpZW50WFBvcyIsInNldENvbHVtblNpemluZ0luZm8iLCJfb2xkJHN0YXJ0T2Zmc2V0IiwiX29sZCRzdGFydFNpemUiLCJkZWx0YURpcmVjdGlvbiIsIl9yZWYzIiwiaGVhZGVyU2l6ZSIsIm9uTW92ZSIsIm9uRW5kIiwiY29udGV4dERvY3VtZW50IiwibW91c2VFdmVudHMiLCJtb3ZlSGFuZGxlciIsInVwSGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0b3VjaEV2ZW50cyIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIl9lJHRvdWNoZXMkIiwicGFzc2l2ZUlmU3VwcG9ydGVkIiwicGFzc2l2ZUV2ZW50U3VwcG9ydGVkIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNldENvbHVtblNpemluZyIsInJlc2V0SGVhZGVyU2l6ZUluZm8iLCJfdGFibGUkaW5pdGlhbFN0YXRlJGMyIiwiZ2V0VG90YWxTaXplIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwIiwiX3RhYmxlJGdldEhlYWRlckdyb3VwMiIsImdldExlZnRUb3RhbFNpemUiLCJfdGFibGUkZ2V0TGVmdEhlYWRlckciLCJfdGFibGUkZ2V0TGVmdEhlYWRlckcyIiwiZ2V0Q2VudGVyVG90YWxTaXplIiwiX3RhYmxlJGdldENlbnRlckhlYWRlIiwiX3RhYmxlJGdldENlbnRlckhlYWRlMiIsImdldFJpZ2h0VG90YWxTaXplIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyIiwiX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiIsInBhc3NpdmVTdXBwb3J0ZWQiLCJzdXBwb3J0ZWQiLCJ3aW5kb3ciLCJlcnIiLCJ0eXBlIiwiQ29sdW1uVmlzaWJpbGl0eSIsImNvbHVtblZpc2liaWxpdHkiLCJvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UiLCJ0b2dnbGVWaXNpYmlsaXR5IiwiZ2V0Q2FuSGlkZSIsInNldENvbHVtblZpc2liaWxpdHkiLCJjaGlsZENvbHVtbnMiLCJjIiwiZW5hYmxlSGlkaW5nIiwiZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0VmlzaWJsZUNlbGxzIiwibWFrZVZpc2libGVDb2x1bW5zTWV0aG9kIiwiZ2V0Q29sdW1ucyIsImdldFZpc2libGVGbGF0Q29sdW1ucyIsImdldEFsbEZsYXRDb2x1bW5zIiwiZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyIsImdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zIiwicmVzZXRDb2x1bW5WaXNpYmlsaXR5IiwidG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUiLCJfdmFsdWUiLCJnZXRJc0FsbENvbHVtbnNWaXNpYmxlIiwib2JqIiwiZ2V0SXNTb21lQ29sdW1uc1Zpc2libGUiLCJnZXRUb2dnbGVBbGxDb2x1bW5zVmlzaWJpbGl0eUhhbmRsZXIiLCJfdGFyZ2V0IiwiR2xvYmFsRmFjZXRpbmciLCJfZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsIiwiX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzIiwiX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJnZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzIiwiR2xvYmFsRmlsdGVyaW5nIiwiZ2xvYmFsRmlsdGVyIiwib25HbG9iYWxGaWx0ZXJDaGFuZ2UiLCJnbG9iYWxGaWx0ZXJGbiIsImdldENvbHVtbkNhbkdsb2JhbEZpbHRlciIsIl90YWJsZSRnZXRDb3JlUm93TW9kZSIsImdldENhbkdsb2JhbEZpbHRlciIsIl90YWJsZSRvcHRpb25zJGdldENvbCIsImVuYWJsZUdsb2JhbEZpbHRlciIsImdldEdsb2JhbEF1dG9GaWx0ZXJGbiIsImdldEdsb2JhbEZpbHRlckZuIiwic2V0R2xvYmFsRmlsdGVyIiwicmVzZXRHbG9iYWxGaWx0ZXIiLCJSb3dFeHBhbmRpbmciLCJleHBhbmRlZCIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJwYWdpbmF0ZUV4cGFuZGVkUm93cyIsInJlZ2lzdGVyZWQiLCJxdWV1ZWQiLCJfYXV0b1Jlc2V0RXhwYW5kZWQiLCJfdGFibGUkb3B0aW9ucyRhdXRvUmUiLCJfcXVldWUiLCJhdXRvUmVzZXRBbGwiLCJhdXRvUmVzZXRFeHBhbmRlZCIsIm1hbnVhbEV4cGFuZGluZyIsInJlc2V0RXhwYW5kZWQiLCJzZXRFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsImdldElzQWxsUm93c0V4cGFuZGVkIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRlIiwiZ2V0Q2FuU29tZVJvd3NFeHBhbmQiLCJnZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwiLCJnZXRDYW5FeHBhbmQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyIiwiZ2V0SXNTb21lUm93c0V4cGFuZGVkIiwia2V5cyIsImdldFJvd01vZGVsIiwiZ2V0SXNFeHBhbmRlZCIsImdldEV4cGFuZGVkRGVwdGgiLCJyb3dJZHMiLCJyb3dzQnlJZCIsInNwbGl0SWQiLCJnZXRQcmVFeHBhbmRlZFJvd01vZGVsIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJnZXRFeHBhbmRlZFJvd01vZGVsIiwiX2dldEV4cGFuZGVkUm93TW9kZWwiLCJ0b2dnbGVFeHBhbmRlZCIsIl9leHBhbmRlZCIsImV4aXN0cyIsIm9sZEV4cGFuZGVkIiwicm93SWQiLCJfdGFibGUkb3B0aW9ucyRnZXRJc1IiLCJnZXRJc1Jvd0V4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Um93IiwiZ2V0Um93Q2FuRXhwYW5kIiwiZW5hYmxlRXhwYW5kaW5nIiwiZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQiLCJpc0Z1bGx5RXhwYW5kZWQiLCJnZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIiLCJjYW5FeHBhbmQiLCJkZWZhdWx0UGFnZUluZGV4IiwiZGVmYXVsdFBhZ2VTaXplIiwiZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSIsInBhZ2VJbmRleCIsInBhZ2VTaXplIiwiUm93UGFnaW5hdGlvbiIsInBhZ2luYXRpb24iLCJvblBhZ2luYXRpb25DaGFuZ2UiLCJfYXV0b1Jlc2V0UGFnZUluZGV4IiwiYXV0b1Jlc2V0UGFnZUluZGV4IiwibWFudWFsUGFnaW5hdGlvbiIsInJlc2V0UGFnZUluZGV4Iiwic2V0UGFnaW5hdGlvbiIsInNhZmVVcGRhdGVyIiwibmV3U3RhdGUiLCJyZXNldFBhZ2luYXRpb24iLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAiLCJzZXRQYWdlSW5kZXgiLCJtYXhQYWdlSW5kZXgiLCJwYWdlQ291bnQiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAyIiwicmVzZXRQYWdlU2l6ZSIsIl90YWJsZSRpbml0aWFsU3RhdGUkcDMiLCJfdGFibGUkaW5pdGlhbFN0YXRlMiIsInNldFBhZ2VTaXplIiwidG9wUm93SW5kZXgiLCJzZXRQYWdlQ291bnQiLCJfdGFibGUkb3B0aW9ucyRwYWdlQ28iLCJuZXdQYWdlQ291bnQiLCJnZXRQYWdlT3B0aW9ucyIsImdldFBhZ2VDb3VudCIsInBhZ2VPcHRpb25zIiwiZmlsbCIsImdldENhblByZXZpb3VzUGFnZSIsImdldENhbk5leHRQYWdlIiwicHJldmlvdXNQYWdlIiwibmV4dFBhZ2UiLCJmaXJzdFBhZ2UiLCJsYXN0UGFnZSIsImdldFBhZ2luYXRpb25Sb3dNb2RlbCIsIl9nZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfdGFibGUkb3B0aW9ucyRwYWdlQ28yIiwiY2VpbCIsImdldFJvd0NvdW50IiwiX3RhYmxlJG9wdGlvbnMkcm93Q291Iiwicm93Q291bnQiLCJyb3dzIiwiZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSIsInRvcCIsImJvdHRvbSIsIlJvd1Bpbm5pbmciLCJyb3dQaW5uaW5nIiwib25Sb3dQaW5uaW5nQ2hhbmdlIiwiaW5jbHVkZUxlYWZSb3dzIiwiaW5jbHVkZVBhcmVudFJvd3MiLCJsZWFmUm93SWRzIiwicGFyZW50Um93SWRzIiwic2V0Um93UGlubmluZyIsIl9vbGQkdG9wMyIsIl9vbGQkYm90dG9tMyIsIl9vbGQkdG9wIiwiX29sZCRib3R0b20iLCJoYXMiLCJfb2xkJHRvcDIiLCJfb2xkJGJvdHRvbTIiLCJlbmFibGVSb3dQaW5uaW5nIiwiaXNUb3AiLCJpc0JvdHRvbSIsIl9yZWY0IiwiX3Zpc2libGVQaW5uZWRSb3dJZHMkIiwidmlzaWJsZVBpbm5lZFJvd0lkcyIsImdldFRvcFJvd3MiLCJnZXRCb3R0b21Sb3dzIiwiX3JlZjUiLCJyZXNldFJvd1Bpbm5pbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHIiLCJnZXRJc1NvbWVSb3dzUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSR0b3AiLCJfcGlubmluZ1N0YXRlJGJvdHRvbSIsIl9nZXRQaW5uZWRSb3dzIiwidmlzaWJsZVJvd3MiLCJwaW5uZWRSb3dJZHMiLCJfdGFibGUkb3B0aW9ucyRrZWVwUGkiLCJrZWVwUGlubmVkUm93cyIsImFsbFJvd3MiLCJ0b3BQaW5uZWRSb3dJZHMiLCJib3R0b21QaW5uZWRSb3dJZHMiLCJnZXRDZW50ZXJSb3dzIiwidG9wQW5kQm90dG9tIiwiUm93U2VsZWN0aW9uIiwicm93U2VsZWN0aW9uIiwib25Sb3dTZWxlY3Rpb25DaGFuZ2UiLCJlbmFibGVSb3dTZWxlY3Rpb24iLCJlbmFibGVNdWx0aVJvd1NlbGVjdGlvbiIsImVuYWJsZVN1YlJvd1NlbGVjdGlvbiIsInNldFJvd1NlbGVjdGlvbiIsInJlc2V0Um93U2VsZWN0aW9uIiwidG9nZ2xlQWxsUm93c1NlbGVjdGVkIiwiZ2V0SXNBbGxSb3dzU2VsZWN0ZWQiLCJwcmVHcm91cGVkRmxhdFJvd3MiLCJnZXRDYW5TZWxlY3QiLCJ0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkIiwicmVzb2x2ZWRWYWx1ZSIsImdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCIsIm11dGF0ZVJvd0lzU2VsZWN0ZWQiLCJnZXRQcmVTZWxlY3RlZFJvd01vZGVsIiwiZ2V0U2VsZWN0ZWRSb3dNb2RlbCIsInJvd01vZGVsIiwic2VsZWN0Um93c0ZuIiwiZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsIiwiZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwiLCJpc0FsbFJvd3NTZWxlY3RlZCIsInBhZ2luYXRpb25GbGF0Um93cyIsImlzQWxsUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU29tZVJvd3NTZWxlY3RlZCIsIl90YWJsZSRnZXRTdGF0ZSRyb3dTZSIsInRvdGFsU2VsZWN0ZWQiLCJnZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkIiwiZ2V0SXNTZWxlY3RlZCIsImdldElzU29tZVNlbGVjdGVkIiwiZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkSGFuZGxlciIsImdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRIYW5kbGVyIiwidG9nZ2xlU2VsZWN0ZWQiLCJpc1NlbGVjdGVkIiwiX29wdHMkc2VsZWN0Q2hpbGRyZW4iLCJzZWxlY3RlZFJvd0lkcyIsInNlbGVjdENoaWxkcmVuIiwiaXNSb3dTZWxlY3RlZCIsImlzU3ViUm93U2VsZWN0ZWQiLCJnZXRJc0FsbFN1YlJvd3NTZWxlY3RlZCIsImdldENhblNlbGVjdFN1YlJvd3MiLCJnZXRDYW5NdWx0aVNlbGVjdCIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTMiLCJnZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIiLCJjYW5TZWxlY3QiLCJpbmNsdWRlQ2hpbGRyZW4iLCJuZXdTZWxlY3RlZEZsYXRSb3dzIiwibmV3U2VsZWN0ZWRSb3dzQnlJZCIsInJlY3Vyc2VSb3dzIiwiX3JvdyRzdWJSb3dzMiIsInNlbGVjdGlvbiIsIl9zZWxlY3Rpb24kcm93JGlkIiwiX3JvdyRzdWJSb3dzMyIsImFsbENoaWxkcmVuU2VsZWN0ZWQiLCJzb21lU2VsZWN0ZWQiLCJzdWJSb3ciLCJzdWJSb3dDaGlsZHJlblNlbGVjdGVkIiwicmVTcGxpdEFscGhhTnVtZXJpYyIsImFscGhhbnVtZXJpYyIsInJvd0EiLCJyb3dCIiwiY29tcGFyZUFscGhhbnVtZXJpYyIsImFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUiLCJ0ZXh0IiwiY29tcGFyZUJhc2ljIiwidGV4dENhc2VTZW5zaXRpdmUiLCJkYXRldGltZSIsImJhc2ljIiwiYVN0ciIsImJTdHIiLCJhYSIsImJiIiwiYW4iLCJwYXJzZUludCIsImJuIiwiY29tYm8iLCJzb3J0aW5nRm5zIiwiUm93U29ydGluZyIsInNvcnRpbmciLCJzb3J0aW5nRm4iLCJzb3J0VW5kZWZpbmVkIiwib25Tb3J0aW5nQ2hhbmdlIiwiaXNNdWx0aVNvcnRFdmVudCIsInNoaWZ0S2V5IiwiZ2V0QXV0b1NvcnRpbmdGbiIsImZpcnN0Um93cyIsImlzU3RyaW5nIiwiZ2V0QXV0b1NvcnREaXIiLCJnZXRTb3J0aW5nRm4iLCJfdGFibGUkb3B0aW9ucyRzb3J0aW4iLCJfdGFibGUkb3B0aW9ucyRzb3J0aW4yIiwidG9nZ2xlU29ydGluZyIsImRlc2MiLCJtdWx0aSIsIm5leHRTb3J0aW5nT3JkZXIiLCJnZXROZXh0U29ydGluZ09yZGVyIiwiaGFzTWFudWFsVmFsdWUiLCJzZXRTb3J0aW5nIiwiZXhpc3RpbmdTb3J0aW5nIiwiZXhpc3RpbmdJbmRleCIsIm5ld1NvcnRpbmciLCJzb3J0QWN0aW9uIiwibmV4dERlc2MiLCJnZXRDYW5NdWx0aVNvcnQiLCJfdGFibGUkb3B0aW9ucyRtYXhNdWwiLCJtYXhNdWx0aVNvcnRDb2xDb3VudCIsImdldEZpcnN0U29ydERpciIsIl9jb2x1bW4kY29sdW1uRGVmJHNvciIsInNvcnREZXNjRmlyc3QiLCJmaXJzdFNvcnREaXJlY3Rpb24iLCJpc1NvcnRlZCIsImdldElzU29ydGVkIiwiZW5hYmxlU29ydGluZ1JlbW92YWwiLCJlbmFibGVNdWx0aVJlbW92ZSIsImdldENhblNvcnQiLCJlbmFibGVTb3J0aW5nIiwiX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiIsImVuYWJsZU11bHRpU29ydCIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aSIsImNvbHVtblNvcnQiLCJnZXRTb3J0SW5kZXgiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkyIiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMyIsImNsZWFyU29ydGluZyIsImdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyIiwiY2FuU29ydCIsInJlc2V0U29ydGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkcyIsImdldFByZVNvcnRlZFJvd01vZGVsIiwiX2dldFNvcnRlZFJvd01vZGVsIiwibWFudWFsU29ydGluZyIsImJ1aWx0SW5GZWF0dXJlcyIsIl9vcHRpb25zJF9mZWF0dXJlcyIsIl9vcHRpb25zJGluaXRpYWxTdGF0ZSIsImRlYnVnVGFibGUiLCJkZWZhdWx0T3B0aW9ucyIsImFzc2lnbiIsIm1lcmdlT3B0aW9ucyIsImNvcmVJbml0aWFsU3RhdGUiLCJfZmVhdHVyZSRnZXRJbml0aWFsU3QiLCJxdWV1ZWRUaW1lb3V0IiwiY29yZUluc3RhbmNlIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsImVycm9yIiwic2V0VGltZW91dCIsInJlc2V0Iiwic2V0T3B0aW9ucyIsIm5ld09wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX2dldFJvd0lkIiwiZ2V0Um93SWQiLCJfZ2V0Q29yZVJvd01vZGVsIiwic2VhcmNoQWxsIiwiX2RlZmF1bHRDb2x1bW4iLCJfcHJvcHMkcmVuZGVyVmFsdWUkdG8iLCJfcHJvcHMkcmVuZGVyVmFsdWUiLCJfZ2V0Q29sdW1uRGVmcyIsImNvbHVtbkRlZnMiLCJyZWN1cnNlQ29sdW1ucyIsImdyb3VwaW5nQ29sdW1uRGVmIiwiX2dldEFsbEZsYXRDb2x1bW5zQnlJZCIsImZsYXRDb2x1bW5zIiwiZGF0YSIsImFjY2Vzc1Jvd3MiLCJvcmlnaW5hbFJvd3MiLCJnZXRTdWJSb3dzIiwiX3JvdyRvcmlnaW5hbFN1YlJvd3MiLCJvcmlnaW5hbFN1YlJvd3MiLCJleHBhbmRSb3dzIiwiZXhwYW5kZWRSb3dzIiwiaGFuZGxlUm93IiwiX3RhYmxlJGdldENvbHVtbiIsImZhY2V0ZWRSb3dNb2RlbCIsInVuaXF1ZVZhbHVlcyIsImZsYXRSb3ciLCJfZmxhdFJvdyRnZXRVbmlxdWVWYWwiLCJmYWNldGVkTWluVmFsdWUiLCJmYWNldGVkTWF4VmFsdWUiLCJmaWx0ZXJSb3dzIiwiZmlsdGVyUm93SW1wbCIsImZpbHRlclJvd01vZGVsRnJvbUxlYWZzIiwiZmlsdGVyUm93TW9kZWxGcm9tUm9vdCIsInJvd3NUb0ZpbHRlciIsImZpbHRlclJvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYSIsIm5ld0ZpbHRlcmVkRmxhdFJvd3MiLCJuZXdGaWx0ZXJlZFJvd3NCeUlkIiwicmVjdXJzZUZpbHRlclJvd3MiLCJuZXdSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEyIiwicGFzcyIsInByZVJvd01vZGVsIiwiZmlsdGVyYWJsZUlkcyIsImZpbHRlclJvd3NJbXBsIiwiZmFjZXRlZFVuaXF1ZVZhbHVlcyIsImoiLCJfZmFjZXRlZFVuaXF1ZVZhbHVlcyQiLCJzZXQiLCJnZXQiLCJyZXNvbHZlZENvbHVtbkZpbHRlcnMiLCJyZXNvbHZlZEdsb2JhbEZpbHRlcnMiLCJfZmlsdGVyRm4kcmVzb2x2ZUZpbHQiLCJnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zIiwiX2dsb2JhbEZpbHRlckZuJHJlc29sIiwiY3VycmVudENvbHVtbkZpbHRlciIsImN1cnJlbnRHbG9iYWxGaWx0ZXIiLCJmaWx0ZXJNZXRhIiwiX19nbG9iYWxfXyIsImV4aXN0aW5nR3JvdXBpbmciLCJncm91cGVkRmxhdFJvd3MiLCJncm91cGVkUm93c0J5SWQiLCJncm91cFVwUmVjdXJzaXZlbHkiLCJyb3dHcm91cHNNYXAiLCJncm91cEJ5IiwiYWdncmVnYXRlZEdyb3VwZWRSb3dzIiwiZW50cmllcyIsImdyb3VwaW5nVmFsdWUiLCJncm91cGVkUm93cyIsIl9ncm91cGVkUm93cyQwJGdldFZhbCIsImFnZ3JlZ2F0ZUZuIiwiZ3JvdXBNYXAiLCJyZXNLZXkiLCJwcmV2aW91cyIsInBhZ2VTdGFydCIsInBhZ2VFbmQiLCJwYWdpbmF0ZWRSb3dNb2RlbCIsInNvcnRpbmdTdGF0ZSIsInNvcnRlZEZsYXRSb3dzIiwiYXZhaWxhYmxlU29ydGluZyIsImNvbHVtbkluZm9CeUlkIiwic29ydEVudHJ5IiwiaW52ZXJ0U29ydGluZyIsInNvcnREYXRhIiwic29ydGVkRGF0YSIsIl9zb3J0RW50cnkkZGVzYyIsImNvbHVtbkluZm8iLCJpc0Rlc2MiLCJzb3J0SW50IiwiYVZhbHVlIiwiYlZhbHVlIiwiYVVuZGVmaW5lZCIsImJVbmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key:  true && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key:  true && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key:  true && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key:  true && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if ( true && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key:  true && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      let attempts = 0;\n      const maxAttempts = 10;\n      const tryScroll = (currentAlign) => {\n        if (!this.targetWindow) return;\n        const offsetInfo = this.getOffsetForIndex(index, currentAlign);\n        if (!offsetInfo) {\n          console.warn(\"Failed to get offset for index:\", index);\n          return;\n        }\n        const [offset, align] = offsetInfo;\n        this._scrollToOffset(offset, { adjustments: void 0, behavior });\n        this.targetWindow.requestAnimationFrame(() => {\n          const currentOffset = this.getScrollOffset();\n          const afterInfo = this.getOffsetForIndex(index, align);\n          if (!afterInfo) {\n            console.warn(\"Failed to get offset for index:\", index);\n            return;\n          }\n          if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(afterInfo[0], currentOffset)) {\n            scheduleRetry(align);\n          }\n        });\n      };\n      const scheduleRetry = (align) => {\n        if (!this.targetWindow) return;\n        attempts++;\n        if (attempts < maxAttempts) {\n          if ( true && this.options.debug) {\n            console.info(\"Schedule retry\", attempts, maxAttempts);\n          }\n          this.targetWindow.requestAnimationFrame(() => tryScroll(align));\n        } else {\n          console.warn(\n            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`\n          );\n        }\n      };\n      tryScroll(initialAlign);\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkU7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFNBQVMsc0RBQXNEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBOEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUF3RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbURBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbURBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0VBQXNFLG1CQUFtQjtBQUN6RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtDQUFJO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFJO0FBQy9CO0FBQ0EsU0FBUyx3REFBd0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFLO0FBQ0wsd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFnQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RyYWRldWwtc2Nhbm5lci1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL2luZGV4LmpzPzUxNjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UsIG1lbW8sIG5vdFVuZGVmaW5lZCwgYXBwcm94RXF1YWwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgZ2V0UmVjdCA9IChlbGVtZW50KSA9PiB7XG4gIGNvbnN0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gZWxlbWVudDtcbiAgcmV0dXJuIHsgd2lkdGg6IG9mZnNldFdpZHRoLCBoZWlnaHQ6IG9mZnNldEhlaWdodCB9O1xufTtcbmNvbnN0IGRlZmF1bHRLZXlFeHRyYWN0b3IgPSAoaW5kZXgpID0+IGluZGV4O1xuY29uc3QgZGVmYXVsdFJhbmdlRXh0cmFjdG9yID0gKHJhbmdlKSA9PiB7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocmFuZ2Uuc3RhcnRJbmRleCAtIHJhbmdlLm92ZXJzY2FuLCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocmFuZ2UuZW5kSW5kZXggKyByYW5nZS5vdmVyc2NhbiwgcmFuZ2UuY291bnQgLSAxKTtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGFyci5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRSZWN0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvdztcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IChyZWN0KSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgIGNiKHsgd2lkdGg6IE1hdGgucm91bmQod2lkdGgpLCBoZWlnaHQ6IE1hdGgucm91bmQoaGVpZ2h0KSB9KTtcbiAgfTtcbiAgaGFuZGxlcihnZXRSZWN0KGVsZW1lbnQpKTtcbiAgaWYgKCF0YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgICAgaWYgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBoYW5kbGVyKHsgd2lkdGg6IGJveC5pbmxpbmVTaXplLCBoZWlnaHQ6IGJveC5ibG9ja1NpemUgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYW5kbGVyKGdldFJlY3QoZWxlbWVudCkpO1xuICAgIH07XG4gICAgaW5zdGFuY2Uub3B0aW9ucy51c2VBbmltYXRpb25GcmFtZVdpdGhSZXNpemVPYnNlcnZlciA/IHJlcXVlc3RBbmltYXRpb25GcmFtZShydW4pIDogcnVuKCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gIH07XG59O1xuY29uc3QgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5jb25zdCBvYnNlcnZlV2luZG93UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgIGNiKHsgd2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCwgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0IH0pO1xuICB9O1xuICBoYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZXIpO1xuICB9O1xufTtcbmNvbnN0IHN1cHBvcnRzU2Nyb2xsZW5kID0gdHlwZW9mIHdpbmRvdyA9PSBcInVuZGVmaW5lZFwiID8gdHJ1ZSA6IFwib25zY3JvbGxlbmRcIiBpbiB3aW5kb3c7XG5jb25zdCBvYnNlcnZlRWxlbWVudE9mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmYWxsYmFjayA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgY29uc3QgeyBob3Jpem9udGFsLCBpc1J0bCB9ID0gaW5zdGFuY2Uub3B0aW9ucztcbiAgICBvZmZzZXQgPSBob3Jpem9udGFsID8gZWxlbWVudFtcInNjcm9sbExlZnRcIl0gKiAoaXNSdGwgJiYgLTEgfHwgMSkgOiBlbGVtZW50W1wic2Nyb2xsVG9wXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgY29uc3QgcmVnaXN0ZXJTY3JvbGxlbmRFdmVudCA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQ7XG4gIGlmIChyZWdpc3RlclNjcm9sbGVuZEV2ZW50KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBvYnNlcnZlV2luZG93T2Zmc2V0ID0gKGluc3RhbmNlLCBjYikgPT4ge1xuICBjb25zdCBlbGVtZW50ID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudDtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IGluc3RhbmNlLnRhcmdldFdpbmRvdztcbiAgaWYgKCF0YXJnZXRXaW5kb3cpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZhbGxiYWNrID0gaW5zdGFuY2Uub3B0aW9ucy51c2VTY3JvbGxlbmRFdmVudCAmJiBzdXBwb3J0c1Njcm9sbGVuZCA/ICgpID0+IHZvaWQgMCA6IGRlYm91bmNlKFxuICAgIHRhcmdldFdpbmRvdyxcbiAgICAoKSA9PiB7XG4gICAgICBjYihvZmZzZXQsIGZhbHNlKTtcbiAgICB9LFxuICAgIGluc3RhbmNlLm9wdGlvbnMuaXNTY3JvbGxpbmdSZXNldERlbGF5XG4gICk7XG4gIGNvbnN0IGNyZWF0ZUhhbmRsZXIgPSAoaXNTY3JvbGxpbmcpID0+ICgpID0+IHtcbiAgICBvZmZzZXQgPSBlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwic2Nyb2xsWFwiIDogXCJzY3JvbGxZXCJdO1xuICAgIGZhbGxiYWNrKCk7XG4gICAgY2Iob2Zmc2V0LCBpc1Njcm9sbGluZyk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKHRydWUpO1xuICBjb25zdCBlbmRIYW5kbGVyID0gY3JlYXRlSGFuZGxlcihmYWxzZSk7XG4gIGVuZEhhbmRsZXIoKTtcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgY29uc3QgcmVnaXN0ZXJTY3JvbGxlbmRFdmVudCA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQ7XG4gIGlmIChyZWdpc3RlclNjcm9sbGVuZEV2ZW50KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIsIGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyKTtcbiAgICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgIH1cbiAgfTtcbn07XG5jb25zdCBtZWFzdXJlRWxlbWVudCA9IChlbGVtZW50LCBlbnRyeSwgaW5zdGFuY2UpID0+IHtcbiAgaWYgKGVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBlbnRyeS5ib3JkZXJCb3hTaXplKSB7XG4gICAgY29uc3QgYm94ID0gZW50cnkuYm9yZGVyQm94U2l6ZVswXTtcbiAgICBpZiAoYm94KSB7XG4gICAgICBjb25zdCBzaXplID0gTWF0aC5yb3VuZChcbiAgICAgICAgYm94W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwiaW5saW5lU2l6ZVwiIDogXCJibG9ja1NpemVcIl1cbiAgICAgICk7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnRbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJvZmZzZXRXaWR0aFwiIDogXCJvZmZzZXRIZWlnaHRcIl07XG59O1xuY29uc3Qgd2luZG93U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNvbnN0IGVsZW1lbnRTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY2xhc3MgVmlydHVhbGl6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy51bnN1YnMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0V2luZG93ID0gbnVsbDtcbiAgICB0aGlzLmlzU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IFtdO1xuICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICB0aGlzLnNjcm9sbFJlY3QgPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbERpcmVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxBZGp1c3RtZW50cyA9IDA7XG4gICAgdGhpcy5lbGVtZW50c0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgICBsZXQgX3JvID0gbnVsbDtcbiAgICAgIGNvbnN0IGdldCA9ICgpID0+IHtcbiAgICAgICAgaWYgKF9ybykge1xuICAgICAgICAgIHJldHVybiBfcm87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFdpbmRvdyB8fCAhdGhpcy50YXJnZXRXaW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JvID0gbmV3IHRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKSA6IHJ1bigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIF9ybyA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG9ic2VydmU6ICh0YXJnZXQpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIChfYSA9IGdldCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2Eub2JzZXJ2ZSh0YXJnZXQsIHsgYm94OiBcImJvcmRlci1ib3hcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5vYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgdGhpcy5yYW5nZSA9IG51bGw7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gKG9wdHMyKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRzMikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIGRlbGV0ZSBvcHRzMltrZXldO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbE9mZnNldDogMCxcbiAgICAgICAgb3ZlcnNjYW46IDEsXG4gICAgICAgIHBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgcGFkZGluZ0VuZDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ1N0YXJ0OiAwLFxuICAgICAgICBzY3JvbGxQYWRkaW5nRW5kOiAwLFxuICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgZ2V0SXRlbUtleTogZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgICAgICAgcmFuZ2VFeHRyYWN0b3I6IGRlZmF1bHRSYW5nZUV4dHJhY3RvcixcbiAgICAgICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgbWVhc3VyZUVsZW1lbnQsXG4gICAgICAgIGluaXRpYWxSZWN0OiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgc2Nyb2xsTWFyZ2luOiAwLFxuICAgICAgICBnYXA6IDAsXG4gICAgICAgIGluZGV4QXR0cmlidXRlOiBcImRhdGEtaW5kZXhcIixcbiAgICAgICAgaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlOiBbXSxcbiAgICAgICAgbGFuZXM6IDEsXG4gICAgICAgIGlzU2Nyb2xsaW5nUmVzZXREZWxheTogMTUwLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpc1J0bDogZmFsc2UsXG4gICAgICAgIHVzZVNjcm9sbGVuZEV2ZW50OiBmYWxzZSxcbiAgICAgICAgdXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXI6IGZhbHNlLFxuICAgICAgICAuLi5vcHRzMlxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm90aWZ5ID0gKHN5bmMpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMpLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGhpcywgc3luYyk7XG4gICAgfTtcbiAgICB0aGlzLm1heWJlTm90aWZ5ID0gbWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2Uuc3RhcnRJbmRleCA6IG51bGwsXG4gICAgICAgICAgdGhpcy5yYW5nZSA/IHRoaXMucmFuZ2UuZW5kSW5kZXggOiBudWxsXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgIHRoaXMubm90aWZ5KGlzU2Nyb2xsaW5nKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwibWF5YmVOb3RpZnlcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgaW5pdGlhbERlcHM6IFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVuc3Vicy5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLl9kaWRNb3VudCA9ICgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMuX3dpbGxVcGRhdGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZWQgPyB0aGlzLm9wdGlvbnMuZ2V0U2Nyb2xsRWxlbWVudCgpIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgIT09IHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIGlmICghc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRWxlbWVudCAmJiBcIm93bmVyRG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9IHRoaXMuc2Nyb2xsRWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudGFyZ2V0V2luZG93ID0gKChfYSA9IHRoaXMuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpbmRvdykgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkKSA9PiB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGNhY2hlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpLCB7XG4gICAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgICBiZWhhdmlvcjogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVuc3Vicy5wdXNoKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vYnNlcnZlRWxlbWVudFJlY3QodGhpcywgKHJlY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRPZmZzZXQodGhpcywgKG9mZnNldCwgaXNTY3JvbGxpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBpc1Njcm9sbGluZyA/IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgPCBvZmZzZXQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBpc1Njcm9sbGluZztcbiAgICAgICAgICAgIHRoaXMubWF5YmVOb3RpZnkoKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nZXRTaXplID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsUmVjdCA9IHRoaXMuc2Nyb2xsUmVjdCA/PyB0aGlzLm9wdGlvbnMuaW5pdGlhbFJlY3Q7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxSZWN0W3RoaXMub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XG4gICAgfTtcbiAgICB0aGlzLmdldFNjcm9sbE9mZnNldCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gdGhpcy5zY3JvbGxPZmZzZXQgPz8gKHR5cGVvZiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQoKSA6IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbE9mZnNldDtcbiAgICB9O1xuICAgIHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudCA9IChtZWFzdXJlbWVudHMsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGZ1cnRoZXN0TWVhc3VyZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IG0gPSBpbmRleCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW21dO1xuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5oYXMobWVhc3VyZW1lbnQubGFuZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c0Z1cnRoZXN0TWVhc3VyZW1lbnQgPSBmdXJ0aGVzdE1lYXN1cmVtZW50cy5nZXQoXG4gICAgICAgICAgbWVhc3VyZW1lbnQubGFuZVxuICAgICAgICApO1xuICAgICAgICBpZiAocHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID09IG51bGwgfHwgbWVhc3VyZW1lbnQuZW5kID4gcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNldChtZWFzdXJlbWVudC5sYW5lLCBtZWFzdXJlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVhc3VyZW1lbnQuZW5kIDwgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCkge1xuICAgICAgICAgIGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuc2V0KG1lYXN1cmVtZW50LmxhbmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVydGhlc3RNZWFzdXJlbWVudHMuc2l6ZSA9PT0gdGhpcy5vcHRpb25zLmxhbmVzID8gQXJyYXkuZnJvbShmdXJ0aGVzdE1lYXN1cmVtZW50cy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5lbmQgPT09IGIuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZCAtIGIuZW5kO1xuICAgICAgfSlbMF0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50T3B0aW9ucyA9IG1lbW8oXG4gICAgICAoKSA9PiBbXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydCxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbixcbiAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXksXG4gICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkXG4gICAgICBdLFxuICAgICAgKGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvdW50LFxuICAgICAgICAgIHBhZGRpbmdTdGFydCxcbiAgICAgICAgICBzY3JvbGxNYXJnaW4sXG4gICAgICAgICAgZ2V0SXRlbUtleSxcbiAgICAgICAgICBlbmFibGVkXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IGZhbHNlXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldE1lYXN1cmVtZW50cyA9IG1lbW8oXG4gICAgICAoKSA9PiBbdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMoKSwgdGhpcy5pdGVtU2l6ZUNhY2hlXSxcbiAgICAgICh7IGNvdW50LCBwYWRkaW5nU3RhcnQsIHNjcm9sbE1hcmdpbiwgZ2V0SXRlbUtleSwgZW5hYmxlZCB9LCBpdGVtU2l6ZUNhY2hlKSA9PiB7XG4gICAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IHRoaXMub3B0aW9ucy5pbml0aWFsTWVhc3VyZW1lbnRzQ2FjaGU7XG4gICAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUuc2V0KGl0ZW0ua2V5LCBpdGVtLnNpemUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbiA9IHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLmxlbmd0aCA+IDAgPyBNYXRoLm1pbiguLi50aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcykgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcyA9IFtdO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlLnNsaWNlKDAsIG1pbik7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaW47IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0SXRlbUtleShpKTtcbiAgICAgICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50ID0gdGhpcy5vcHRpb25zLmxhbmVzID09PSAxID8gbWVhc3VyZW1lbnRzW2kgLSAxXSA6IHRoaXMuZ2V0RnVydGhlc3RNZWFzdXJlbWVudChtZWFzdXJlbWVudHMsIGkpO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZnVydGhlc3RNZWFzdXJlbWVudCA/IGZ1cnRoZXN0TWVhc3VyZW1lbnQuZW5kICsgdGhpcy5vcHRpb25zLmdhcCA6IHBhZGRpbmdTdGFydCArIHNjcm9sbE1hcmdpbjtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlZFNpemUgPSBpdGVtU2l6ZUNhY2hlLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlb2YgbWVhc3VyZWRTaXplID09PSBcIm51bWJlclwiID8gbWVhc3VyZWRTaXplIDogdGhpcy5vcHRpb25zLmVzdGltYXRlU2l6ZShpKTtcbiAgICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHNpemU7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmxhbmUgOiBpICUgdGhpcy5vcHRpb25zLmxhbmVzO1xuICAgICAgICAgIG1lYXN1cmVtZW50c1tpXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbGFuZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlbWVudHNDYWNoZSA9IG1lYXN1cmVtZW50cztcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVtZW50cztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0TWVhc3VyZW1lbnRzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLmdldE1lYXN1cmVtZW50cygpLFxuICAgICAgICB0aGlzLmdldFNpemUoKSxcbiAgICAgICAgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmxhbmVzXG4gICAgICBdLFxuICAgICAgKG1lYXN1cmVtZW50cywgb3V0ZXJTaXplLCBzY3JvbGxPZmZzZXQsIGxhbmVzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlID0gbWVhc3VyZW1lbnRzLmxlbmd0aCA+IDAgJiYgb3V0ZXJTaXplID4gMCA/IGNhbGN1bGF0ZVJhbmdlKHtcbiAgICAgICAgICBtZWFzdXJlbWVudHMsXG4gICAgICAgICAgb3V0ZXJTaXplLFxuICAgICAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICB9KSA6IG51bGw7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImNhbGN1bGF0ZVJhbmdlXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEluZGV4ZXMgPSBtZW1vKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGhpcy5jYWxjdWxhdGVSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICAgICAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF5YmVOb3RpZnkudXBkYXRlRGVwcyhbdGhpcy5pc1Njcm9sbGluZywgc3RhcnRJbmRleCwgZW5kSW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJzY2FuLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jb3VudCxcbiAgICAgICAgICBzdGFydEluZGV4LFxuICAgICAgICAgIGVuZEluZGV4XG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgKHJhbmdlRXh0cmFjdG9yLCBvdmVyc2NhbiwgY291bnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBzdGFydEluZGV4ID09PSBudWxsIHx8IGVuZEluZGV4ID09PSBudWxsID8gW10gOiByYW5nZUV4dHJhY3Rvcih7XG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhbixcbiAgICAgICAgICBjb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0VmlydHVhbEluZGV4ZXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbmRleEZyb21FbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLm9wdGlvbnMuaW5kZXhBdHRyaWJ1dGU7XG4gICAgICBjb25zdCBpbmRleFN0ciA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgaWYgKCFpbmRleFN0cikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYE1pc3NpbmcgYXR0cmlidXRlIG5hbWUgJyR7YXR0cmlidXRlTmFtZX09e2luZGV4fScgb24gbWVhc3VyZWQgZWxlbWVudC5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZUludChpbmRleFN0ciwgMTApO1xuICAgIH07XG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAobm9kZSwgZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleEZyb21FbGVtZW50KG5vZGUpO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLmVsZW1lbnRzQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUocHJldk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLnNldChrZXksIG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5yZXNpemVJdGVtKGluZGV4LCB0aGlzLm9wdGlvbnMubWVhc3VyZUVsZW1lbnQobm9kZSwgZW50cnksIHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucmVzaXplSXRlbSA9IChpbmRleCwgc2l6ZSkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZUNhY2hlLmdldChpdGVtLmtleSkgPz8gaXRlbS5zaXplO1xuICAgICAgY29uc3QgZGVsdGEgPSBzaXplIC0gaXRlbVNpemU7XG4gICAgICBpZiAoZGVsdGEgIT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlICE9PSB2b2lkIDAgPyB0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZShpdGVtLCBkZWx0YSwgdGhpcykgOiBpdGVtLnN0YXJ0IDwgdGhpcy5nZXRTY3JvbGxPZmZzZXQoKSArIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiY29ycmVjdGlvblwiLCBkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksIHtcbiAgICAgICAgICAgIGFkanVzdG1lbnRzOiB0aGlzLnNjcm9sbEFkanVzdG1lbnRzICs9IGRlbHRhLFxuICAgICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzLnB1c2goaXRlbS5pbmRleCk7XG4gICAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IG5ldyBNYXAodGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgc2l6ZSkpO1xuICAgICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmVFbGVtZW50ID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZm9yRWFjaCgoY2FjaGVkLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAoIWNhY2hlZC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUoY2FjaGVkKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudChub2RlLCB2b2lkIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbXMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0VmlydHVhbEluZGV4ZXMoKSwgdGhpcy5nZXRNZWFzdXJlbWVudHMoKV0sXG4gICAgICAoaW5kZXhlcywgbWVhc3VyZW1lbnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gaW5kZXhlcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzW2tdO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgICAgICAgIHZpcnR1YWxJdGVtcy5wdXNoKG1lYXN1cmVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlydHVhbEl0ZW1zO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJnZXRWaXJ0dWFsSXRlbXNcIixcbiAgICAgICAgZGVidWc6ICgpID0+IHRoaXMub3B0aW9ucy5kZWJ1Z1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRWaXJ0dWFsSXRlbUZvck9mZnNldCA9IChvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBpZiAobWVhc3VyZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFVuZGVmaW5lZChcbiAgICAgICAgbWVhc3VyZW1lbnRzW2ZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgKGluZGV4KSA9PiBub3RVbmRlZmluZWQobWVhc3VyZW1lbnRzW2luZGV4XSkuc3RhcnQsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgICldXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQgPSAodG9PZmZzZXQsIGFsaWduLCBpdGVtU2l6ZSA9IDApID0+IHtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGFsaWduID0gdG9PZmZzZXQgPj0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZSA/IFwiZW5kXCIgOiBcInN0YXJ0XCI7XG4gICAgICB9XG4gICAgICBpZiAoYWxpZ24gPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgKz0gKGl0ZW1TaXplIC0gc2l6ZSkgLyAyO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgICB0b09mZnNldCAtPSBzaXplO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gdGhpcy5nZXRUb3RhbFNpemUoKSArIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gLSBzaXplO1xuICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKG1heE9mZnNldCwgdG9PZmZzZXQpLCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXggPSAoaW5kZXgsIGFsaWduID0gXCJhdXRvXCIpID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5nZXRTY3JvbGxPZmZzZXQoKTtcbiAgICAgIGlmIChhbGlnbiA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgaWYgKGl0ZW0uZW5kID49IHNjcm9sbE9mZnNldCArIHNpemUgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCkge1xuICAgICAgICAgIGFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXJ0IDw9IHNjcm9sbE9mZnNldCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwic3RhcnRcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3Njcm9sbE9mZnNldCwgYWxpZ25dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0b09mZnNldCA9IGFsaWduID09PSBcImVuZFwiID8gaXRlbS5lbmQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ0VuZCA6IGl0ZW0uc3RhcnQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduLCBpdGVtLnNpemUpLFxuICAgICAgICBhbGlnblxuICAgICAgXTtcbiAgICB9O1xuICAgIHRoaXMuaXNEeW5hbWljTW9kZSA9ICgpID0+IHRoaXMuZWxlbWVudHNDYWNoZS5zaXplID4gMDtcbiAgICB0aGlzLnNjcm9sbFRvT2Zmc2V0ID0gKHRvT2Zmc2V0LCB7IGFsaWduID0gXCJzdGFydFwiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiksIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxUb0luZGV4ID0gKGluZGV4LCB7IGFsaWduOiBpbml0aWFsQWxpZ24gPSBcImF1dG9cIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSAxMDtcbiAgICAgIGNvbnN0IHRyeVNjcm9sbCA9IChjdXJyZW50QWxpZ24pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFdpbmRvdykgcmV0dXJuO1xuICAgICAgICBjb25zdCBvZmZzZXRJbmZvID0gdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgY3VycmVudEFsaWduKTtcbiAgICAgICAgaWYgKCFvZmZzZXRJbmZvKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGdldCBvZmZzZXQgZm9yIGluZGV4OlwiLCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvZmZzZXQsIGFsaWduXSA9IG9mZnNldEluZm87XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KG9mZnNldCwgeyBhZGp1c3RtZW50czogdm9pZCAwLCBiZWhhdmlvciB9KTtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gdGhpcy5nZXRTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgICBjb25zdCBhZnRlckluZm8gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBhbGlnbik7XG4gICAgICAgICAgaWYgKCFhZnRlckluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBnZXQgb2Zmc2V0IGZvciBpbmRleDpcIiwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFwcHJveEVxdWFsKGFmdGVySW5mb1swXSwgY3VycmVudE9mZnNldCkpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlUmV0cnkoYWxpZ24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NoZWR1bGVSZXRyeSA9IChhbGlnbikgPT4ge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0V2luZG93KSByZXR1cm47XG4gICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgIGlmIChhdHRlbXB0cyA8IG1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlNjaGVkdWxlIHJldHJ5XCIsIGF0dGVtcHRzLCBtYXhBdHRlbXB0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGFyZ2V0V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0cnlTY3JvbGwoYWxpZ24pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHNjcm9sbCB0byBpbmRleCAke2luZGV4fSBhZnRlciAke21heEF0dGVtcHRzfSBhdHRlbXB0cy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRyeVNjcm9sbChpbml0aWFsQWxpZ24pO1xuICAgIH07XG4gICAgdGhpcy5zY3JvbGxCeSA9IChkZWx0YSwgeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyBkZWx0YSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBsZXQgZW5kO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmxhbmVzID09PSAxKSB7XG4gICAgICAgIGVuZCA9ICgoX2EgPSBtZWFzdXJlbWVudHNbbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kKSA/PyAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW5kQnlMYW5lID0gQXJyYXkodGhpcy5vcHRpb25zLmxhbmVzKS5maWxsKG51bGwpO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGVuZEluZGV4ID49IDAgJiYgZW5kQnlMYW5lLnNvbWUoKHZhbCkgPT4gdmFsID09PSBudWxsKSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbZW5kSW5kZXhdO1xuICAgICAgICAgIGlmIChlbmRCeUxhbmVbaXRlbS5sYW5lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZW5kQnlMYW5lW2l0ZW0ubGFuZV0gPSBpdGVtLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kSW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICBlbmQgPSBNYXRoLm1heCguLi5lbmRCeUxhbmUuZmlsdGVyKCh2YWwpID0+IHZhbCAhPT0gbnVsbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgICBlbmQgLSB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luICsgdGhpcy5vcHRpb25zLnBhZGRpbmdFbmQsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfTtcbiAgICB0aGlzLl9zY3JvbGxUb09mZnNldCA9IChvZmZzZXQsIHtcbiAgICAgIGFkanVzdG1lbnRzLFxuICAgICAgYmVoYXZpb3JcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9GbihvZmZzZXQsIHsgYmVoYXZpb3IsIGFkanVzdG1lbnRzIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlID0gKCkgPT4ge1xuICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMubm90aWZ5KGZhbHNlKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRzKTtcbiAgfVxufVxuY29uc3QgZmluZE5lYXJlc3RCaW5hcnlTZWFyY2ggPSAobG93LCBoaWdoLCBnZXRDdXJyZW50VmFsdWUsIHZhbHVlKSA9PiB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIGNvbnN0IG1pZGRsZSA9IChsb3cgKyBoaWdoKSAvIDIgfCAwO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldEN1cnJlbnRWYWx1ZShtaWRkbGUpO1xuICAgIGlmIChjdXJyZW50VmFsdWUgPCB2YWx1ZSkge1xuICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IHZhbHVlKSB7XG4gICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9XG4gIH1cbiAgaWYgKGxvdyA+IDApIHtcbiAgICByZXR1cm4gbG93IC0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVJhbmdlKHtcbiAgbWVhc3VyZW1lbnRzLFxuICBvdXRlclNpemUsXG4gIHNjcm9sbE9mZnNldCxcbiAgbGFuZXNcbn0pIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGdldE9mZnNldCA9IChpbmRleCkgPT4gbWVhc3VyZW1lbnRzW2luZGV4XS5zdGFydDtcbiAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPD0gbGFuZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRJbmRleDogMCxcbiAgICAgIGVuZEluZGV4OiBsYXN0SW5kZXhcbiAgICB9O1xuICB9XG4gIGxldCBzdGFydEluZGV4ID0gZmluZE5lYXJlc3RCaW5hcnlTZWFyY2goXG4gICAgMCxcbiAgICBsYXN0SW5kZXgsXG4gICAgZ2V0T2Zmc2V0LFxuICAgIHNjcm9sbE9mZnNldFxuICApO1xuICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4O1xuICBpZiAobGFuZXMgPT09IDEpIHtcbiAgICB3aGlsZSAoZW5kSW5kZXggPCBsYXN0SW5kZXggJiYgbWVhc3VyZW1lbnRzW2VuZEluZGV4XS5lbmQgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpIHtcbiAgICAgIGVuZEluZGV4Kys7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxhbmVzID4gMSkge1xuICAgIGNvbnN0IGVuZFBlckxhbmUgPSBBcnJheShsYW5lcykuZmlsbCgwKTtcbiAgICB3aGlsZSAoZW5kSW5kZXggPCBsYXN0SW5kZXggJiYgZW5kUGVyTGFuZS5zb21lKChwb3MpID0+IHBvcyA8IHNjcm9sbE9mZnNldCArIG91dGVyU2l6ZSkpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbZW5kSW5kZXhdO1xuICAgICAgZW5kUGVyTGFuZVtpdGVtLmxhbmVdID0gaXRlbS5lbmQ7XG4gICAgICBlbmRJbmRleCsrO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFBlckxhbmUgPSBBcnJheShsYW5lcykuZmlsbChzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpO1xuICAgIHdoaWxlIChzdGFydEluZGV4ID49IDAgJiYgc3RhcnRQZXJMYW5lLnNvbWUoKHBvcykgPT4gcG9zID49IHNjcm9sbE9mZnNldCkpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbc3RhcnRJbmRleF07XG4gICAgICBzdGFydFBlckxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uc3RhcnQ7XG4gICAgICBzdGFydEluZGV4LS07XG4gICAgfVxuICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCBzdGFydEluZGV4IC0gc3RhcnRJbmRleCAlIGxhbmVzKTtcbiAgICBlbmRJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCwgZW5kSW5kZXggKyAobGFuZXMgLSAxIC0gZW5kSW5kZXggJSBsYW5lcykpO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH07XG59XG5leHBvcnQge1xuICBWaXJ0dWFsaXplcixcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gIGVsZW1lbnRTY3JvbGwsXG4gIG1lYXN1cmVFbGVtZW50LFxuICBtZW1vLFxuICBub3RVbmRlZmluZWQsXG4gIG9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gIG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gIG9ic2VydmVXaW5kb3dSZWN0LFxuICB3aW5kb3dTY3JvbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QixHQUFHLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXLElBQUksT0FBTztBQUNqRSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90cmFkZXVsLXNjYW5uZXItZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcz80YTc5Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBvcHRzLmluaXRpYWxEZXBzID8/IFtdO1xuICBsZXQgcmVzdWx0O1xuICBmdW5jdGlvbiBtZW1vaXplZEZ1bmN0aW9uKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYSA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMpKSkgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9iID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0cykpKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYyA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKG9wdHMpKSkge1xuICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIHJlc3VsdFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgc3RyID0gXCIgXCIgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH07XG4gICAgICBjb25zb2xlLmluZm8oXG4gICAgICAgIGAlY+KPsSAke3BhZChyZXN1bHRFbmRUaW1lLCA1KX0gLyR7cGFkKGRlcEVuZFRpbWUsIDUpfSBtc2AsXG4gICAgICAgIGBcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogLjZyZW07XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIGNvbG9yOiBoc2woJHtNYXRoLm1heChcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMClcbiAgICAgICAgKX1kZWcgMTAwJSAzMSUpO2AsXG4gICAgICAgIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMua2V5XG4gICAgICApO1xuICAgIH1cbiAgICAoX2QgPSBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChvcHRzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbWVtb2l6ZWRGdW5jdGlvbi51cGRhdGVEZXBzID0gKG5ld0RlcHMpID0+IHtcbiAgICBkZXBzID0gbmV3RGVwcztcbiAgfTtcbiAgcmV0dXJuIG1lbW9pemVkRnVuY3Rpb247XG59XG5mdW5jdGlvbiBub3RVbmRlZmluZWQodmFsdWUsIG1zZykge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB1bmRlZmluZWQke21zZyA/IGA6ICR7bXNnfWAgOiBcIlwifWApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuY29uc3QgYXBwcm94RXF1YWwgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpIDwgMS4wMTtcbmNvbnN0IGRlYm91bmNlID0gKHRhcmdldFdpbmRvdywgZm4sIG1zKSA9PiB7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgdGFyZ2V0V2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIHRpbWVvdXRJZCA9IHRhcmdldFdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGZuLmFwcGx5KHRoaXMsIGFyZ3MpLCBtcyk7XG4gIH07XG59O1xuZXhwb3J0IHtcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBtZW1vLFxuICBub3RVbmRlZmluZWRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;