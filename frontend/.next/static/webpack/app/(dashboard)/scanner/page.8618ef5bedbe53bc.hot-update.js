"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/scanner/page",{

/***/ "(app-pages-browser)/./lib/window-injector.ts":
/*!********************************!*\
  !*** ./lib/window-injector.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   openInjectedWindow: function() { return /* binding */ openInjectedWindow; },\n/* harmony export */   sendAggregateToChild: function() { return /* binding */ sendAggregateToChild; },\n/* harmony export */   sendConnectionStatusToChild: function() { return /* binding */ sendConnectionStatusToChild; },\n/* harmony export */   sendDeltaToChild: function() { return /* binding */ sendDeltaToChild; },\n/* harmony export */   sendSnapshotToChild: function() { return /* binding */ sendSnapshotToChild; },\n/* harmony export */   setupChildCommunication: function() { return /* binding */ setupChildCommunication; }\n/* harmony export */ });\n/**\n * Sistema de Ventanas con about:blank + Inyección Dinámica\n * Inspirado en Godel Terminal\n * \n * Ventajas:\n * - No dispara bloqueadores de pop-ups\n * - Mantiene WebSocket activo via SharedWorker\n * - Inyecta contenido dinámicamente sin full page reload\n * - Comunicación bidireccional via postMessage\n */ /**\n * Abre una ventana about:blank e inyecta el contenido dinámicamente\n */ function openInjectedWindow(data, config) {\n    const { width = 1200, height = 800, centered = true } = config;\n    // Calcular posición centrada\n    const left = centered ? (window.screen.width - width) / 2 : 100;\n    const top = centered ? (window.screen.height - height) / 2 : 100;\n    const windowFeatures = [\n        \"width=\".concat(width),\n        \"height=\".concat(height),\n        \"left=\".concat(left),\n        \"top=\".concat(top),\n        \"resizable=yes\",\n        \"scrollbars=yes\",\n        \"status=yes\"\n    ].join(\",\");\n    // 1. Abrir about:blank (no dispara bloqueador)\n    const newWindow = window.open(\"about:blank\", \"_blank\", windowFeatures);\n    if (!newWindow) {\n        console.error(\"❌ Failed to open window (popup blocked?)\");\n        return null;\n    }\n    // 2. Inyectar contenido inmediatamente\n    injectContent(newWindow, data, config);\n    return newWindow;\n}\n/**\n * Inyecta el HTML completo en la ventana about:blank\n */ function injectContent(targetWindow, data, config) {\n    const { title } = config;\n    const origin = window.location.origin;\n    // HTML template LIGERO sin dependencias CDN\n    const htmlContent = '\\n<!DOCTYPE html>\\n<html lang=\"es\">\\n<head>\\n  <meta charset=\"UTF-8\">\\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n  <title>'.concat(title, ' - Tradeul</title>\\n  \\n  <style>\\n    /* Reset y estilos base */\\n    * { box-sizing: border-box; margin: 0; padding: 0; }\\n    \\n    body {\\n      margin: 0;\\n      padding: 0;\\n      font-family: -apple-system, BlinkMacSystemFont, \\'Segoe UI\\', \\'Roboto\\', sans-serif;\\n      -webkit-font-smoothing: antialiased;\\n      background: #ffffff;\\n      overflow: hidden;\\n    }\\n    \\n    /* Animaci\\xf3n de loading */\\n    @keyframes pulse {\\n      0%, 100% { opacity: 1; }\\n      50% { opacity: 0.5; }\\n    }\\n    \\n    @keyframes spin {\\n      to { transform: rotate(360deg); }\\n    }\\n    \\n    .loading-spinner {\\n      display: inline-block;\\n      width: 48px;\\n      height: 48px;\\n      border: 4px solid #e2e8f0;\\n      border-top-color: #3b82f6;\\n      border-radius: 50%;\\n      animation: spin 1s linear infinite;\\n    }\\n    \\n    /* Layout principal */\\n    .app-container {\\n      display: flex;\\n      flex-direction: column;\\n      height: 100vh;\\n      width: 100vw;\\n    }\\n    \\n    /* Header de la tabla */\\n    .table-header {\\n      display: flex;\\n      align-items: center;\\n      justify-content: space-between;\\n      padding: 12px 16px;\\n      background: white;\\n      border-bottom: 2px solid #3b82f6;\\n      flex-shrink: 0;\\n    }\\n    \\n    .header-left {\\n      display: flex;\\n      align-items: center;\\n      gap: 16px;\\n    }\\n    \\n    .header-title {\\n      display: flex;\\n      align-items: center;\\n      gap: 8px;\\n    }\\n    \\n    .title-indicator {\\n      width: 4px;\\n      height: 24px;\\n      background: #3b82f6;\\n      border-radius: 2px;\\n    }\\n    \\n    .title-text {\\n      font-size: 18px;\\n      font-weight: 700;\\n      color: #0f172a;\\n    }\\n    \\n    .status-badge {\\n      display: flex;\\n      align-items: center;\\n      gap: 6px;\\n    }\\n    \\n    .status-dot {\\n      width: 8px;\\n      height: 8px;\\n      border-radius: 50%;\\n      background: #94a3b8;\\n    }\\n    \\n    .status-dot.live {\\n      background: #10b981;\\n      animation: pulse 2s ease-in-out infinite;\\n    }\\n    \\n    .status-text {\\n      font-size: 12px;\\n      font-weight: 500;\\n      color: #64748b;\\n    }\\n    \\n    .status-text.live {\\n      color: #10b981;\\n    }\\n    \\n    .count-badge {\\n      display: flex;\\n      align-items: center;\\n      gap: 6px;\\n      padding: 4px 12px;\\n      background: #eff6ff;\\n      border: 1px solid #bfdbfe;\\n      border-radius: 6px;\\n    }\\n    \\n    .count-number {\\n      font-size: 14px;\\n      font-weight: 600;\\n      color: #2563eb;\\n    }\\n    \\n    .count-label {\\n      font-size: 12px;\\n      color: #64748b;\\n    }\\n    \\n    .header-right {\\n      font-size: 12px;\\n      color: #64748b;\\n    }\\n    \\n    .timestamp {\\n      font-family: monospace;\\n      font-weight: 500;\\n      color: #0f172a;\\n    }\\n    \\n    /* Tabla */\\n    .table-container {\\n      flex: 1;\\n      overflow: auto;\\n      background: white;\\n    }\\n    \\n    table {\\n      width: 100%;\\n      border-collapse: collapse;\\n    }\\n    \\n    thead {\\n      position: sticky;\\n      top: 0;\\n      background: #f8fafc;\\n      border-bottom: 1px solid #e2e8f0;\\n      z-index: 10;\\n    }\\n    \\n    th {\\n      padding: 12px 16px;\\n      text-align: left;\\n      font-size: 11px;\\n      font-weight: 700;\\n      color: #475569;\\n      text-transform: uppercase;\\n      letter-spacing: 0.05em;\\n    }\\n    \\n    th.text-right { text-align: right; }\\n    \\n    tbody tr {\\n      border-bottom: 1px solid #f1f5f9;\\n      transition: background 0.15s;\\n    }\\n    \\n    tbody tr:hover {\\n      background: #f8fafc;\\n    }\\n    \\n    td {\\n      padding: 12px 16px;\\n      font-size: 14px;\\n    }\\n    \\n    td.text-right { text-align: right; }\\n    \\n    .rank-cell {\\n      font-weight: 600;\\n      color: #94a3b8;\\n    }\\n    \\n    .symbol-cell {\\n      font-weight: 700;\\n      color: #2563eb;\\n      cursor: pointer;\\n    }\\n    \\n    .symbol-cell:hover {\\n      color: #1d4ed8;\\n      text-decoration: underline;\\n    }\\n    \\n    .price-cell {\\n      font-family: monospace;\\n      font-weight: 600;\\n      color: #0f172a;\\n    }\\n    \\n    .change-cell {\\n      font-family: monospace;\\n      padding: 4px 8px;\\n      border-radius: 4px;\\n      font-weight: 700;\\n    }\\n    \\n    .change-cell.positive {\\n      background: #dcfce7;\\n      color: #16a34a;\\n    }\\n    \\n    .change-cell.negative {\\n      background: #fee2e2;\\n      color: #dc2626;\\n    }\\n    \\n    .mono {\\n      font-family: monospace;\\n    }\\n    \\n    /* Estado vac\\xedo / loading */\\n    .empty-state {\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n      justify-content: center;\\n      height: calc(100vh - 60px);\\n      color: #64748b;\\n    }\\n    \\n    .empty-icon {\\n      font-size: 64px;\\n      margin-bottom: 16px;\\n      opacity: 0.5;\\n    }\\n    \\n    .empty-title {\\n      font-size: 20px;\\n      font-weight: 600;\\n      color: #0f172a;\\n      margin-bottom: 8px;\\n    }\\n    \\n    .empty-message {\\n      font-size: 14px;\\n      color: #64748b;\\n    }\\n  </style>\\n</head>\\n<body>\\n  <div id=\"root\" class=\"app-container\">\\n    <!-- Pantalla de carga inicial -->\\n    <div class=\"empty-state\">\\n      <div class=\"loading-spinner\"></div>\\n      <div class=\"empty-title\" style=\"margin-top: 16px;\">Cargando ').concat(title, '...</div>\\n      <div class=\"empty-message\">Conectando al servidor...</div>\\n    </div>\\n  </div>\\n\\n  <script>\\n    // ============================================================================\\n    // CONFIGURACI\\xd3N INICIAL\\n    // ============================================================================\\n    \\n    const CONFIG = ').concat(JSON.stringify(data), \";\\n    const PARENT_ORIGIN = '\").concat(origin, \"';\\n    \\n    console.log('\\uD83D\\uDE80 [InjectedWindow] Initializing...', CONFIG);\\n    \\n    // ============================================================================\\n    // COMUNICACI\\xd3N CON VENTANA PADRE\\n    // ============================================================================\\n    \\n    // Enviar mensaje al padre solicitando datos iniciales\\n    function requestInitialData() {\\n      if (window.opener && !window.opener.closed) {\\n        window.opener.postMessage({\\n          type: 'child_ready',\\n          listName: CONFIG.listName,\\n          timestamp: new Date().toISOString()\\n        }, PARENT_ORIGIN);\\n        \\n        console.log('\\uD83D\\uDCE4 [InjectedWindow] Requested initial data from parent');\\n      }\\n    }\\n    \\n    // Recibir mensajes del padre\\n    window.addEventListener('message', (event) => {\\n      // Validar origen por seguridad\\n      if (event.origin !== PARENT_ORIGIN) {\\n        console.warn('⚠️ [InjectedWindow] Rejected message from unknown origin:', event.origin);\\n        return;\\n      }\\n      \\n      const { type, data } = event.data;\\n      \\n      console.log('\\uD83D\\uDCE5 [InjectedWindow] Message received:', type, data);\\n      \\n      switch (type) {\\n        case 'snapshot_data':\\n          handleSnapshotData(data);\\n          break;\\n        case 'delta_update':\\n          handleDeltaUpdate(data);\\n          break;\\n        case 'aggregate_update':\\n          handleAggregateUpdate(data);\\n          break;\\n        case 'connection_status':\\n          updateConnectionStatus(data.isConnected);\\n          break;\\n      }\\n    });\\n    \\n    // ============================================================================\\n    // WEBSOCKET CONNECTION (via SharedWorker)\\n    // ============================================================================\\n    \\n    let sharedWorker = null;\\n    let workerPort = null;\\n    let isConnected = false;\\n    let tickersData = new Map();\\n    let tickerOrder = [];\\n    \\n    function initWebSocket() {\\n      try {\\n        // Conectar al SharedWorker existente\\n        sharedWorker = new SharedWorker('/workers/websocket-shared.js', {\\n          name: 'tradeul-websocket'\\n        });\\n        \\n        workerPort = sharedWorker.port;\\n        \\n        workerPort.onmessage = (event) => {\\n          const msg = event.data;\\n          \\n          switch (msg.type) {\\n            case 'message':\\n              handleWebSocketMessage(msg.data);\\n              break;\\n            case 'status':\\n              isConnected = msg.isConnected;\\n              updateConnectionStatus(msg.isConnected);\\n              console.log(`\\uD83D\\uDCCA [InjectedWindow] WS Status: ${msg.isConnected ? 'connected' : 'disconnected'}`);\\n              break;\\n            case 'log':\\n              console.log(`\\uD83D\\uDCDD [SharedWorker] ${msg.message}`, msg.data || '');\\n              break;\\n          }\\n        };\\n        \\n        workerPort.onerror = (error) => {\\n          console.error('❌ [InjectedWindow] SharedWorker error:', error);\\n        };\\n        \\n        workerPort.start();\\n        \\n        // Conectar al WebSocket (si no est\\xe1 ya conectado)\\n        workerPort.postMessage({\\n          action: 'connect',\\n          url: CONFIG.wsUrl\\n        });\\n        \\n        // Suscribirse a la lista\\n        setTimeout(() => {\\n          workerPort.postMessage({\\n            action: 'subscribe_list',\\n            list: CONFIG.listName\\n          });\\n          console.log(`✅ [InjectedWindow] Subscribed to list: ${CONFIG.listName}`);\\n        }, 1000);\\n        \\n      } catch (error) {\\n        console.error('❌ [InjectedWindow] Failed to init WebSocket:', error);\\n        // Fallback: solicitar datos al padre\\n        requestInitialData();\\n      }\\n    }\\n    \\n    function handleWebSocketMessage(message) {\\n      switch (message.type) {\\n        case 'snapshot':\\n          if (message.list === CONFIG.listName) {\\n            handleSnapshotData(message);\\n          }\\n          break;\\n        case 'delta':\\n          if (message.list === CONFIG.listName) {\\n            handleDeltaUpdate(message);\\n          }\\n          break;\\n        case 'aggregate':\\n          handleAggregateUpdate(message);\\n          break;\\n      }\\n    }\\n    \\n    // ============================================================================\\n    // MANEJO DE DATOS\\n    // ============================================================================\\n    \\n    function handleSnapshotData(snapshot) {\\n      console.log('\\uD83D\\uDCF8 [InjectedWindow] Snapshot received:', snapshot.data?.length || 0, 'tickers');\\n      \\n      if (!snapshot.data) return;\\n      \\n      // Limpiar datos anteriores\\n      tickersData.clear();\\n      tickerOrder = [];\\n      \\n      // Cargar snapshot\\n      snapshot.data.forEach((ticker, index) => {\\n        tickersData.set(ticker.symbol, ticker);\\n        tickerOrder.push(ticker.symbol);\\n      });\\n      \\n      renderTable();\\n    }\\n    \\n    function handleDeltaUpdate(delta) {\\n      if (!delta.actions) return;\\n      \\n      delta.actions.forEach(action => {\\n        switch (action.action) {\\n          case 'add':\\n            if (action.data) {\\n              tickersData.set(action.symbol, action.data);\\n              if (!tickerOrder.includes(action.symbol)) {\\n                // Insertar en la posici\\xf3n correcta\\n                const rank = action.rank ?? tickerOrder.length;\\n                tickerOrder.splice(rank, 0, action.symbol);\\n              }\\n            }\\n            break;\\n            \\n          case 'remove':\\n            tickersData.delete(action.symbol);\\n            tickerOrder = tickerOrder.filter(s => s !== action.symbol);\\n            break;\\n            \\n          case 'update':\\n            if (action.data) {\\n              const existing = tickersData.get(action.symbol);\\n              tickersData.set(action.symbol, { ...existing, ...action.data });\\n            }\\n            break;\\n            \\n          case 'rerank':\\n            if (action.old_rank !== undefined && action.new_rank !== undefined) {\\n              const symbol = action.symbol;\\n              tickerOrder = tickerOrder.filter(s => s !== symbol);\\n              tickerOrder.splice(action.new_rank, 0, symbol);\\n            }\\n            break;\\n        }\\n      });\\n      \\n      renderTable();\\n    }\\n    \\n    function handleAggregateUpdate(aggregate) {\\n      if (!aggregate.symbol || !aggregate.data) return;\\n      \\n      const ticker = tickersData.get(aggregate.symbol);\\n      if (ticker) {\\n        // Actualizar precio/volumen en tiempo real\\n        tickersData.set(aggregate.symbol, {\\n          ...ticker,\\n          price: aggregate.data.close ?? ticker.price,\\n          volume: aggregate.data.volume ?? ticker.volume,\\n        });\\n        \\n        // Actualizar solo la fila espec\\xedfica (m\\xe1s eficiente)\\n        updateTickerRow(aggregate.symbol);\\n      }\\n    }\\n    \\n    function updateConnectionStatus(connected) {\\n      const statusEl = document.getElementById('connection-status');\\n      if (statusEl) {\\n        statusEl.className = `w-2 h-2 rounded-full ${connected ? 'bg-green-500' : 'bg-red-500'}`;\\n      }\\n      \\n      const statusText = document.getElementById('connection-text');\\n      if (statusText) {\\n        statusText.textContent = connected ? 'Live' : 'Offline';\\n        statusText.className = `text-xs font-medium ${connected ? 'text-green-600' : 'text-red-600'}`;\\n      }\\n    }\\n    \\n    // ============================================================================\\n    // RENDERIZADO DE LA TABLA\\n    // ============================================================================\\n    \\n    function renderTable() {\\n      const tickers = tickerOrder.map(symbol => tickersData.get(symbol)).filter(Boolean);\\n      \\n      // Si no hay datos, mostrar estado vac\\xedo\\n      if (tickers.length === 0) {\\n        const html = `\\n          <div class=\\\"app-container\\\">\\n            <div class=\\\"table-header\\\">\\n              <div class=\\\"header-left\\\">\\n                <div class=\\\"header-title\\\">\\n                  <div class=\\\"title-indicator\\\"></div>\\n                  <h1 class=\\\"title-text\\\">${CONFIG.categoryName}</h1>\\n                </div>\\n                <div class=\\\"status-badge\\\">\\n                  <div id=\\\"connection-status\\\" class=\\\"status-dot\\\"></div>\\n                  <span id=\\\"connection-text\\\" class=\\\"status-text\\\">Conectando...</span>\\n                </div>\\n                <div class=\\\"count-badge\\\">\\n                  <span class=\\\"count-number\\\">0</span>\\n                  <span class=\\\"count-label\\\">tickers</span>\\n                </div>\\n              </div>\\n              <div class=\\\"header-right\\\">\\n                Actualizado: <span id=\\\"last-update\\\" class=\\\"timestamp\\\">${new Date().toLocaleTimeString()}</span>\\n              </div>\\n            </div>\\n            <div class=\\\"empty-state\\\">\\n              <div class=\\\"empty-icon\\\">\\uD83D\\uDCCA</div>\\n              <div class=\\\"empty-title\\\">No hay datos disponibles</div>\\n              <div class=\\\"empty-message\\\">Esperando actualizaciones del mercado...</div>\\n            </div>\\n          </div>\\n        `;\\n        \\n        const root = document.getElementById('root');\\n        if (root) {\\n          root.innerHTML = html;\\n        }\\n        return;\\n      }\\n      \\n      const html = `\\n        <div class=\\\"app-container\\\">\\n          <!-- Header -->\\n          <div class=\\\"table-header\\\">\\n            <div class=\\\"header-left\\\">\\n              <div class=\\\"header-title\\\">\\n                <div class=\\\"title-indicator\\\"></div>\\n                <h1 class=\\\"title-text\\\">${CONFIG.categoryName}</h1>\\n              </div>\\n              <div class=\\\"status-badge\\\">\\n                <div id=\\\"connection-status\\\" class=\\\"status-dot\\\"></div>\\n                <span id=\\\"connection-text\\\" class=\\\"status-text\\\">Conectando...</span>\\n              </div>\\n              <div class=\\\"count-badge\\\">\\n                <span class=\\\"count-number\\\">${tickers.length}</span>\\n                <span class=\\\"count-label\\\">tickers</span>\\n              </div>\\n            </div>\\n            <div class=\\\"header-right\\\">\\n              Actualizado: <span id=\\\"last-update\\\" class=\\\"timestamp\\\">${new Date().toLocaleTimeString()}</span>\\n            </div>\\n          </div>\\n          \\n          <!-- Table -->\\n          <div class=\\\"table-container\\\">\\n            <table>\\n              <thead>\\n                <tr>\\n                  <th>#</th>\\n                  <th>Symbol</th>\\n                  <th class=\\\"text-right\\\">Price</th>\\n                  <th class=\\\"text-right\\\">Change</th>\\n                  <th class=\\\"text-right\\\">% Change</th>\\n                  <th class=\\\"text-right\\\">Volume</th>\\n                  <th class=\\\"text-right\\\">RVOL</th>\\n                  <th class=\\\"text-right\\\">Gap %</th>\\n                </tr>\\n              </thead>\\n              <tbody>\\n                ${tickers.map((ticker, index) => renderTickerRow(ticker, index + 1)).join('')}\\n              </tbody>\\n            </table>\\n          </div>\\n        </div>\\n      `;\\n      \\n      const root = document.getElementById('root');\\n      if (root) {\\n        root.innerHTML = html;\\n      }\\n      \\n      // Actualizar timestamp\\n      updateTimestamp();\\n    }\\n    \\n    function renderTickerRow(ticker, rank) {\\n      const isPositive = (ticker.change_percent ?? 0) >= 0;\\n      const changeClass = isPositive ? 'positive' : 'negative';\\n      \\n      return `\\n        <tr id=\\\"ticker-row-${ticker.symbol}\\\">\\n          <td class=\\\"rank-cell\\\">${rank}</td>\\n          <td class=\\\"symbol-cell\\\">${ticker.symbol}</td>\\n          <td class=\\\"text-right price-cell\\\">${formatPrice(ticker.price)}</td>\\n          <td class=\\\"text-right mono\\\" style=\\\"color: ${isPositive ? '#16a34a' : '#dc2626'}\\\">${formatChange(ticker.change)}</td>\\n          <td class=\\\"text-right\\\">\\n            <span class=\\\"change-cell ${changeClass}\\\">${formatPercent(ticker.change_percent)}</span>\\n          </td>\\n          <td class=\\\"text-right mono\\\">${formatVolume(ticker.volume)}</td>\\n          <td class=\\\"text-right mono\\\" style=\\\"color: #7c3aed; font-weight: 600;\\\">${formatRVOL(ticker.rvol)}</td>\\n          <td class=\\\"text-right mono\\\" style=\\\"color: ${isPositive ? '#16a34a' : '#dc2626'}\\\">${formatPercent(ticker.gap_percent)}</td>\\n        </tr>\\n      `;\\n    }\\n    \\n    function updateTickerRow(symbol) {\\n      const ticker = tickersData.get(symbol);\\n      if (!ticker) return;\\n      \\n      const rank = tickerOrder.indexOf(symbol) + 1;\\n      const rowEl = document.getElementById(`ticker-row-${symbol}`);\\n      \\n      if (rowEl) {\\n        rowEl.outerHTML = renderTickerRow(ticker, rank);\\n      }\\n      \\n      updateTimestamp();\\n    }\\n    \\n    function updateTimestamp() {\\n      const timestampEl = document.getElementById('last-update');\\n      if (timestampEl) {\\n        timestampEl.textContent = new Date().toLocaleTimeString();\\n      }\\n    }\\n    \\n    // ============================================================================\\n    // FORMATTERS\\n    // ============================================================================\\n    \\n    function formatPrice(value) {\\n      if (value == null) return '-';\\n      return `$${value.toFixed(2)}`;\\n    }\\n    \\n    function formatChange(value) {\\n      if (value == null) return '-';\\n      const sign = value >= 0 ? '+' : '';\\n      return `${sign}${value.toFixed(2)}`;\\n    }\\n    \\n    function formatPercent(value) {\\n      if (value == null) return '-';\\n      const sign = value >= 0 ? '+' : '';\\n      return `${sign}${value.toFixed(2)}%`;\\n    }\\n    \\n    function formatVolume(value) {\\n      if (value == null) return '-';\\n      if (value >= 1e9) return `${(value / 1e9).toFixed(2)}B`;\\n      if (value >= 1e6) return `${(value / 1e6).toFixed(2)}M`;\\n      if (value >= 1e3) return `${(value / 1e3).toFixed(2)}K`;\\n      return value.toFixed(0);\\n    }\\n    \\n    function formatRVOL(value) {\\n      if (value == null) return '-';\\n      return `${value.toFixed(2)}x`;\\n    }\\n    \\n    // ============================================================================\\n    // INIT\\n    // ============================================================================\\n    \\n    // Inicializar WebSocket\\n    initWebSocket();\\n    \\n    // Solicitar datos iniciales del padre (backup si WS falla)\\n    setTimeout(requestInitialData, 500);\\n    \\n    console.log('✅ [InjectedWindow] Initialized successfully');\\n  </script>\\n</body>\\n</html>\\n  \");\n    // NO usar document.write (bloqueante)\n    // En su lugar, reemplazar el documento completo\n    targetWindow.document.open();\n    targetWindow.document.write(htmlContent);\n    targetWindow.document.close();\n    console.log(\"✅ [WindowInjector] Content injected successfully\");\n}\n/**\n * Establece comunicación con ventana hija para enviarle datos\n */ function setupChildCommunication(childWindow, onChildReady) {\n    const handleMessage = (event)=>{\n        // Validar que el mensaje viene de nuestra ventana hija\n        if (event.source !== childWindow) return;\n        const { type } = event.data;\n        if (type === \"child_ready\") {\n            console.log(\"✅ [WindowInjector] Child window is ready\");\n            onChildReady();\n        }\n    };\n    window.addEventListener(\"message\", handleMessage);\n    // Retornar función de cleanup\n    return ()=>{\n        window.removeEventListener(\"message\", handleMessage);\n    };\n}\n/**\n * Envía snapshot inicial a la ventana hija\n */ function sendSnapshotToChild(childWindow, snapshot) {\n    if (childWindow && !childWindow.closed) {\n        childWindow.postMessage({\n            type: \"snapshot_data\",\n            data: snapshot\n        }, window.location.origin);\n    }\n}\n/**\n * Envía delta update a la ventana hija\n */ function sendDeltaToChild(childWindow, delta) {\n    if (childWindow && !childWindow.closed) {\n        childWindow.postMessage({\n            type: \"delta_update\",\n            data: delta\n        }, window.location.origin);\n    }\n}\n/**\n * Envía aggregate update a la ventana hija\n */ function sendAggregateToChild(childWindow, aggregate) {\n    if (childWindow && !childWindow.closed) {\n        childWindow.postMessage({\n            type: \"aggregate_update\",\n            data: aggregate\n        }, window.location.origin);\n    }\n}\n/**\n * Envía estado de conexión a la ventana hija\n */ function sendConnectionStatusToChild(childWindow, isConnected) {\n    if (childWindow && !childWindow.closed) {\n        childWindow.postMessage({\n            type: \"connection_status\",\n            data: {\n                isConnected\n            }\n        }, window.location.origin);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi93aW5kb3ctaW5qZWN0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBa0JEOztDQUVDLEdBQ00sU0FBU0EsbUJBQ2RDLElBQWdCLEVBQ2hCQyxNQUE0QjtJQUU1QixNQUFNLEVBQ0pDLFFBQVEsSUFBSSxFQUNaQyxTQUFTLEdBQUcsRUFDWkMsV0FBVyxJQUFJLEVBQ2hCLEdBQUdIO0lBRUosNkJBQTZCO0lBQzdCLE1BQU1JLE9BQU9ELFdBQ1QsQ0FBQ0UsT0FBT0MsTUFBTSxDQUFDTCxLQUFLLEdBQUdBLEtBQUksSUFBSyxJQUNoQztJQUNKLE1BQU1NLE1BQU1KLFdBQ1IsQ0FBQ0UsT0FBT0MsTUFBTSxDQUFDSixNQUFNLEdBQUdBLE1BQUssSUFBSyxJQUNsQztJQUVKLE1BQU1NLGlCQUFpQjtRQUNwQixTQUFjLE9BQU5QO1FBQ1IsVUFBZ0IsT0FBUEM7UUFDVCxRQUFZLE9BQUxFO1FBQ1AsT0FBVSxPQUFKRztRQUNQO1FBQ0E7UUFDQTtLQUNELENBQUNFLElBQUksQ0FBQztJQUVQLCtDQUErQztJQUMvQyxNQUFNQyxZQUFZTCxPQUFPTSxJQUFJLENBQUMsZUFBZSxVQUFVSDtJQUV2RCxJQUFJLENBQUNFLFdBQVc7UUFDZEUsUUFBUUMsS0FBSyxDQUFDO1FBQ2QsT0FBTztJQUNUO0lBRUEsdUNBQXVDO0lBQ3ZDQyxjQUFjSixXQUFXWCxNQUFNQztJQUUvQixPQUFPVTtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTSSxjQUNQQyxZQUFvQixFQUNwQmhCLElBQWdCLEVBQ2hCQyxNQUE0QjtJQUU1QixNQUFNLEVBQUVnQixLQUFLLEVBQUUsR0FBR2hCO0lBQ2xCLE1BQU1pQixTQUFTWixPQUFPYSxRQUFRLENBQUNELE1BQU07SUFFckMsNENBQTRDO0lBQzVDLE1BQU1FLGNBQWMsNkpBOFE4Q0gsT0F4UXpEQSxPQUFNLCtxS0FrUklJLE9BVitDSixPQUFNLHlWQVc3Q0MsT0FEUkcsS0FBS0MsU0FBUyxDQUFDdEIsT0FBTSxrQ0FDTixPQUFQa0IsUUFBTztJQWdhbEMsc0NBQXNDO0lBQ3RDLGdEQUFnRDtJQUNoREYsYUFBYU8sUUFBUSxDQUFDWCxJQUFJO0lBQzFCSSxhQUFhTyxRQUFRLENBQUNDLEtBQUssQ0FBQ0o7SUFDNUJKLGFBQWFPLFFBQVEsQ0FBQ0UsS0FBSztJQUUzQlosUUFBUWEsR0FBRyxDQUFDO0FBQ2Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLHdCQUNkQyxXQUFtQixFQUNuQkMsWUFBd0I7SUFFeEIsTUFBTUMsZ0JBQWdCLENBQUNDO1FBQ3JCLHVEQUF1RDtRQUN2RCxJQUFJQSxNQUFNQyxNQUFNLEtBQUtKLGFBQWE7UUFFbEMsTUFBTSxFQUFFSyxJQUFJLEVBQUUsR0FBR0YsTUFBTS9CLElBQUk7UUFFM0IsSUFBSWlDLFNBQVMsZUFBZTtZQUMxQnBCLFFBQVFhLEdBQUcsQ0FBQztZQUNaRztRQUNGO0lBQ0Y7SUFFQXZCLE9BQU80QixnQkFBZ0IsQ0FBQyxXQUFXSjtJQUVuQyw4QkFBOEI7SUFDOUIsT0FBTztRQUNMeEIsT0FBTzZCLG1CQUFtQixDQUFDLFdBQVdMO0lBQ3hDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNNLG9CQUNkUixXQUFtQixFQUNuQlMsUUFBYTtJQUViLElBQUlULGVBQWUsQ0FBQ0EsWUFBWVUsTUFBTSxFQUFFO1FBQ3RDVixZQUFZVyxXQUFXLENBQ3JCO1lBQ0VOLE1BQU07WUFDTmpDLE1BQU1xQztRQUNSLEdBQ0EvQixPQUFPYSxRQUFRLENBQUNELE1BQU07SUFFMUI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU3NCLGlCQUNkWixXQUFtQixFQUNuQmEsS0FBVTtJQUVWLElBQUliLGVBQWUsQ0FBQ0EsWUFBWVUsTUFBTSxFQUFFO1FBQ3RDVixZQUFZVyxXQUFXLENBQ3JCO1lBQ0VOLE1BQU07WUFDTmpDLE1BQU15QztRQUNSLEdBQ0FuQyxPQUFPYSxRQUFRLENBQUNELE1BQU07SUFFMUI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU3dCLHFCQUNkZCxXQUFtQixFQUNuQmUsU0FBYztJQUVkLElBQUlmLGVBQWUsQ0FBQ0EsWUFBWVUsTUFBTSxFQUFFO1FBQ3RDVixZQUFZVyxXQUFXLENBQ3JCO1lBQ0VOLE1BQU07WUFDTmpDLE1BQU0yQztRQUNSLEdBQ0FyQyxPQUFPYSxRQUFRLENBQUNELE1BQU07SUFFMUI7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzBCLDRCQUNkaEIsV0FBbUIsRUFDbkJpQixXQUFvQjtJQUVwQixJQUFJakIsZUFBZSxDQUFDQSxZQUFZVSxNQUFNLEVBQUU7UUFDdENWLFlBQVlXLFdBQVcsQ0FDckI7WUFDRU4sTUFBTTtZQUNOakMsTUFBTTtnQkFBRTZDO1lBQVk7UUFDdEIsR0FDQXZDLE9BQU9hLFFBQVEsQ0FBQ0QsTUFBTTtJQUUxQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi93aW5kb3ctaW5qZWN0b3IudHM/NjVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNpc3RlbWEgZGUgVmVudGFuYXMgY29uIGFib3V0OmJsYW5rICsgSW55ZWNjacOzbiBEaW7DoW1pY2FcbiAqIEluc3BpcmFkbyBlbiBHb2RlbCBUZXJtaW5hbFxuICogXG4gKiBWZW50YWphczpcbiAqIC0gTm8gZGlzcGFyYSBibG9xdWVhZG9yZXMgZGUgcG9wLXVwc1xuICogLSBNYW50aWVuZSBXZWJTb2NrZXQgYWN0aXZvIHZpYSBTaGFyZWRXb3JrZXJcbiAqIC0gSW55ZWN0YSBjb250ZW5pZG8gZGluw6FtaWNhbWVudGUgc2luIGZ1bGwgcGFnZSByZWxvYWRcbiAqIC0gQ29tdW5pY2FjacOzbiBiaWRpcmVjY2lvbmFsIHZpYSBwb3N0TWVzc2FnZVxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgV2luZG93SW5qZWN0b3JDb25maWcge1xuICB0aXRsZTogc3RyaW5nO1xuICB3aWR0aD86IG51bWJlcjtcbiAgaGVpZ2h0PzogbnVtYmVyO1xuICBjZW50ZXJlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2luZG93RGF0YSB7XG4gIGxpc3ROYW1lOiBzdHJpbmc7XG4gIGNhdGVnb3J5TmFtZTogc3RyaW5nO1xuICB3c1VybDogc3RyaW5nO1xuICBhcGlVcmw6IHN0cmluZztcbiAgLy8gUGFyYSBoZXJlZGFyIGxhIHNlc2nDs24vYXV0aCBzaSBlcyBuZWNlc2FyaW9cbiAgYXV0aFRva2VuPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEFicmUgdW5hIHZlbnRhbmEgYWJvdXQ6YmxhbmsgZSBpbnllY3RhIGVsIGNvbnRlbmlkbyBkaW7DoW1pY2FtZW50ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3BlbkluamVjdGVkV2luZG93KFxuICBkYXRhOiBXaW5kb3dEYXRhLFxuICBjb25maWc6IFdpbmRvd0luamVjdG9yQ29uZmlnXG4pOiBXaW5kb3cgfCBudWxsIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoID0gMTIwMCxcbiAgICBoZWlnaHQgPSA4MDAsXG4gICAgY2VudGVyZWQgPSB0cnVlLFxuICB9ID0gY29uZmlnO1xuXG4gIC8vIENhbGN1bGFyIHBvc2ljacOzbiBjZW50cmFkYVxuICBjb25zdCBsZWZ0ID0gY2VudGVyZWQgXG4gICAgPyAod2luZG93LnNjcmVlbi53aWR0aCAtIHdpZHRoKSAvIDIgXG4gICAgOiAxMDA7XG4gIGNvbnN0IHRvcCA9IGNlbnRlcmVkIFxuICAgID8gKHdpbmRvdy5zY3JlZW4uaGVpZ2h0IC0gaGVpZ2h0KSAvIDIgXG4gICAgOiAxMDA7XG5cbiAgY29uc3Qgd2luZG93RmVhdHVyZXMgPSBbXG4gICAgYHdpZHRoPSR7d2lkdGh9YCxcbiAgICBgaGVpZ2h0PSR7aGVpZ2h0fWAsXG4gICAgYGxlZnQ9JHtsZWZ0fWAsXG4gICAgYHRvcD0ke3RvcH1gLFxuICAgICdyZXNpemFibGU9eWVzJyxcbiAgICAnc2Nyb2xsYmFycz15ZXMnLFxuICAgICdzdGF0dXM9eWVzJyxcbiAgXS5qb2luKCcsJyk7XG5cbiAgLy8gMS4gQWJyaXIgYWJvdXQ6YmxhbmsgKG5vIGRpc3BhcmEgYmxvcXVlYWRvcilcbiAgY29uc3QgbmV3V2luZG93ID0gd2luZG93Lm9wZW4oJ2Fib3V0OmJsYW5rJywgJ19ibGFuaycsIHdpbmRvd0ZlYXR1cmVzKTtcblxuICBpZiAoIW5ld1dpbmRvdykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGYWlsZWQgdG8gb3BlbiB3aW5kb3cgKHBvcHVwIGJsb2NrZWQ/KScpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gMi4gSW55ZWN0YXIgY29udGVuaWRvIGlubWVkaWF0YW1lbnRlXG4gIGluamVjdENvbnRlbnQobmV3V2luZG93LCBkYXRhLCBjb25maWcpO1xuXG4gIHJldHVybiBuZXdXaW5kb3c7XG59XG5cbi8qKlxuICogSW55ZWN0YSBlbCBIVE1MIGNvbXBsZXRvIGVuIGxhIHZlbnRhbmEgYWJvdXQ6YmxhbmtcbiAqL1xuZnVuY3Rpb24gaW5qZWN0Q29udGVudChcbiAgdGFyZ2V0V2luZG93OiBXaW5kb3csXG4gIGRhdGE6IFdpbmRvd0RhdGEsXG4gIGNvbmZpZzogV2luZG93SW5qZWN0b3JDb25maWdcbik6IHZvaWQge1xuICBjb25zdCB7IHRpdGxlIH0gPSBjb25maWc7XG4gIGNvbnN0IG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgLy8gSFRNTCB0ZW1wbGF0ZSBMSUdFUk8gc2luIGRlcGVuZGVuY2lhcyBDRE5cbiAgY29uc3QgaHRtbENvbnRlbnQgPSBgXG48IURPQ1RZUEUgaHRtbD5cbjxodG1sIGxhbmc9XCJlc1wiPlxuPGhlYWQ+XG4gIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPlxuICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMFwiPlxuICA8dGl0bGU+JHt0aXRsZX0gLSBUcmFkZXVsPC90aXRsZT5cbiAgXG4gIDxzdHlsZT5cbiAgICAvKiBSZXNldCB5IGVzdGlsb3MgYmFzZSAqL1xuICAgICogeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IH1cbiAgICBcbiAgICBib2R5IHtcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIHBhZGRpbmc6IDA7XG4gICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCAnUm9ib3RvJywgc2Fucy1zZXJpZjtcbiAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjtcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgfVxuICAgIFxuICAgIC8qIEFuaW1hY2nDs24gZGUgbG9hZGluZyAqL1xuICAgIEBrZXlmcmFtZXMgcHVsc2Uge1xuICAgICAgMCUsIDEwMCUgeyBvcGFjaXR5OiAxOyB9XG4gICAgICA1MCUgeyBvcGFjaXR5OiAwLjU7IH1cbiAgICB9XG4gICAgXG4gICAgQGtleWZyYW1lcyBzcGluIHtcbiAgICAgIHRvIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfVxuICAgIH1cbiAgICBcbiAgICAubG9hZGluZy1zcGlubmVyIHtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgYm9yZGVyOiA0cHggc29saWQgI2UyZThmMDtcbiAgICAgIGJvcmRlci10b3AtY29sb3I6ICMzYjgyZjY7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xuICAgIH1cbiAgICBcbiAgICAvKiBMYXlvdXQgcHJpbmNpcGFsICovXG4gICAgLmFwcC1jb250YWluZXIge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgIH1cbiAgICBcbiAgICAvKiBIZWFkZXIgZGUgbGEgdGFibGEgKi9cbiAgICAudGFibGUtaGVhZGVyIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzNiODJmNjtcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIH1cbiAgICBcbiAgICAuaGVhZGVyLWxlZnQge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBnYXA6IDE2cHg7XG4gICAgfVxuICAgIFxuICAgIC5oZWFkZXItdGl0bGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBnYXA6IDhweDtcbiAgICB9XG4gICAgXG4gICAgLnRpdGxlLWluZGljYXRvciB7XG4gICAgICB3aWR0aDogNHB4O1xuICAgICAgaGVpZ2h0OiAyNHB4O1xuICAgICAgYmFja2dyb3VuZDogIzNiODJmNjtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICB9XG4gICAgXG4gICAgLnRpdGxlLXRleHQge1xuICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICAgIGNvbG9yOiAjMGYxNzJhO1xuICAgIH1cbiAgICBcbiAgICAuc3RhdHVzLWJhZGdlIHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZ2FwOiA2cHg7XG4gICAgfVxuICAgIFxuICAgIC5zdGF0dXMtZG90IHtcbiAgICAgIHdpZHRoOiA4cHg7XG4gICAgICBoZWlnaHQ6IDhweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIGJhY2tncm91bmQ6ICM5NGEzYjg7XG4gICAgfVxuICAgIFxuICAgIC5zdGF0dXMtZG90LmxpdmUge1xuICAgICAgYmFja2dyb3VuZDogIzEwYjk4MTtcbiAgICAgIGFuaW1hdGlvbjogcHVsc2UgMnMgZWFzZS1pbi1vdXQgaW5maW5pdGU7XG4gICAgfVxuICAgIFxuICAgIC5zdGF0dXMtdGV4dCB7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgY29sb3I6ICM2NDc0OGI7XG4gICAgfVxuICAgIFxuICAgIC5zdGF0dXMtdGV4dC5saXZlIHtcbiAgICAgIGNvbG9yOiAjMTBiOTgxO1xuICAgIH1cbiAgICBcbiAgICAuY291bnQtYmFkZ2Uge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBnYXA6IDZweDtcbiAgICAgIHBhZGRpbmc6IDRweCAxMnB4O1xuICAgICAgYmFja2dyb3VuZDogI2VmZjZmZjtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNiZmRiZmU7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgfVxuICAgIFxuICAgIC5jb3VudC1udW1iZXIge1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgIGNvbG9yOiAjMjU2M2ViO1xuICAgIH1cbiAgICBcbiAgICAuY291bnQtbGFiZWwge1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgY29sb3I6ICM2NDc0OGI7XG4gICAgfVxuICAgIFxuICAgIC5oZWFkZXItcmlnaHQge1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgY29sb3I6ICM2NDc0OGI7XG4gICAgfVxuICAgIFxuICAgIC50aW1lc3RhbXAge1xuICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICBjb2xvcjogIzBmMTcyYTtcbiAgICB9XG4gICAgXG4gICAgLyogVGFibGEgKi9cbiAgICAudGFibGUtY29udGFpbmVyIHtcbiAgICAgIGZsZXg6IDE7XG4gICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgIH1cbiAgICBcbiAgICB0YWJsZSB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gICAgfVxuICAgIFxuICAgIHRoZWFkIHtcbiAgICAgIHBvc2l0aW9uOiBzdGlja3k7XG4gICAgICB0b3A6IDA7XG4gICAgICBiYWNrZ3JvdW5kOiAjZjhmYWZjO1xuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlMmU4ZjA7XG4gICAgICB6LWluZGV4OiAxMDtcbiAgICB9XG4gICAgXG4gICAgdGgge1xuICAgICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgICAgdGV4dC1hbGlnbjogbGVmdDtcbiAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgICBjb2xvcjogIzQ3NTU2OTtcbiAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICBsZXR0ZXItc3BhY2luZzogMC4wNWVtO1xuICAgIH1cbiAgICBcbiAgICB0aC50ZXh0LXJpZ2h0IHsgdGV4dC1hbGlnbjogcmlnaHQ7IH1cbiAgICBcbiAgICB0Ym9keSB0ciB7XG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2YxZjVmOTtcbiAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4xNXM7XG4gICAgfVxuICAgIFxuICAgIHRib2R5IHRyOmhvdmVyIHtcbiAgICAgIGJhY2tncm91bmQ6ICNmOGZhZmM7XG4gICAgfVxuICAgIFxuICAgIHRkIHtcbiAgICAgIHBhZGRpbmc6IDEycHggMTZweDtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICB9XG4gICAgXG4gICAgdGQudGV4dC1yaWdodCB7IHRleHQtYWxpZ246IHJpZ2h0OyB9XG4gICAgXG4gICAgLnJhbmstY2VsbCB7XG4gICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgY29sb3I6ICM5NGEzYjg7XG4gICAgfVxuICAgIFxuICAgIC5zeW1ib2wtY2VsbCB7XG4gICAgICBmb250LXdlaWdodDogNzAwO1xuICAgICAgY29sb3I6ICMyNTYzZWI7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuICAgIFxuICAgIC5zeW1ib2wtY2VsbDpob3ZlciB7XG4gICAgICBjb2xvcjogIzFkNGVkODtcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIH1cbiAgICBcbiAgICAucHJpY2UtY2VsbCB7XG4gICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgIGNvbG9yOiAjMGYxNzJhO1xuICAgIH1cbiAgICBcbiAgICAuY2hhbmdlLWNlbGwge1xuICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcbiAgICAgIHBhZGRpbmc6IDRweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBmb250LXdlaWdodDogNzAwO1xuICAgIH1cbiAgICBcbiAgICAuY2hhbmdlLWNlbGwucG9zaXRpdmUge1xuICAgICAgYmFja2dyb3VuZDogI2RjZmNlNztcbiAgICAgIGNvbG9yOiAjMTZhMzRhO1xuICAgIH1cbiAgICBcbiAgICAuY2hhbmdlLWNlbGwubmVnYXRpdmUge1xuICAgICAgYmFja2dyb3VuZDogI2ZlZTJlMjtcbiAgICAgIGNvbG9yOiAjZGMyNjI2O1xuICAgIH1cbiAgICBcbiAgICAubW9ubyB7XG4gICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgIH1cbiAgICBcbiAgICAvKiBFc3RhZG8gdmFjw61vIC8gbG9hZGluZyAqL1xuICAgIC5lbXB0eS1zdGF0ZSB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGhlaWdodDogY2FsYygxMDB2aCAtIDYwcHgpO1xuICAgICAgY29sb3I6ICM2NDc0OGI7XG4gICAgfVxuICAgIFxuICAgIC5lbXB0eS1pY29uIHtcbiAgICAgIGZvbnQtc2l6ZTogNjRweDtcbiAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgICBvcGFjaXR5OiAwLjU7XG4gICAgfVxuICAgIFxuICAgIC5lbXB0eS10aXRsZSB7XG4gICAgICBmb250LXNpemU6IDIwcHg7XG4gICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgY29sb3I6ICMwZjE3MmE7XG4gICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgfVxuICAgIFxuICAgIC5lbXB0eS1tZXNzYWdlIHtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGNvbG9yOiAjNjQ3NDhiO1xuICAgIH1cbiAgPC9zdHlsZT5cbjwvaGVhZD5cbjxib2R5PlxuICA8ZGl2IGlkPVwicm9vdFwiIGNsYXNzPVwiYXBwLWNvbnRhaW5lclwiPlxuICAgIDwhLS0gUGFudGFsbGEgZGUgY2FyZ2EgaW5pY2lhbCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZW1wdHktc3RhdGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJsb2FkaW5nLXNwaW5uZXJcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJlbXB0eS10aXRsZVwiIHN0eWxlPVwibWFyZ2luLXRvcDogMTZweDtcIj5DYXJnYW5kbyAke3RpdGxlfS4uLjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImVtcHR5LW1lc3NhZ2VcIj5Db25lY3RhbmRvIGFsIHNlcnZpZG9yLi4uPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxzY3JpcHQ+XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIENPTkZJR1VSQUNJw5NOIElOSUNJQUxcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgY29uc3QgQ09ORklHID0gJHtKU09OLnN0cmluZ2lmeShkYXRhKX07XG4gICAgY29uc3QgUEFSRU5UX09SSUdJTiA9ICcke29yaWdpbn0nO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn5qAIFtJbmplY3RlZFdpbmRvd10gSW5pdGlhbGl6aW5nLi4uJywgQ09ORklHKTtcbiAgICBcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQ09NVU5JQ0FDScOTTiBDT04gVkVOVEFOQSBQQURSRVxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBcbiAgICAvLyBFbnZpYXIgbWVuc2FqZSBhbCBwYWRyZSBzb2xpY2l0YW5kbyBkYXRvcyBpbmljaWFsZXNcbiAgICBmdW5jdGlvbiByZXF1ZXN0SW5pdGlhbERhdGEoKSB7XG4gICAgICBpZiAod2luZG93Lm9wZW5lciAmJiAhd2luZG93Lm9wZW5lci5jbG9zZWQpIHtcbiAgICAgICAgd2luZG93Lm9wZW5lci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogJ2NoaWxkX3JlYWR5JyxcbiAgICAgICAgICBsaXN0TmFtZTogQ09ORklHLmxpc3ROYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0sIFBBUkVOVF9PUklHSU4pO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6QgW0luamVjdGVkV2luZG93XSBSZXF1ZXN0ZWQgaW5pdGlhbCBkYXRhIGZyb20gcGFyZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFJlY2liaXIgbWVuc2FqZXMgZGVsIHBhZHJlXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIFZhbGlkYXIgb3JpZ2VuIHBvciBzZWd1cmlkYWRcbiAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IFBBUkVOVF9PUklHSU4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gW0luamVjdGVkV2luZG93XSBSZWplY3RlZCBtZXNzYWdlIGZyb20gdW5rbm93biBvcmlnaW46JywgZXZlbnQub3JpZ2luKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IGV2ZW50LmRhdGE7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OlIFtJbmplY3RlZFdpbmRvd10gTWVzc2FnZSByZWNlaXZlZDonLCB0eXBlLCBkYXRhKTtcbiAgICAgIFxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NuYXBzaG90X2RhdGEnOlxuICAgICAgICAgIGhhbmRsZVNuYXBzaG90RGF0YShkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVsdGFfdXBkYXRlJzpcbiAgICAgICAgICBoYW5kbGVEZWx0YVVwZGF0ZShkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWdncmVnYXRlX3VwZGF0ZSc6XG4gICAgICAgICAgaGFuZGxlQWdncmVnYXRlVXBkYXRlKGRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb25uZWN0aW9uX3N0YXR1cyc6XG4gICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXR1cyhkYXRhLmlzQ29ubmVjdGVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gV0VCU09DS0VUIENPTk5FQ1RJT04gKHZpYSBTaGFyZWRXb3JrZXIpXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIFxuICAgIGxldCBzaGFyZWRXb3JrZXIgPSBudWxsO1xuICAgIGxldCB3b3JrZXJQb3J0ID0gbnVsbDtcbiAgICBsZXQgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBsZXQgdGlja2Vyc0RhdGEgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHRpY2tlck9yZGVyID0gW107XG4gICAgXG4gICAgZnVuY3Rpb24gaW5pdFdlYlNvY2tldCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENvbmVjdGFyIGFsIFNoYXJlZFdvcmtlciBleGlzdGVudGVcbiAgICAgICAgc2hhcmVkV29ya2VyID0gbmV3IFNoYXJlZFdvcmtlcignL3dvcmtlcnMvd2Vic29ja2V0LXNoYXJlZC5qcycsIHtcbiAgICAgICAgICBuYW1lOiAndHJhZGV1bC13ZWJzb2NrZXQnXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgd29ya2VyUG9ydCA9IHNoYXJlZFdvcmtlci5wb3J0O1xuICAgICAgICBcbiAgICAgICAgd29ya2VyUG9ydC5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBldmVudC5kYXRhO1xuICAgICAgICAgIFxuICAgICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICAgICAgICBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdGF0dXMnOlxuICAgICAgICAgICAgICBpc0Nvbm5lY3RlZCA9IG1zZy5pc0Nvbm5lY3RlZDtcbiAgICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvblN0YXR1cyhtc2cuaXNDb25uZWN0ZWQpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXGDwn5OKIFtJbmplY3RlZFdpbmRvd10gV1MgU3RhdHVzOiBcXCR7bXNnLmlzQ29ubmVjdGVkID8gJ2Nvbm5lY3RlZCcgOiAnZGlzY29ubmVjdGVkJ31cXGApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcYPCfk50gW1NoYXJlZFdvcmtlcl0gXFwke21zZy5tZXNzYWdlfVxcYCwgbXNnLmRhdGEgfHwgJycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB3b3JrZXJQb3J0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgW0luamVjdGVkV2luZG93XSBTaGFyZWRXb3JrZXIgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgd29ya2VyUG9ydC5zdGFydCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29uZWN0YXIgYWwgV2ViU29ja2V0IChzaSBubyBlc3TDoSB5YSBjb25lY3RhZG8pXG4gICAgICAgIHdvcmtlclBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIGFjdGlvbjogJ2Nvbm5lY3QnLFxuICAgICAgICAgIHVybDogQ09ORklHLndzVXJsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU3VzY3JpYmlyc2UgYSBsYSBsaXN0YVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB3b3JrZXJQb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3N1YnNjcmliZV9saXN0JyxcbiAgICAgICAgICAgIGxpc3Q6IENPTkZJRy5saXN0TmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFxcYOKchSBbSW5qZWN0ZWRXaW5kb3ddIFN1YnNjcmliZWQgdG8gbGlzdDogXFwke0NPTkZJRy5saXN0TmFtZX1cXGApO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgW0luamVjdGVkV2luZG93XSBGYWlsZWQgdG8gaW5pdCBXZWJTb2NrZXQ6JywgZXJyb3IpO1xuICAgICAgICAvLyBGYWxsYmFjazogc29saWNpdGFyIGRhdG9zIGFsIHBhZHJlXG4gICAgICAgIHJlcXVlc3RJbml0aWFsRGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBoYW5kbGVXZWJTb2NrZXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NuYXBzaG90JzpcbiAgICAgICAgICBpZiAobWVzc2FnZS5saXN0ID09PSBDT05GSUcubGlzdE5hbWUpIHtcbiAgICAgICAgICAgIGhhbmRsZVNuYXBzaG90RGF0YShtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlbHRhJzpcbiAgICAgICAgICBpZiAobWVzc2FnZS5saXN0ID09PSBDT05GSUcubGlzdE5hbWUpIHtcbiAgICAgICAgICAgIGhhbmRsZURlbHRhVXBkYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWdncmVnYXRlJzpcbiAgICAgICAgICBoYW5kbGVBZ2dyZWdhdGVVcGRhdGUobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBNQU5FSk8gREUgREFUT1NcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgZnVuY3Rpb24gaGFuZGxlU25hcHNob3REYXRhKHNuYXBzaG90KSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TuCBbSW5qZWN0ZWRXaW5kb3ddIFNuYXBzaG90IHJlY2VpdmVkOicsIHNuYXBzaG90LmRhdGE/Lmxlbmd0aCB8fCAwLCAndGlja2VycycpO1xuICAgICAgXG4gICAgICBpZiAoIXNuYXBzaG90LmRhdGEpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gTGltcGlhciBkYXRvcyBhbnRlcmlvcmVzXG4gICAgICB0aWNrZXJzRGF0YS5jbGVhcigpO1xuICAgICAgdGlja2VyT3JkZXIgPSBbXTtcbiAgICAgIFxuICAgICAgLy8gQ2FyZ2FyIHNuYXBzaG90XG4gICAgICBzbmFwc2hvdC5kYXRhLmZvckVhY2goKHRpY2tlciwgaW5kZXgpID0+IHtcbiAgICAgICAgdGlja2Vyc0RhdGEuc2V0KHRpY2tlci5zeW1ib2wsIHRpY2tlcik7XG4gICAgICAgIHRpY2tlck9yZGVyLnB1c2godGlja2VyLnN5bWJvbCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmVuZGVyVGFibGUoKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaGFuZGxlRGVsdGFVcGRhdGUoZGVsdGEpIHtcbiAgICAgIGlmICghZGVsdGEuYWN0aW9ucykgcmV0dXJuO1xuICAgICAgXG4gICAgICBkZWx0YS5hY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24uYWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZGF0YSkge1xuICAgICAgICAgICAgICB0aWNrZXJzRGF0YS5zZXQoYWN0aW9uLnN5bWJvbCwgYWN0aW9uLmRhdGEpO1xuICAgICAgICAgICAgICBpZiAoIXRpY2tlck9yZGVyLmluY2x1ZGVzKGFjdGlvbi5zeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0YXIgZW4gbGEgcG9zaWNpw7NuIGNvcnJlY3RhXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuayA9IGFjdGlvbi5yYW5rID8/IHRpY2tlck9yZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aWNrZXJPcmRlci5zcGxpY2UocmFuaywgMCwgYWN0aW9uLnN5bWJvbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgIHRpY2tlcnNEYXRhLmRlbGV0ZShhY3Rpb24uc3ltYm9sKTtcbiAgICAgICAgICAgIHRpY2tlck9yZGVyID0gdGlja2VyT3JkZXIuZmlsdGVyKHMgPT4gcyAhPT0gYWN0aW9uLnN5bWJvbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmRhdGEpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aWNrZXJzRGF0YS5nZXQoYWN0aW9uLnN5bWJvbCk7XG4gICAgICAgICAgICAgIHRpY2tlcnNEYXRhLnNldChhY3Rpb24uc3ltYm9sLCB7IC4uLmV4aXN0aW5nLCAuLi5hY3Rpb24uZGF0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY2FzZSAncmVyYW5rJzpcbiAgICAgICAgICAgIGlmIChhY3Rpb24ub2xkX3JhbmsgIT09IHVuZGVmaW5lZCAmJiBhY3Rpb24ubmV3X3JhbmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBhY3Rpb24uc3ltYm9sO1xuICAgICAgICAgICAgICB0aWNrZXJPcmRlciA9IHRpY2tlck9yZGVyLmZpbHRlcihzID0+IHMgIT09IHN5bWJvbCk7XG4gICAgICAgICAgICAgIHRpY2tlck9yZGVyLnNwbGljZShhY3Rpb24ubmV3X3JhbmssIDAsIHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJlbmRlclRhYmxlKCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZUFnZ3JlZ2F0ZVVwZGF0ZShhZ2dyZWdhdGUpIHtcbiAgICAgIGlmICghYWdncmVnYXRlLnN5bWJvbCB8fCAhYWdncmVnYXRlLmRhdGEpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgdGlja2VyID0gdGlja2Vyc0RhdGEuZ2V0KGFnZ3JlZ2F0ZS5zeW1ib2wpO1xuICAgICAgaWYgKHRpY2tlcikge1xuICAgICAgICAvLyBBY3R1YWxpemFyIHByZWNpby92b2x1bWVuIGVuIHRpZW1wbyByZWFsXG4gICAgICAgIHRpY2tlcnNEYXRhLnNldChhZ2dyZWdhdGUuc3ltYm9sLCB7XG4gICAgICAgICAgLi4udGlja2VyLFxuICAgICAgICAgIHByaWNlOiBhZ2dyZWdhdGUuZGF0YS5jbG9zZSA/PyB0aWNrZXIucHJpY2UsXG4gICAgICAgICAgdm9sdW1lOiBhZ2dyZWdhdGUuZGF0YS52b2x1bWUgPz8gdGlja2VyLnZvbHVtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBY3R1YWxpemFyIHNvbG8gbGEgZmlsYSBlc3BlY8OtZmljYSAobcOhcyBlZmljaWVudGUpXG4gICAgICAgIHVwZGF0ZVRpY2tlclJvdyhhZ2dyZWdhdGUuc3ltYm9sKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvblN0YXR1cyhjb25uZWN0ZWQpIHtcbiAgICAgIGNvbnN0IHN0YXR1c0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nvbm5lY3Rpb24tc3RhdHVzJyk7XG4gICAgICBpZiAoc3RhdHVzRWwpIHtcbiAgICAgICAgc3RhdHVzRWwuY2xhc3NOYW1lID0gXFxgdy0yIGgtMiByb3VuZGVkLWZ1bGwgXFwke2Nvbm5lY3RlZCA/ICdiZy1ncmVlbi01MDAnIDogJ2JnLXJlZC01MDAnfVxcYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25uZWN0aW9uLXRleHQnKTtcbiAgICAgIGlmIChzdGF0dXNUZXh0KSB7XG4gICAgICAgIHN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBjb25uZWN0ZWQgPyAnTGl2ZScgOiAnT2ZmbGluZSc7XG4gICAgICAgIHN0YXR1c1RleHQuY2xhc3NOYW1lID0gXFxgdGV4dC14cyBmb250LW1lZGl1bSBcXCR7Y29ubmVjdGVkID8gJ3RleHQtZ3JlZW4tNjAwJyA6ICd0ZXh0LXJlZC02MDAnfVxcYDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFJFTkRFUklaQURPIERFIExBIFRBQkxBXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIFxuICAgIGZ1bmN0aW9uIHJlbmRlclRhYmxlKCkge1xuICAgICAgY29uc3QgdGlja2VycyA9IHRpY2tlck9yZGVyLm1hcChzeW1ib2wgPT4gdGlja2Vyc0RhdGEuZ2V0KHN5bWJvbCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIFxuICAgICAgLy8gU2kgbm8gaGF5IGRhdG9zLCBtb3N0cmFyIGVzdGFkbyB2YWPDrW9cbiAgICAgIGlmICh0aWNrZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBodG1sID0gXFxgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImFwcC1jb250YWluZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJsZS1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci10aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlLWluZGljYXRvclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzPVwidGl0bGUtdGV4dFwiPlxcJHtDT05GSUcuY2F0ZWdvcnlOYW1lfTwvaDE+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN0YXR1cy1iYWRnZVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBpZD1cImNvbm5lY3Rpb24tc3RhdHVzXCIgY2xhc3M9XCJzdGF0dXMtZG90XCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cImNvbm5lY3Rpb24tdGV4dFwiIGNsYXNzPVwic3RhdHVzLXRleHRcIj5Db25lY3RhbmRvLi4uPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb3VudC1iYWRnZVwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb3VudC1udW1iZXJcIj4wPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb3VudC1sYWJlbFwiPnRpY2tlcnM8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgQWN0dWFsaXphZG86IDxzcGFuIGlkPVwibGFzdC11cGRhdGVcIiBjbGFzcz1cInRpbWVzdGFtcFwiPlxcJHtuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlbXB0eS1zdGF0ZVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZW1wdHktaWNvblwiPvCfk4o8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImVtcHR5LXRpdGxlXCI+Tm8gaGF5IGRhdG9zIGRpc3BvbmlibGVzPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlbXB0eS1tZXNzYWdlXCI+RXNwZXJhbmRvIGFjdHVhbGl6YWNpb25lcyBkZWwgbWVyY2Fkby4uLjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIFxcYDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIHJvb3QuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGh0bWwgPSBcXGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImFwcC1jb250YWluZXJcIj5cbiAgICAgICAgICA8IS0tIEhlYWRlciAtLT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtaGVhZGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyLWxlZnRcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci10aXRsZVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZS1pbmRpY2F0b3JcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJ0aXRsZS10ZXh0XCI+XFwke0NPTkZJRy5jYXRlZ29yeU5hbWV9PC9oMT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdGF0dXMtYmFkZ2VcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiY29ubmVjdGlvbi1zdGF0dXNcIiBjbGFzcz1cInN0YXR1cy1kb3RcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICA8c3BhbiBpZD1cImNvbm5lY3Rpb24tdGV4dFwiIGNsYXNzPVwic3RhdHVzLXRleHRcIj5Db25lY3RhbmRvLi4uPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvdW50LWJhZGdlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb3VudC1udW1iZXJcIj5cXCR7dGlja2Vycy5sZW5ndGh9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY291bnQtbGFiZWxcIj50aWNrZXJzPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci1yaWdodFwiPlxuICAgICAgICAgICAgICBBY3R1YWxpemFkbzogPHNwYW4gaWQ9XCJsYXN0LXVwZGF0ZVwiIGNsYXNzPVwidGltZXN0YW1wXCI+XFwke25ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCl9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgXG4gICAgICAgICAgPCEtLSBUYWJsZSAtLT5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFibGUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICA8dGg+IzwvdGg+XG4gICAgICAgICAgICAgICAgICA8dGg+U3ltYm9sPC90aD5cbiAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtcmlnaHRcIj5QcmljZTwvdGg+XG4gICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+Q2hhbmdlPC90aD5cbiAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtcmlnaHRcIj4lIENoYW5nZTwvdGg+XG4gICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJ0ZXh0LXJpZ2h0XCI+Vm9sdW1lPC90aD5cbiAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtcmlnaHRcIj5SVk9MPC90aD5cbiAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cInRleHQtcmlnaHRcIj5HYXAgJTwvdGg+XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgIFxcJHt0aWNrZXJzLm1hcCgodGlja2VyLCBpbmRleCkgPT4gcmVuZGVyVGlja2VyUm93KHRpY2tlciwgaW5kZXggKyAxKSkuam9pbignJyl9XG4gICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIFxcYDtcbiAgICAgIFxuICAgICAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICByb290LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFjdHVhbGl6YXIgdGltZXN0YW1wXG4gICAgICB1cGRhdGVUaW1lc3RhbXAoKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcmVuZGVyVGlja2VyUm93KHRpY2tlciwgcmFuaykge1xuICAgICAgY29uc3QgaXNQb3NpdGl2ZSA9ICh0aWNrZXIuY2hhbmdlX3BlcmNlbnQgPz8gMCkgPj0gMDtcbiAgICAgIGNvbnN0IGNoYW5nZUNsYXNzID0gaXNQb3NpdGl2ZSA/ICdwb3NpdGl2ZScgOiAnbmVnYXRpdmUnO1xuICAgICAgXG4gICAgICByZXR1cm4gXFxgXG4gICAgICAgIDx0ciBpZD1cInRpY2tlci1yb3ctXFwke3RpY2tlci5zeW1ib2x9XCI+XG4gICAgICAgICAgPHRkIGNsYXNzPVwicmFuay1jZWxsXCI+XFwke3Jhbmt9PC90ZD5cbiAgICAgICAgICA8dGQgY2xhc3M9XCJzeW1ib2wtY2VsbFwiPlxcJHt0aWNrZXIuc3ltYm9sfTwvdGQ+XG4gICAgICAgICAgPHRkIGNsYXNzPVwidGV4dC1yaWdodCBwcmljZS1jZWxsXCI+XFwke2Zvcm1hdFByaWNlKHRpY2tlci5wcmljZSl9PC90ZD5cbiAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LXJpZ2h0IG1vbm9cIiBzdHlsZT1cImNvbG9yOiBcXCR7aXNQb3NpdGl2ZSA/ICcjMTZhMzRhJyA6ICcjZGMyNjI2J31cIj5cXCR7Zm9ybWF0Q2hhbmdlKHRpY2tlci5jaGFuZ2UpfTwvdGQ+XG4gICAgICAgICAgPHRkIGNsYXNzPVwidGV4dC1yaWdodFwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGFuZ2UtY2VsbCBcXCR7Y2hhbmdlQ2xhc3N9XCI+XFwke2Zvcm1hdFBlcmNlbnQodGlja2VyLmNoYW5nZV9wZXJjZW50KX08L3NwYW4+XG4gICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LXJpZ2h0IG1vbm9cIj5cXCR7Zm9ybWF0Vm9sdW1lKHRpY2tlci52b2x1bWUpfTwvdGQ+XG4gICAgICAgICAgPHRkIGNsYXNzPVwidGV4dC1yaWdodCBtb25vXCIgc3R5bGU9XCJjb2xvcjogIzdjM2FlZDsgZm9udC13ZWlnaHQ6IDYwMDtcIj5cXCR7Zm9ybWF0UlZPTCh0aWNrZXIucnZvbCl9PC90ZD5cbiAgICAgICAgICA8dGQgY2xhc3M9XCJ0ZXh0LXJpZ2h0IG1vbm9cIiBzdHlsZT1cImNvbG9yOiBcXCR7aXNQb3NpdGl2ZSA/ICcjMTZhMzRhJyA6ICcjZGMyNjI2J31cIj5cXCR7Zm9ybWF0UGVyY2VudCh0aWNrZXIuZ2FwX3BlcmNlbnQpfTwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgICBcXGA7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRpY2tlclJvdyhzeW1ib2wpIHtcbiAgICAgIGNvbnN0IHRpY2tlciA9IHRpY2tlcnNEYXRhLmdldChzeW1ib2wpO1xuICAgICAgaWYgKCF0aWNrZXIpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgcmFuayA9IHRpY2tlck9yZGVyLmluZGV4T2Yoc3ltYm9sKSArIDE7XG4gICAgICBjb25zdCByb3dFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxcYHRpY2tlci1yb3ctXFwke3N5bWJvbH1cXGApO1xuICAgICAgXG4gICAgICBpZiAocm93RWwpIHtcbiAgICAgICAgcm93RWwub3V0ZXJIVE1MID0gcmVuZGVyVGlja2VyUm93KHRpY2tlciwgcmFuayk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHVwZGF0ZVRpbWVzdGFtcCgpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiB1cGRhdGVUaW1lc3RhbXAoKSB7XG4gICAgICBjb25zdCB0aW1lc3RhbXBFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXN0LXVwZGF0ZScpO1xuICAgICAgaWYgKHRpbWVzdGFtcEVsKSB7XG4gICAgICAgIHRpbWVzdGFtcEVsLnRleHRDb250ZW50ID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEZPUk1BVFRFUlNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgZnVuY3Rpb24gZm9ybWF0UHJpY2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gJy0nO1xuICAgICAgcmV0dXJuIFxcYCRcXCR7dmFsdWUudG9GaXhlZCgyKX1cXGA7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGZvcm1hdENoYW5nZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAnLSc7XG4gICAgICBjb25zdCBzaWduID0gdmFsdWUgPj0gMCA/ICcrJyA6ICcnO1xuICAgICAgcmV0dXJuIFxcYFxcJHtzaWdufVxcJHt2YWx1ZS50b0ZpeGVkKDIpfVxcYDtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyY2VudCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAnLSc7XG4gICAgICBjb25zdCBzaWduID0gdmFsdWUgPj0gMCA/ICcrJyA6ICcnO1xuICAgICAgcmV0dXJuIFxcYFxcJHtzaWdufVxcJHt2YWx1ZS50b0ZpeGVkKDIpfSVcXGA7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGZvcm1hdFZvbHVtZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAnLSc7XG4gICAgICBpZiAodmFsdWUgPj0gMWU5KSByZXR1cm4gXFxgXFwkeyh2YWx1ZSAvIDFlOSkudG9GaXhlZCgyKX1CXFxgO1xuICAgICAgaWYgKHZhbHVlID49IDFlNikgcmV0dXJuIFxcYFxcJHsodmFsdWUgLyAxZTYpLnRvRml4ZWQoMil9TVxcYDtcbiAgICAgIGlmICh2YWx1ZSA+PSAxZTMpIHJldHVybiBcXGBcXCR7KHZhbHVlIC8gMWUzKS50b0ZpeGVkKDIpfUtcXGA7XG4gICAgICByZXR1cm4gdmFsdWUudG9GaXhlZCgwKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZm9ybWF0UlZPTCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiAnLSc7XG4gICAgICByZXR1cm4gXFxgXFwke3ZhbHVlLnRvRml4ZWQoMil9eFxcYDtcbiAgICB9XG4gICAgXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIElOSVRcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgXG4gICAgLy8gSW5pY2lhbGl6YXIgV2ViU29ja2V0XG4gICAgaW5pdFdlYlNvY2tldCgpO1xuICAgIFxuICAgIC8vIFNvbGljaXRhciBkYXRvcyBpbmljaWFsZXMgZGVsIHBhZHJlIChiYWNrdXAgc2kgV1MgZmFsbGEpXG4gICAgc2V0VGltZW91dChyZXF1ZXN0SW5pdGlhbERhdGEsIDUwMCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KchSBbSW5qZWN0ZWRXaW5kb3ddIEluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuICA8L3NjcmlwdD5cbjwvYm9keT5cbjwvaHRtbD5cbiAgYDtcblxuICAvLyBOTyB1c2FyIGRvY3VtZW50LndyaXRlIChibG9xdWVhbnRlKVxuICAvLyBFbiBzdSBsdWdhciwgcmVlbXBsYXphciBlbCBkb2N1bWVudG8gY29tcGxldG9cbiAgdGFyZ2V0V2luZG93LmRvY3VtZW50Lm9wZW4oKTtcbiAgdGFyZ2V0V2luZG93LmRvY3VtZW50LndyaXRlKGh0bWxDb250ZW50KTtcbiAgdGFyZ2V0V2luZG93LmRvY3VtZW50LmNsb3NlKCk7XG5cbiAgY29uc29sZS5sb2coJ+KchSBbV2luZG93SW5qZWN0b3JdIENvbnRlbnQgaW5qZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG59XG5cbi8qKlxuICogRXN0YWJsZWNlIGNvbXVuaWNhY2nDs24gY29uIHZlbnRhbmEgaGlqYSBwYXJhIGVudmlhcmxlIGRhdG9zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENoaWxkQ29tbXVuaWNhdGlvbihcbiAgY2hpbGRXaW5kb3c6IFdpbmRvdyxcbiAgb25DaGlsZFJlYWR5OiAoKSA9PiB2b2lkXG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgLy8gVmFsaWRhciBxdWUgZWwgbWVuc2FqZSB2aWVuZSBkZSBudWVzdHJhIHZlbnRhbmEgaGlqYVxuICAgIGlmIChldmVudC5zb3VyY2UgIT09IGNoaWxkV2luZG93KSByZXR1cm47XG5cbiAgICBjb25zdCB7IHR5cGUgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NoaWxkX3JlYWR5Jykge1xuICAgICAgY29uc29sZS5sb2coJ+KchSBbV2luZG93SW5qZWN0b3JdIENoaWxkIHdpbmRvdyBpcyByZWFkeScpO1xuICAgICAgb25DaGlsZFJlYWR5KCk7XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG5cbiAgLy8gUmV0b3JuYXIgZnVuY2nDs24gZGUgY2xlYW51cFxuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gIH07XG59XG5cbi8qKlxuICogRW52w61hIHNuYXBzaG90IGluaWNpYWwgYSBsYSB2ZW50YW5hIGhpamFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRTbmFwc2hvdFRvQ2hpbGQoXG4gIGNoaWxkV2luZG93OiBXaW5kb3csXG4gIHNuYXBzaG90OiBhbnlcbik6IHZvaWQge1xuICBpZiAoY2hpbGRXaW5kb3cgJiYgIWNoaWxkV2luZG93LmNsb3NlZCkge1xuICAgIGNoaWxkV2luZG93LnBvc3RNZXNzYWdlKFxuICAgICAge1xuICAgICAgICB0eXBlOiAnc25hcHNob3RfZGF0YScsXG4gICAgICAgIGRhdGE6IHNuYXBzaG90LFxuICAgICAgfSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW52w61hIGRlbHRhIHVwZGF0ZSBhIGxhIHZlbnRhbmEgaGlqYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VuZERlbHRhVG9DaGlsZChcbiAgY2hpbGRXaW5kb3c6IFdpbmRvdyxcbiAgZGVsdGE6IGFueVxuKTogdm9pZCB7XG4gIGlmIChjaGlsZFdpbmRvdyAmJiAhY2hpbGRXaW5kb3cuY2xvc2VkKSB7XG4gICAgY2hpbGRXaW5kb3cucG9zdE1lc3NhZ2UoXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdkZWx0YV91cGRhdGUnLFxuICAgICAgICBkYXRhOiBkZWx0YSxcbiAgICAgIH0sXG4gICAgICB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVudsOtYSBhZ2dyZWdhdGUgdXBkYXRlIGEgbGEgdmVudGFuYSBoaWphXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQWdncmVnYXRlVG9DaGlsZChcbiAgY2hpbGRXaW5kb3c6IFdpbmRvdyxcbiAgYWdncmVnYXRlOiBhbnlcbik6IHZvaWQge1xuICBpZiAoY2hpbGRXaW5kb3cgJiYgIWNoaWxkV2luZG93LmNsb3NlZCkge1xuICAgIGNoaWxkV2luZG93LnBvc3RNZXNzYWdlKFxuICAgICAge1xuICAgICAgICB0eXBlOiAnYWdncmVnYXRlX3VwZGF0ZScsXG4gICAgICAgIGRhdGE6IGFnZ3JlZ2F0ZSxcbiAgICAgIH0sXG4gICAgICB3aW5kb3cubG9jYXRpb24ub3JpZ2luXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVudsOtYSBlc3RhZG8gZGUgY29uZXhpw7NuIGEgbGEgdmVudGFuYSBoaWphXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQ29ubmVjdGlvblN0YXR1c1RvQ2hpbGQoXG4gIGNoaWxkV2luZG93OiBXaW5kb3csXG4gIGlzQ29ubmVjdGVkOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgaWYgKGNoaWxkV2luZG93ICYmICFjaGlsZFdpbmRvdy5jbG9zZWQpIHtcbiAgICBjaGlsZFdpbmRvdy5wb3N0TWVzc2FnZShcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb25fc3RhdHVzJyxcbiAgICAgICAgZGF0YTogeyBpc0Nvbm5lY3RlZCB9LFxuICAgICAgfSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICApO1xuICB9XG59XG5cbiJdLCJuYW1lcyI6WyJvcGVuSW5qZWN0ZWRXaW5kb3ciLCJkYXRhIiwiY29uZmlnIiwid2lkdGgiLCJoZWlnaHQiLCJjZW50ZXJlZCIsImxlZnQiLCJ3aW5kb3ciLCJzY3JlZW4iLCJ0b3AiLCJ3aW5kb3dGZWF0dXJlcyIsImpvaW4iLCJuZXdXaW5kb3ciLCJvcGVuIiwiY29uc29sZSIsImVycm9yIiwiaW5qZWN0Q29udGVudCIsInRhcmdldFdpbmRvdyIsInRpdGxlIiwib3JpZ2luIiwibG9jYXRpb24iLCJodG1sQ29udGVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkb2N1bWVudCIsIndyaXRlIiwiY2xvc2UiLCJsb2ciLCJzZXR1cENoaWxkQ29tbXVuaWNhdGlvbiIsImNoaWxkV2luZG93Iiwib25DaGlsZFJlYWR5IiwiaGFuZGxlTWVzc2FnZSIsImV2ZW50Iiwic291cmNlIiwidHlwZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2VuZFNuYXBzaG90VG9DaGlsZCIsInNuYXBzaG90IiwiY2xvc2VkIiwicG9zdE1lc3NhZ2UiLCJzZW5kRGVsdGFUb0NoaWxkIiwiZGVsdGEiLCJzZW5kQWdncmVnYXRlVG9DaGlsZCIsImFnZ3JlZ2F0ZSIsInNlbmRDb25uZWN0aW9uU3RhdHVzVG9DaGlsZCIsImlzQ29ubmVjdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/window-injector.ts\n"));

/***/ })

});